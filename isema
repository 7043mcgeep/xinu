4: * @return non-zero value on error
apps/date.c:    /* UTC-12 */
apps/date.c:    "", "", "H", "AK", "P", "M",        /* UTC-7 */
apps/date.c:    "C", "E", "A", "", "", ""   /* UTC-1 */
apps/date.c:    date_time = dt - clktime;
apps/date.c:    t->weekday = (1 + (seconds / SECS_IN_DAY)) % 7;
apps/date.c:    t->year = (seconds / SECS_IN_YEAR);
apps/date.c:    leapyear = ((t->year - 1) / 4 + (t->year - 1) / 100) * SECS_IN_DAY;
apps/date.c:    t->year = ((seconds - leapyear) / SECS_IN_YEAR);
apps/date.c:    seconds -= (t->year * SECS_IN_YEAR);
apps/date.c:    if (((0 == (t->year % 4)) && (0 != (t->year % 100)))
apps/date.c:        || (0 == ((1900 + t->year) % 400)))
apps/date.c:    t->yearday = (seconds / SECS_IN_DAY);
apps/date.c:    seconds -= ((t->yearday) * SECS_IN_DAY);
apps/date.c:    t->yearday -= t->year / 4;
apps/date.c:    t->yearday += t->year / 100;
apps/date.c:    t->yearday -= (((1900 + t->year) / 400) - 4);
apps/date.c:    t->yearday += leapday;
apps/date.c:    t->monthday = t->yearday;
apps/date.c:    /* yearday - days of the month loop */
apps/date.c:    for (t->month = 0; t->month < sizeof(days_in_month) - 1; t->month++)
apps/date.c:        if (1 == leapday && 1 == t->month)
apps/date.c:        if (t->monthday < days_in_month[t->month] + leapyear)
apps/date.c:        t->monthday -= days_in_month[t->month] + leapyear;
apps/date.c:    t->monthday += 1;
apps/date.c:    t->hour = (seconds / SECS_IN_HOUR);
apps/date.c:    seconds -= (t->hour * SECS_IN_HOUR);
apps/date.c:    t->minute = (seconds / SECS_IN_MIN);
apps/date.c:    seconds -= (t->minute * SECS_IN_MIN);
apps/date.c:    t->second = seconds;
apps/date.c:    t->is_dst = 0;
apps/date.c:    if (55 <= t->year && t->year <= 106)
apps/date.c:        if (4 < t->month && t->month < 8)
apps/date.c:            t->is_dst = 1;
apps/date.c:        else if (4 == t->month)
apps/date.c:            dst_day = (2 + 6 * t->year - t->year / 4) % 7 + 1;
apps/date.c:        else if (8 == t->month)
apps/date.c:            dst_day = (31 - (t->year * 5 / 4 + 1)) % 7;
apps/date.c:    else if (107 <= t->year)
apps/date.c:        if (3 < t->month && t->month < 9)
apps/date.c:            t->is_dst = 1;
apps/date.c:        else if (3 == t->month)
apps/date.c:            dst_day = 14 - (1 + t->year * 5 / 4) % 7;
apps/date.c:        else if (9 == t->month)
apps/date.c:            dst_day = 7 - (1 + t->year * 5 / 4) % 7;
apps/date.c:        t->is_dst = -1;         /* DST didn't exist */
apps/date.c:    if ((t->monthday == dst_day && 2 <= t->hour) || t->monthday > dst_day)
apps/date.c:        t->is_dst = 1;
apps/rdate.c:    interface = netLookup((ethertab[0].dev)->num);
apps/rdate.c:    localhost = &(interface->ip);
apps/timeserver.c: * @return non-zero value on error
apps/timeserver.c:    localhost = &(interface->ip);
apps/timeserver.c:        memcpy(remotehost.addr, pseudo->srcIp, remotehost.len);
apps/timeserver.c:        remoteport = udp->srcPort;
apps/timeserver.c:        memcpy(pseudo->srcIp, pseudo->dstIp, remotehost.len);
apps/timeserver.c:        memcpy(pseudo->dstIp, remotehost.addr, remotehost.len);
apps/timeserver.c:        pseudo->len += 4;
apps/timeserver.c:        udp->srcPort = udp->dstPort;
apps/timeserver.c:        udp->dstPort = remoteport;
apps/timeserver.c:        udp->len += 4;
apps/timeserver.c:        memcpy(udp->data, &time, sizeof(time));
apps/timeserver.c:        /*         pseudo->srcIp[0], */
apps/timeserver.c:        /*         pseudo->srcIp[1], */
apps/timeserver.c:        /*         pseudo->srcIp[2], */
apps/timeserver.c:        /*         pseudo->srcIp[3]); */
apps/timeserver.c:        /* printf(":%d -> ", udp->srcPort); */
apps/timeserver.c:        /*         pseudo->dstIp[0], */
apps/timeserver.c:        /*         pseudo->dstIp[1], */
apps/timeserver.c:        /*         pseudo->dstIp[2], */
apps/timeserver.c:        /*         pseudo->dstIp[3]); */
apps/timeserver.c:        /* printf(":%d 0x%08X %d\n", udp->dstPort, time, time); */
Binary file apps/timeserver.o matches
apps/timeserver.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
apps/timeserver.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
apps/timeserver.d:../system/platforms/arm-rpi3/interrupt.h:
apps/timeserver.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file apps/date.o matches
apps/date.d: ../system/platforms/arm-rpi3/interrupt.h \
apps/date.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
apps/date.d:../system/platforms/arm-rpi3/interrupt.h:
apps/date.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file apps/rdate.o matches
apps/rdate.d: ../system/platforms/arm-rpi3/interrupt.h \
apps/rdate.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
apps/rdate.d:../system/platforms/arm-rpi3/interrupt.h:
apps/rdate.d:../system/platforms/arm-rpi3/bcm2837.h:
AUTHORS:Comer and Prentice Hall, and ran on the LSI-11 platform.  The VAX port
AUTHORS:ANSI-compliant C on an embedded RISC architecture.  The MIPS port of
AUTHORS:National Science Foundation (Grant DUE-CCLI-0737476).
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:# that follow. The default is UTF-8 which is also the encoding used for all
compile/Doxyfile:DOXYFILE_ENCODING      = UTF-8
compile/Doxyfile:# 4096 sub-directories (in 2 levels) under the output directory of each output
compile/Doxyfile:# Afrikaans, Arabic, Brazilian, Catalan, Chinese, Chinese-Traditional,
compile/Doxyfile:# Greek, Hungarian, Italian, Japanese, Japanese-en (Japanese with English
compile/Doxyfile:# messages), Korean, Korean-en, Lithuanian, Norwegian, Macedonian, Persian,
compile/Doxyfile:# Polish, Portuguese, Romanian, Russian, Serbian, Serbian-Cyrillic, Slovak,
compile/Doxyfile:# This tag implements a quasi-intelligent brief description abbreviator
compile/Doxyfile:# used as the annotated text. Otherwise, the brief description is used as-is.
compile/Doxyfile:# can be used to strip a user-defined part of the path. Stripping is
compile/Doxyfile:# only done if one of the specified strings matches the left-hand part of
compile/Doxyfile:# The STRIP_FROM_INC_PATH tag can be used to strip a user-defined part of
compile/Doxyfile:# are normally passed to the compiler using the -I flag.
compile/Doxyfile:# doesn't support long names like on DOS, Mac, or CD-ROM.
compile/Doxyfile:# will interpret the first line (until the first dot) of a JavaDoc-style
compile/Doxyfile:# comments will behave just like regular Qt-style comments
compile/Doxyfile:# interpret the first line (until the first dot) of a Qt-style
compile/Doxyfile:# will behave just like regular Qt-style comments (thus requiring
compile/Doxyfile:# treat a multi-line C++ special comment block (i.e. a block of //! or ///
compile/Doxyfile:# The new default is to treat a multi-line C++ comment block as a detailed
compile/Doxyfile:# re-implements.
compile/Doxyfile:# will result in a user-defined paragraph with heading "Side Effects:".
compile/Doxyfile:# Doxygen has a built-in mapping, but you can override or extend it using this
compile/Doxyfile:# C++, D, PHP, Objective-C, Python, Fortran, VHDL, C, C++. For instance to make
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:# This flag is only useful for Objective-C code. When set to YES local
compile/Doxyfile:# file names in lower-case letters. If set to YES upper-case letters are also
compile/Doxyfile:# sorted by fully-qualified names, including namespaces. If set to
compile/Doxyfile:# popen()) the command <command> <input-file>, where <command> is the value of
compile/Doxyfile:# the FILE_VERSION_FILTER tag, and <input-file> is the name of an input file
compile/Doxyfile:# that represents doxygen's defaults, run doxygen with the -l option.
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:# that doxygen parses. Internally doxygen uses the UTF-8 encoding, which is
compile/Doxyfile:INPUT_ENCODING         = UTF-8
compile/Doxyfile:# and *.h) to filter out the source-files in the directories. If left
compile/Doxyfile:# and *.h) to filter out the source-files in the directories. If left
compile/Doxyfile:# by executing (via popen()) the command <filter> <input-file>, where <filter>
compile/Doxyfile:# is the value of the INPUT_FILTER tag, and <input-file> is the name of an
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:# be generated. Documented entities will be cross-referenced with these sources.
compile/Doxyfile:# built-in source browser. The htags tool is part of GNU's global source
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:# It is adviced to generate a default header using "doxygen -w html
compile/Doxyfile:# The HTML_STYLESHEET tag can be used to specify a user-defined cascading
compile/Doxyfile:# fine-tune the look of the HTML output. If the tag is left blank doxygen
compile/Doxyfile:# the files will be copied as-is; there are no commands or markers available.
compile/Doxyfile:# reverse domain-name style string, e.g. com.mycompany.MyDocSet. Doxygen
compile/Doxyfile:# the documentation publisher. This should be a reverse domain-name style
compile/Doxyfile:# the HTML help compiler (hhc.exe). If non-empty doxygen will try to run
compile/Doxyfile:# http://doc.trolltech.com/qthelpproject.html#virtual-folders
compile/Doxyfile:# http://doc.trolltech.com/qthelpproject.html#custom-filters
compile/Doxyfile:# <a href="http://doc.trolltech.com/qthelpproject.html#custom-filters">
compile/Doxyfile:# <a href="http://doc.trolltech.com/qthelpproject.html#filter-attributes">
compile/Doxyfile:# If non-empty doxygen will try to run qhelpgenerator on the generated
compile/Doxyfile:# The GENERATE_TREEVIEW tag is used to specify whether a tree-like index
compile/Doxyfile:# containing a tree-like index structure (just like the one that
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:# and cross-referencing information) to the XML output. Note that
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:# evaluate all C-preprocessor directives found in the sources and include
compile/Doxyfile:# patterns (like *.h and *.hpp) to filter out the header-files in the
compile/Doxyfile:# are defined before the preprocessor is started (similar to the -D option of
compile/Doxyfile:# doxygen's preprocessor will remove all references to function-like macros
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:#---------------------------------------------------------------------------
compile/Doxyfile:# enabling this option may lead to badly anti-aliased labels on the edges of
compile/Doxyfile:# files in one run (i.e. multiple -o and -T options on the command line). This
compile/Makefile:# $ make PLATFORM=arm-rpi
compile/Makefile:PLATFORM := arm-rpi3
compile/Makefile:# Top-level Embedded Xinu directory
compile/Makefile:CFLAGS  += -c
compile/Makefile:CFLAGS  += -Os
compile/Makefile:#C_FLAGS += -O0
compile/Makefile:CFLAGS  += -Wall
compile/Makefile:CFLAGS  += -Wstrict-prototypes
compile/Makefile:CFLAGS  += -nostdinc
compile/Makefile:CFLAGS  += -fno-builtin
compile/Makefile:CFLAGS  += -fno-strict-aliasing
compile/Makefile:CFLAGS  += -fno-common
compile/Makefile:# collection to remove unused functions (the --gc-sections linker flag).
compile/Makefile:CFLAGS  += -ffunction-sections
compile/Makefile:# Do not generate position-independent code.  (This flag may be unneeded, since
compile/Makefile:# generally you have to specify -fPIC to *get* the compiler to generate
compile/Makefile:# position-independent code).
compile/Makefile:CFLAGS  += -fno-pic
compile/Makefile:CFLAGS  += -fwrapv
compile/Makefile:# flags if needed.  Do not use the "-Wa," prefix, either here or in
compile/Makefile:# Note: this -I option is not used for C headers; instead it's used in case the
compile/Makefile:ASFLAGS := -I$(TOPDIR)/system/platforms/$(PLATFORM)
compile/Makefile:# flags if needed.  Do not use the "-Wl," prefix either here on in platformVars.
compile/Makefile:LDFLAGS := --static --gc-sections
compile/Makefile:# Set default external libraries.  Embedded Xinu is, of course, stand-alone and
compile/Makefile:# platformVars can add -lgcc to this if needed by the platform.
compile/Makefile:INCLUDE := -I$(TOPDIR)/include -I$(TOPDIR)/system/platforms/$(PLATFORM) -I$(TOPDIR)
compile/Makefile:# Override this as -DDETAIL to enable certain debugging messages in Embedded
compile/Makefile:# Include the platform-specific Makefile.
compile/Makefile:ASFLAG_PREFIX := -Wa,
compile/Makefile:ASFLAGS       += $(INCLUDE) $(DEFS) -c
compile/Makefile:  CFLAGS += -DHAVE_TESTSUITE=1
compile/Makefile:  CFLAGS += -DHAVE_TESTSUITE=0
compile/Makefile:  CFLAGS += -DHAVE_SHELL=1
compile/Makefile:  CFLAGS += -DHAVE_SHELL=0
compile/Makefile:  ifeq ($(shell if [ -e arch/$(TEMPLATE_ARCH)/ld.script ]; then echo 1; fi),1)
compile/Makefile:ifeq ($(shell if [ -e platforms/$(PLATFORM)/ld.script ]; then echo 1; fi),1)
compile/Makefile:  LDFLAGS += -T$(LDSCRIPT)
compile/Makefile:# Set the location of the architecture-specific cross-compiler and binutils.
compile/Makefile:# make PLATFORM=arm-rpi COMPILER_ROOT=/opt/arm-dev/bin/arm-none-eabi-
compile/Makefile:LD       := $(COMPILER_ROOT)ld -Map test.map
compile/Makefile:ifneq ($(shell if $(CC) --version &> /dev/null; then echo 1; fi),1)
compile/Makefile:# Did platformVars add -lgcc to LDLIBS?  If so, we need to do the linking with
compile/Makefile:# linker and adding -nostdlib to prevent gcc from linking in the C runtime
compile/Makefile:ifneq ($(filter -lgcc,$(LDLIBS)),)
compile/Makefile:  LDFLAGS_PREFIX := -Wl,
compile/Makefile:  LDFLAGS        += -nostdlib
compile/Makefile:# Path to platform-specific configuration file
compile/Makefile:DEPFLAGS := -MMD -MP
compile/Makefile:INDENT_TYPES := -T uchar -T ushort -T uint -T ulong -T bool -T message    \
compile/Makefile:               -T irqmask -T semaphore -T mailbox -T qid_type -T tid_typ \
compile/Makefile:               -T syscall -T devcall -T shellcmd -T thread -T interrupt  \
compile/Makefile:               -T device
compile/Makefile:INDENT_ARGS := -npro -kr -bl -blf -bls -bli0 -nce -ncs -nlps -l74 -lc74 -nut
compile/Makefile:INDENT_FILES := $(shell find $(TOPDIR) -name '*.[ch]')
compile/Makefile:	@echo -e "\tLinking" $@
compile/Makefile:	$(KERNEL_LD) -o $@ $(LDFLAGS) $^ $(LDLIBS)
compile/Makefile:# (This is not true with non-generated headers, for which the build system
compile/Makefile:	rm -f $(KERNARC)
compile/Makefile:	@echo -e "\tCompiling" $@
compile/Makefile:	$(CC) $(DEPFLAGS) $(CFLAGS) -o $@ $<
compile/Makefile:	@echo -e "\tAssembling" $@
compile/Makefile:	$(CC) $(DEPFLAGS) $(ASFLAGS) -o $@ $<
compile/Makefile:	@echo -e "\tCleaning all objects"
compile/Makefile:	rm -f *.o $(COMP_OBJ) $(CONF_OBJ) $(MAIN_OBJ) $(DATA_OBJ) $(USRTHRS_OBJ)
compile/Makefile:	rm -f $(DEPFILES)
compile/Makefile:	rm -f xinu.boot xinu.bin xinu.elf
compile/Makefile:	@echo -e "\tIndenting sources"
compile/Makefile:	rm -f $(INDENT_FILES:%=%~)
compile/Makefile:ifneq ($(filter uart-%,$(DEVICES)),)
compile/Makefile:	@echo -e "\tBuilding debug mode"
compile/Makefile:	$(MAKE) DEBUG="-DDEBUG $(BUGFLAG)"
compile/Makefile:libclean: $(LIBS:%=%-clean)
compile/Makefile:	@echo -e "\tCleaning configuration"
compile/Makefile:	$(MAKE) -C config/ clean
compile/Makefile:	@echo -e "\tCleaning EVERYTHING"
compile/Makefile:	rm -f ../include/conf.h
compile/Makefile:	rm -f ../system/conf.c
compile/Makefile:	rm -f vn version $(TOPDIR)/include/version.h
compile/Makefile:	rm -f Makefile.bak
compile/Makefile:	@echo -e "\tBuilding" $@
compile/Makefile:	@echo -e "\tObject Copy" $@
compile/Makefile:	@echo -e "\tConfiguring" $@
compile/Makefile:	@echo -e "\tBuilding" $@
compile/Makefile:	$(MAKE) -C config/
compile/Makefile:	@echo -e "\tBuilding" $@
compile/Makefile:	$(MAKE) -C $(LIBDIR)/$@
compile/Makefile:	@echo -e "\tInstalling" $@
compile/Makefile:	$(MAKE) -C $(@:%.a=%) install
compile/Makefile:$(LIBS:%=%-clean):
compile/Makefile:	@echo -e "\tCleaning" $@
compile/Makefile:	$(MAKE) -C $(LIBDIR)/$(@:%-clean=%) clean
compile/Makefile:-include $(DEPFILES)
compile/Makefile:# Ensure the default `make' target is set correctly--- it's supposed to be
compile/arch/arm/platformVars:ARCH_PREFIX   := arm-none-eabi-
compile/arch/arm/platformVars:BUGFLAG       := -gstabs+
compile/arch/arm/platformVars:LDLIBS        += -lgcc
compile/arch/arm/platformVars:OCFLAGS       := -I binary -O elf32-littlearm -B arm
compile/arch/arm/platformVars:DEFS          += -D_XINU_ARCH_ARM_
compile/arch/arm/platformVars:	$(OBJCOPY) -O binary $^ $@
compile/arch/mips/ld.script:		*(.rodata .rodata.*) /* asm and C read-only data              */
compile/arch/mips/ld.script:	* ".note.gnu.build-id" section before _start!  */
compile/arch/mips/platformVars:  ARCH_PREFIX   := mipsel-
compile/arch/mips/platformVars:  ARCH_PREFIX   := mips-
compile/arch/mips/platformVars:BUGFLAG  := -gstabs+
compile/arch/mips/platformVars:# Additional platform-specific compiler and assembler flags.
compile/arch/mips/platformVars:CFLAGS   += -march=$(MIPS_ISA_FLAG) -Wa,-march=$(MIPS_ISA_FLAG) \
compile/arch/mips/platformVars:            -Wa,-$(MIPS_ISA_FLAG)                               \
compile/arch/mips/platformVars:	    -fomit-frame-pointer -G 0 -mlong-calls              \
compile/arch/mips/platformVars:	    -mno-abicalls -mabi=32 -Wa,--trap -Wa,-32
compile/arch/mips/platformVars:ASFLAGS  += -march=$(MIPS_ISA_FLAG) -$(MIPS_ISA_FLAG)
compile/arch/mips/platformVars:DEFS += -D_XINU_ARCH_MIPS_
compile/arch/mips/platformVars:  DEFS += -D_XINU_ARCH_MIPSEL_
compile/arch/mips/platformVars:  MIPS_BFDARCH := elf32-littlemips
compile/arch/mips/platformVars:  MIPS_BFDARCH := elf32-bigmips
compile/arch/mips/platformVars:OCFLAGS       := -I binary -O $(MIPS_BFDARCH) -B mips
compile/arch/mips/platformVars:# Use the ELF-format kernel as the final build target, unless the specific
compile/arch/x86/platformVars:BUGFLAG       := -gstabs+
compile/arch/x86/platformVars:OCFLAGS       := -I binary -O elf32-i386 -B i386
compile/arch/x86/platformVars:DEFS          += -D_XINU_ARCH_X86_
compile/arch/x86/platformVars:	$(OBJCOPY) -O binary $^ $@
compile/arch/aarch64/platformVars:ARCH_PREFIX := arm-none-eabi-
compile/arch/aarch64/platformVars:BUGFLAG     := -gstabs+
compile/arch/aarch64/platformVars:DEFS        += -D_XINU_ARCH_ARM_
compile/arch/aarch64/platformVars:	$(OBJCOPY) -O binary $^ $@
compile/config/Makefile:YACC    = bison -y    # Flag enables yacc-compatible filenames
compile/config/Makefile:YFLAGS  = -d
compile/config/Makefile:	rm -f $(CONFIG) *.o y.tab.h parse.c
compile/config/config.c:    return(p ? p-s : n);
compile/config/config.c:int   currname = -1;
compile/config/config.c:int   currtname = -1;
compile/config/config.c:int   currdname = -1;
compile/config/config.c:	if ( argc > 1 && (strncmp("-v", argv[1], 2) == 0) )
compile/config/config.c:		argc--;
compile/config/config.c:		fprintf(stderr, "use: config [-v] [file]\n");
compile/config/config.c:	for (i = 0, s = devs; s != NIL; i++, s = s->next)
compile/config/config.c:		fprintf(confh, "#define %-12s%d       /* type %-8s */\n",
compile/config/config.c:		        s->name, i, s->tname);
compile/config/config.c:		s->minor = symtab[s->tnum].occurs++;
compile/config/config.c:			" * dev-number, minor-number, dev-name,",
compile/config/config.c:			" * dev-csr-address, intr-handler, irq",
compile/config/config.c:	for (fcount = 0, s = devs; s != NIL; fcount++, s = s->next)
compile/config/config.c:		fprintf(confc, "/* %s is %s */\n", s->name, s->tname);
compile/config/config.c:		fprintf(confc, "\t{ %d, %d, \"%s\",\n", fcount, s->minor, s->name);
compile/config/config.c:		        s->init, s->open, s->close);
compile/config/config.c:		        s->read, s->write, s->seek);
compile/config/config.c:		        s->getc, s->putc, s->control);
compile/config/config.c:		        s->csr, s->intr, s->irq);
compile/config/config.c:		if ( s->next != NIL ) { fprintf(confc, ",\n\n"); }
compile/config/config.c:		for (s = devs; s != NIL ; s = s->next)
compile/config/config.c:			printf("Device %s (on %s)\n", s->name, s->device);
compile/config/config.c:			       s->csr, s->irq, s->minor);
compile/config/config.c:/* lookup  --  lookup a name in the symbol table; return position */
compile/config/config.c:		len = CONFMAXNM-1;
compile/config/config.c:/* newattr -- add a new attribute spec to current type/device description */
compile/config/config.c:	case CSR:     s->csr = val;                      break;
compile/config/config.c:	case IRQ:     s->irq = val;                      break;
compile/config/config.c:	case INTR:    strncpy(s->intr,    c, CONFMAXNM); break;
compile/config/config.c:	case READ:    strncpy(s->read,    c, CONFMAXNM); break;
compile/config/config.c:	case WRITE:   strncpy(s->write,   c, CONFMAXNM); break;
compile/config/config.c:	case GETC:    strncpy(s->getc,    c, CONFMAXNM); break;
compile/config/config.c:	case PUTC:    strncpy(s->putc,    c, CONFMAXNM); break;
compile/config/config.c:	case OPEN:    strncpy(s->open,    c, CONFMAXNM); break;
compile/config/config.c:	case CLOSE:   strncpy(s->close,   c, CONFMAXNM); break;
compile/config/config.c:	case INIT:    strncpy(s->init,    c, CONFMAXNM); break;
compile/config/config.c:	case SEEK:    strncpy(s->seek,    c, CONFMAXNM); break;
compile/config/config.c:	case CONTROL: strncpy(s->control, c, CONFMAXNM); break;
compile/config/config.c:/* cktname  --  check type name for duplicates */
compile/config/config.c:	for (s = ftypes; s != NIL; s = s->next)
compile/config/config.c:		if (s->tname == name)
compile/config/config.c:/* mktype  --  make a node in the type list and initialize to defaults */
compile/config/config.c:	for (s = ftypes; s != NIL ; s = s->next)
compile/config/config.c:		if (s->tname == tn && s->device==dn)
compile/config/config.c:	if (ftypes != NIL) { p->next = s; }
compile/config/config.c:	fstr->name = NULL;
compile/config/config.c:	fstr->tname = symtab[tnum].name;
compile/config/config.c:	fstr->tnum = tnum;
compile/config/config.c:	fstr->device = symtab[deviceid].name;
compile/config/config.c:	fstr->csr = 0;
compile/config/config.c:	fstr->irq = 0;
compile/config/config.c:	strncpy(fstr->intr,    "ioerr", 5);
compile/config/config.c:	strncpy(fstr->init,    "ioerr", 5);
compile/config/config.c:	strncpy(fstr->open,    "ioerr", 5);
compile/config/config.c:	strncpy(fstr->close,   "ioerr", 5);
compile/config/config.c:	strncpy(fstr->read,    "ioerr", 5);
compile/config/config.c:	strncpy(fstr->write,   "ioerr", 5);
compile/config/config.c:	strncpy(fstr->control, "ioerr", 5);
compile/config/config.c:	strncpy(fstr->seek,    "ioerr", 5);
compile/config/config.c:	strncpy(fstr->getc,    "ioerr", 5);
compile/config/config.c:	strncpy(fstr->putc,    "ioerr", 5);
compile/config/config.c:	fstr->minor = 0;
compile/config/config.c:/* mkdev  --  make a node on the device list */
compile/config/config.c:	s->next = NIL;
compile/config/config.c:		lastdv->next = s;
compile/config/config.c:	for (s = ftypes; s != NULL ; s = s->next)
compile/config/config.c:		if (s->tname == tn && (dn == NULL || s->device == dn))
compile/config/config.c:	lastdv->next = NIL;
compile/config/config.c:	lastdv->name = devn;
compile/config/config.c:/* chdname  -- check for duplicate device name */
compile/config/config.c:	for (s = devs; s != NIL; s = s->next)
compile/config/config.c:		if (s->name == name)
compile/config/scan.l:OCT 0[0-7]*
compile/config/scan.l:DEC [1-9][0-9]*
compile/config/scan.l:HEX 0x[0-9a-fA-F]+
compile/config/scan.l:ID [a-z_A-Z][a-z_A-Z0-9]*
compile/config/scan.l: * -lfl. */
compile/config/scan.l:/* Exclusive start condition (within a comment--- most parsing rules don't
compile/config/scan.l: * configuration file --- copied directly to the output conf.h) */
compile/config/scan.l:-?intr    { return INTR;      }
compile/config/scan.l:-?csr     { return CSR;       }
compile/config/scan.l:-?irq     { return IRQ;       }
compile/config/scan.l:-?i       { return INIT;      }
compile/config/scan.l:-?o       { return OPEN;      }
compile/config/scan.l:-?c       { return CLOSE;     }
compile/config/scan.l:-?r       { return READ;      }
compile/config/scan.l:-?g       { return GETC;      }
compile/config/scan.l:-?p       { return PUTC;      }
compile/config/scan.l:-?w       { return WRITE;     }
compile/config/scan.l:-?s       { return SEEK;      }
compile/config/scan.l:-?n       { return CONTROL;   }
Binary file compile/config/parse.o matches
compile/config/y.tab.h:/* Bison interface for Yacc-like parsers in C
compile/config/y.tab.h:   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
compile/config/parse.c:/* Bison implementation for Yacc-like parsers in C
compile/config/parse.c:   Copyright (C) 1984, 1989-1990, 2000-2015 Free Software Foundation, Inc.
compile/config/parse.c:   simplifying the original so-called "semantic" parser.  */
compile/config/parse.c:#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
compile/config/parse.c:#   define YY_(Msgid) dgettext ("bison-runtime", Msgid)
compile/config/parse.c:/* Suppress unused-variable warnings by "using" E.  */
compile/config/parse.c:    _Pragma ("GCC diagnostic ignored \"-Wuninitialized\"")\
compile/config/parse.c:    _Pragma ("GCC diagnostic ignored \"-Wmaybe-uninitialized\"")
compile/config/parse.c:   /* Pacify GCC's 'empty if-body' warning.  */
compile/config/parse.c:       to allow for a few compiler-allocated temporary stack slots.  */
compile/config/parse.c:# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
compile/config/parse.c:        YYCOPY (&yyptr->Stack_alloc, Stack, yysize);                    \
compile/config/parse.c:        Stack = &yyptr->Stack_alloc;                                    \
compile/config/parse.c:/* YYFINAL -- State number of the termination state.  */
compile/config/parse.c:/* YYLAST -- Last index in YYTABLE.  */
compile/config/parse.c:/* YYNTOKENS -- Number of terminals.  */
compile/config/parse.c:/* YYNNTS -- Number of nonterminals.  */
compile/config/parse.c:/* YYNRULES -- Number of rules.  */
compile/config/parse.c:/* YYNSTATES -- Number of states.  */
compile/config/parse.c:/* YYTRANSLATE[YYX] -- Symbol number corresponding to YYX as returned
compile/config/parse.c:   by yylex, with out-of-bounds checking.  */
compile/config/parse.c:/* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
compile/config/parse.c:   as returned by yylex, without out-of-bounds checking.  */
compile/config/parse.c:  /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
compile/config/parse.c:/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
compile/config/parse.c:/* YYTOKNUM[NUM] -- (External) token number corresponding to the
compile/config/parse.c:#define YYPACT_NINF -17
compile/config/parse.c:  (!!((Yystate) == (-17)))
compile/config/parse.c:#define YYTABLE_NINF -1
compile/config/parse.c:  /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
compile/config/parse.c:     STATE-NUM.  */
compile/config/parse.c:     -17,     3,   -17,    -1,   -17,     2,   -17,   -17,   -17,   -12,
compile/config/parse.c:       5,   -17,   -17,   -17,   -10,     2,   -12,   -17,   -17,    23,
compile/config/parse.c:       2,   -17,   -17,    23,     8,     9,     2,     2,     2,     2,
compile/config/parse.c:       2,     2,     2,     2,     2,     2,   -17,    -3,    23,   -17,
compile/config/parse.c:     -17,   -17,   -17,   -17,   -17,   -17,   -17,   -17,   -17,   -17,
compile/config/parse.c:     -17,     2,   -17,   -17
compile/config/parse.c:  /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
compile/config/parse.c:  /* YYPGOTO[NTERM-NUM].  */
compile/config/parse.c:     -17,   -17,   -17,   -17,   -17,   -17,    -7,   -17,    -5,   -16,
compile/config/parse.c:     -17,   -17,   -17,   -17,   -17,   -17
compile/config/parse.c:  /* YYDEFGOTO[NTERM-NUM].  */
compile/config/parse.c:      -1,     1,     2,     3,     8,    16,    17,     9,    10,    19,
compile/config/parse.c:  /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
compile/config/parse.c:      15,     6,     4,     4,    -1,    20,    19,    -1,    -1,    -1,
compile/config/parse.c:      -1,    26,    27,    28,    29,    30,    31,    32,    33,    34,
compile/config/parse.c:      17,    -1,    -1,    20,    21,    -1,    51
compile/config/parse.c:  /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
compile/config/parse.c:     symbol of state STATE-NUM.  */
compile/config/parse.c:  /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
compile/config/parse.c:  /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
compile/config/parse.c:#define YYEMPTY         (-2)
compile/config/parse.c:/*----------------------------------------.
compile/config/parse.c:`----------------------------------------*/
compile/config/parse.c:/*--------------------------------.
compile/config/parse.c:`--------------------------------*/
compile/config/parse.c:/*------------------------------------------------------------------.
compile/config/parse.c:| yy_stack_print -- Print the state stack from its BOTTOM up to its |
compile/config/parse.c:`------------------------------------------------------------------*/
compile/config/parse.c:/*------------------------------------------------.
compile/config/parse.c:`------------------------------------------------*/
compile/config/parse.c:             yyrule - 1, yylno);
compile/config/parse.c:                       yystos[yyssp[yyi + 1 - yynrhs]],
compile/config/parse.c:                       &(yyvsp[(yyi + 1) - (yynrhs)])
compile/config/parse.c:/* YYINITDEPTH -- initial size of the parser's stacks.  */
compile/config/parse.c:/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
compile/config/parse.c:   if the built-in stack extension method is used).
compile/config/parse.c:   evaluated with infinite-precision integer arithmetic.  */
compile/config/parse.c:  return yyd - 1;
compile/config/parse.c:   heuristic is that double-quoting is unnecessary unless the string
compile/config/parse.c:   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
compile/config/parse.c:  return yystpcpy (yyres, yystr) - yyres;
compile/config/parse.c:     - If this state is a consistent state with a default action, then
compile/config/parse.c:     - The only way there can be no lookahead present (in yychar) is if
compile/config/parse.c:     - Don't assume there isn't a lookahead just because this state is a
compile/config/parse.c:       previous inconsistent state, consistent state with a non-default
compile/config/parse.c:     - Of course, the expected token list depends on states to have
compile/config/parse.c:          /* Start YYX at -YYN if negative to avoid negative indexes in
compile/config/parse.c:             YYCHECK.  In other words, skip the first -YYN actions for
compile/config/parse.c:          int yyxbegin = yyn < 0 ? -yyn : 0;
compile/config/parse.c:          int yychecklim = YYLAST - yyn + 1;
compile/config/parse.c:/*-----------------------------------------------.
compile/config/parse.c:`-----------------------------------------------*/
compile/config/parse.c:/*----------.
compile/config/parse.c:`----------*/
compile/config/parse.c:#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
compile/config/parse.c:/*------------------------------------------------------------.
compile/config/parse.c:| yynewstate -- Push a new state, which is found in yystate.  |
compile/config/parse.c:`------------------------------------------------------------*/
compile/config/parse.c:  if (yyss + yystacksize - 1 <= yyssp)
compile/config/parse.c:      YYSIZE_T yysize = yyssp - yyss + 1;
compile/config/parse.c:      yyssp = yyss + yysize - 1;
compile/config/parse.c:      yyvsp = yyvs + yysize - 1;
compile/config/parse.c:      if (yyss + yystacksize - 1 <= yyssp)
compile/config/parse.c:/*-----------.
compile/config/parse.c:`-----------*/
compile/config/parse.c:      yyn = -yyn;
compile/config/parse.c:    yyerrstatus--;
compile/config/parse.c:/*-----------------------------------------------------------.
compile/config/parse.c:| yydefault -- do the default action for the current state.  |
compile/config/parse.c:`-----------------------------------------------------------*/
compile/config/parse.c:/*-----------------------------.
compile/config/parse.c:| yyreduce -- Do a reduction.  |
compile/config/parse.c:`-----------------------------*/
compile/config/parse.c:  yyval = yyvsp[1-yylen];
compile/config/parse.c:    {(yyval.intval) = currtname = cktname((yyvsp[-1].intval)); }
compile/config/parse.c:    { mkdev((yyvsp[-3].intval), (yyvsp[-1].intval), (yyvsp[0].intval)); }
compile/config/parse.c:  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
compile/config/parse.c:  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
compile/config/parse.c:    yystate = yydefgoto[yyn - YYNTOKENS];
compile/config/parse.c:/*--------------------------------------.
compile/config/parse.c:| yyerrlab -- here on detecting error.  |
compile/config/parse.c:`--------------------------------------*/
compile/config/parse.c:/*---------------------------------------------------.
compile/config/parse.c:| yyerrorlab -- error raised explicitly by YYERROR.  |
compile/config/parse.c:`---------------------------------------------------*/
compile/config/parse.c:/*-------------------------------------------------------------.
compile/config/parse.c:| yyerrlab1 -- common code for both syntax error and YYERROR.  |
compile/config/parse.c:`-------------------------------------------------------------*/
compile/config/parse.c:/*-------------------------------------.
compile/config/parse.c:| yyacceptlab -- YYACCEPT comes here.  |
compile/config/parse.c:`-------------------------------------*/
compile/config/parse.c:/*-----------------------------------.
compile/config/parse.c:| yyabortlab -- YYABORT comes here.  |
compile/config/parse.c:`-----------------------------------*/
compile/config/parse.c:/*-------------------------------------------------.
compile/config/parse.c:| yyexhaustedlab -- memory exhaustion comes here.  |
compile/config/parse.c:`-------------------------------------------------*/
Binary file compile/config/scan.o matches
Binary file compile/config/config matches
Binary file compile/config/config.o matches
Binary file compile/data/mytar.tar matches
compile/data/pcap-bigmips.c: * @file     pcap-bigmips.c
compile/data/pcap-bigmips.c: * This standalone UNIX utility is meant to run on a little-endian
compile/data/pcap-bigmips.c: *  with little-endian metadata into big-endian metadata.
compile/data/pcap-bigmips.c: *  (big-endian) both before and after this conversion.
compile/data/pcap-bigmips.c: * Rewrites files with little-endian PCAP metadata to be big-endian.
compile/data/pcap-bigmips.c:        fseek(stream, -sizeof(bigendpkt), SEEK_CUR);
compile/data/pcap-bigmips.c:        exit(-1);
compile/data/testsnoop.txt:# (1) arp who-has 192.168.6.2 tell 192.168.6.1
compile/data/testsnoop.txt:# (2) arp who-has 192.168.6.6 tell 192.168.6.1
compile/data/testsnoop.txt:# (3) arp reply 192.168.6.6 is-at AA:BB:CC:DD:EE:FF
compile/data/testsnoop.txt:# (14) arp who-has 192.168.6.2 tell 192.168.6.6
compile/data/testsnoop.txt:# (15) arp who-has 192.168.6.2 tell 192.168.6.3
compile/data/testsnoop.txt:# (16) arp who-has 192.168.6.2 tell 192.168.6.6
compile/data/testsnoop.txt:# (17) arp reply 192.168.6.2 is-at AA:BB:CC:DD:EE:BB
compile/mkvers.sh:if [ -f vn ]; then
compile/mkvers.sh:if [ -z "$USER" ]; then
compile/platforms/arm-qemu/ld.script: * This is the linker script for the Xinu kernel on the arm-qemu platform, where
compile/platforms/arm-qemu/ld.script: * the --gc-sections option, which removes all sections not reachable from the
compile/platforms/arm-qemu/ld.script: * To be safe, we ensure that every section is aligned on a 64-byte (cache line)
compile/platforms/arm-qemu/ld.script:     * ".note.gnu.build-id" section before _start!  */
compile/platforms/arm-qemu/platformVars:# Platform-specific Makefile definitions for the ARM QEMU (emulating an ARM
compile/platforms/arm-qemu/platformVars:# Note: When running the resulting kernel With qemu-system-arm, use the option
compile/platforms/arm-qemu/platformVars:# '-cpu arm1176'.  Although QEMU can emulate many different ARM CPUs, ARM1176 is
compile/platforms/arm-qemu/platformVars:# Xinu platform "arm-rpi").
compile/platforms/arm-qemu/platformVars:CFLAGS   += -mcpu=arm1176jz-s
compile/platforms/arm-qemu/platformVars:ASFLAGS  += -mcpu=arm1176jz-s
compile/platforms/arm-qemu/platformVars:DEFS     += -D_XINU_PLATFORM_ARM_QEMU_
compile/platforms/arm-qemu/platformVars:DEVICES  := loopback tty uart-pl011
compile/platforms/arm-qemu/xinu.conf:/* Configuration - (device configuration specifications)  */
compile/platforms/arm-qemu/xinu.conf:/*  -i    init          -o    open      -c    close       */
compile/platforms/arm-qemu/xinu.conf:/*  -r    read          -g    getc      -p    putc        */
compile/platforms/arm-qemu/xinu.conf:/*  -w    write         -s    seek      -n    control     */
compile/platforms/arm-qemu/xinu.conf:/*  -intr interrupt     -csr  csr       -irq  irq         */
compile/platforms/arm-qemu/xinu.conf:/* "type" declarations for both real- and pseudo- devices */
compile/platforms/arm-qemu/xinu.conf:	on LOOPBACK -i loopbackInit -o loopbackOpen  -c loopbackClose
compile/platforms/arm-qemu/xinu.conf:	            -r loopbackRead -g loopbackGetc  -p loopbackPutc
compile/platforms/arm-qemu/xinu.conf:	            -w loopbackWrite -n loopbackControl
compile/platforms/arm-qemu/xinu.conf:    on NOTHING  -i ionull       -o ionull        -c ionull
compile/platforms/arm-qemu/xinu.conf:                -r ionull       -g ionull        -p ionull
compile/platforms/arm-qemu/xinu.conf:                -w ionull
compile/platforms/arm-qemu/xinu.conf:	on HARDWARE -i uartInit     -o ionull        -c ionull
compile/platforms/arm-qemu/xinu.conf:	            -r uartRead     -g uartGetc      -p uartPutc
compile/platforms/arm-qemu/xinu.conf:	            -w uartWrite    -n uartControl
compile/platforms/arm-qemu/xinu.conf:                -intr uartInterrupt
compile/platforms/arm-qemu/xinu.conf:/* tty pseudo-devices */
compile/platforms/arm-qemu/xinu.conf:	on SOFTWARE -i ttyInit      -o ttyOpen       -c ttyClose
compile/platforms/arm-qemu/xinu.conf:	            -r ttyRead      -g ttyGetc       -p ttyPutc
compile/platforms/arm-qemu/xinu.conf:	            -w ttyWrite     -n ttyControl
compile/platforms/arm-rpi/ld.script: * --gc-sections option, which removes all sections not reachable from the
compile/platforms/arm-rpi/ld.script: * To be safe, we ensure that every section is aligned on a 64-byte (cache line)
compile/platforms/arm-rpi/ld.script:     * ".note.gnu.build-id" section before _start!  */
compile/platforms/arm-rpi/platformVars:# Platform-specific Makefile definitions for the Raspberry Pi port of Embedded
compile/platforms/arm-rpi/platformVars:# Extra compiler and assembler flags to specifically target the ARM1176JZF-S CPU
compile/platforms/arm-rpi/platformVars:CFLAGS   += -mcpu=arm1176jzf-s
compile/platforms/arm-rpi/platformVars:ASFLAGS  += -mcpu=arm1176jzf-s
compile/platforms/arm-rpi/platformVars:DEFS     += -D_XINU_PLATFORM_ARM_RPI_
compile/platforms/arm-rpi/platformVars:            uart-pl011      \
compile/platforms/arm-rpi/xinu.conf:/* Configuration - (device configuration specifications)  */
compile/platforms/arm-rpi/xinu.conf:/*  -i    init          -o    open      -c    close       */
compile/platforms/arm-rpi/xinu.conf:/*  -r    read          -g    getc      -p    putc        */
compile/platforms/arm-rpi/xinu.conf:/*  -w    write         -s    seek      -n    control     */
compile/platforms/arm-rpi/xinu.conf:/*  -intr interrupt     -csr  csr       -irq  irq         */
compile/platforms/arm-rpi/xinu.conf:/* "type" declarations for both real- and pseudo- devices */
compile/platforms/arm-rpi/xinu.conf:	on LOOPBACK -i loopbackInit -o loopbackOpen  -c loopbackClose
compile/platforms/arm-rpi/xinu.conf:	            -r loopbackRead -g loopbackGetc  -p loopbackPutc
compile/platforms/arm-rpi/xinu.conf:	            -w loopbackWrite -n loopbackControl
compile/platforms/arm-rpi/xinu.conf:    on NOTHING  -i ionull       -o ionull        -c ionull
compile/platforms/arm-rpi/xinu.conf:                -r ionull       -g ionull        -p ionull
compile/platforms/arm-rpi/xinu.conf:                -w ionull
compile/platforms/arm-rpi/xinu.conf:	on HARDWARE -i uartInit     -o ionull        -c ionull
compile/platforms/arm-rpi/xinu.conf:	            -r uartRead     -g uartGetc      -p uartPutc
compile/platforms/arm-rpi/xinu.conf:	            -w uartWrite    -n uartControl
compile/platforms/arm-rpi/xinu.conf:                -intr uartInterrupt
compile/platforms/arm-rpi/xinu.conf:	on HARDWARE -i ionull     -o ionull        -c ionull
compile/platforms/arm-rpi/xinu.conf:	            -r ioerr      -g ioerr         -p fbPutc
compile/platforms/arm-rpi/xinu.conf:	            -w fbWrite
compile/platforms/arm-rpi/xinu.conf:/* tty pseudo-devices */
compile/platforms/arm-rpi/xinu.conf:	on SOFTWARE -i ttyInit      -o ttyOpen       -c ttyClose
compile/platforms/arm-rpi/xinu.conf:	            -r ttyRead      -g ttyGetc       -p ttyPutc
compile/platforms/arm-rpi/xinu.conf:	            -w ttyWrite     -n ttyControl
compile/platforms/arm-rpi/xinu.conf:	on HARDWARE -i etherInit    -o etherOpen     -c etherClose
compile/platforms/arm-rpi/xinu.conf:	            -r etherRead    -w etherWrite    -n etherControl
compile/platforms/arm-rpi/xinu.conf:	on ETHLOOP  -i ethloopInit  -o ethloopOpen   -c ethloopClose
compile/platforms/arm-rpi/xinu.conf:	            -r ethloopRead  -w ethloopWrite  -n ethloopControl
compile/platforms/arm-rpi/xinu.conf:	on SOFTWARE -i rawInit      -o rawOpen       -c rawClose
compile/platforms/arm-rpi/xinu.conf:                -r rawRead      -w rawWrite      -n rawControl
compile/platforms/arm-rpi/xinu.conf:    on NET      -i udpInit      -o udpOpen       -c udpClose
compile/platforms/arm-rpi/xinu.conf:                -r udpRead      -w udpWrite      -n udpControl
compile/platforms/arm-rpi/xinu.conf:    on SOFTWARE -i tcpInit      -o tcpOpen       -c tcpClose
compile/platforms/arm-rpi/xinu.conf:                -r tcpRead      -g tcpGetc       -w tcpWrite
compile/platforms/arm-rpi/xinu.conf:                -p tcpPutc      -n tcpControl
compile/platforms/arm-rpi/xinu.conf:    on TCP      -i telnetInit   -o telnetOpen   -c telnetClose
compile/platforms/arm-rpi/xinu.conf:                -r telnetRead   -g telnetGetc   -w telnetWrite
compile/platforms/arm-rpi/xinu.conf:                -p telnetPutc   -n telnetControl
compile/platforms/arm-rpi/xinu.conf:    on USB      -i usbKbdInit   -o ionull       -c ionull
compile/platforms/arm-rpi/xinu.conf:                -r usbKbdRead   -g usbKbdGetc   -w ioerr
compile/platforms/arm-rpi/xinu.conf:                -p ioerr        -n usbKbdControl
compile/platforms/arm-rpi/xinu.conf:    on OTHERDEVS -i ionull       -o ionull       -c ionull
compile/platforms/arm-rpi/xinu.conf:                 -r usbKbdRead   -g usbKbdGetc   -w fbWrite
compile/platforms/arm-rpi/xinu.conf:                 -p fbPutc       -n ioerr
compile/platforms/arm-rpi/xinu.conf: * (BCM2835-ARM-Peripherals.pdf).  IRQ number is on page 113; registers address
compile/platforms/e2100l/ld.script:		*(.rodata .rodata.*) /* asm and C read-only data              */
compile/platforms/e2100l/ld.script:	* ".note.gnu.build-id" section before _start!  */
compile/platforms/e2100l/platformVars:# Platform-specific Makefile definitions for the Cisco Linksys E2100L port of
compile/platforms/e2100l/platformVars:# specific sub-architecture
compile/platforms/e2100l/platformVars:           uart-ns16550 \
compile/platforms/e2100l/platformVars:MKIMAGE   := uboot-tool/mkimage
compile/platforms/e2100l/platformVars:UBOOTOPTS := -A mips -O linux -T kernel -a 0x80010000 \
compile/platforms/e2100l/platformVars:             -C none -e 0x80010000 -n 'Xinu'
compile/platforms/e2100l/platformVars:	$(MKIMAGE) $(UBOOTOPTS) -d xinu.bin $@
compile/platforms/e2100l/platformVars:	@echo "ERROR: The U-Boot utilities are not part of Xinu."
compile/platforms/e2100l/platformVars:	$(OBJCOPY) -O binary $^ $@
compile/platforms/e2100l/xinu.conf:/* Configuration - (device configuration specifications)  */
compile/platforms/e2100l/xinu.conf:/*  -i    init          -o    open      -c    close       */
compile/platforms/e2100l/xinu.conf:/*  -r    read          -g    getc      -p    putc        */
compile/platforms/e2100l/xinu.conf:/*  -w    write         -s    seek      -n    control     */
compile/platforms/e2100l/xinu.conf:/*  -intr interrupt     -csr  csr       -irq  irq         */
compile/platforms/e2100l/xinu.conf:/* "type" declarations for both real- and pseudo- devices */
compile/platforms/e2100l/xinu.conf:	on LOOPBACK -i loopbackInit -o loopbackOpen  -c loopbackClose
compile/platforms/e2100l/xinu.conf:	            -r loopbackRead -g loopbackGetc  -p loopbackPutc
compile/platforms/e2100l/xinu.conf:	            -w loopbackWrite -n loopbackControl
compile/platforms/e2100l/xinu.conf:    on NOTHING  -i ionull       -o ionull        -c ionull
compile/platforms/e2100l/xinu.conf:                -r ionull       -g ionull        -p ionull
compile/platforms/e2100l/xinu.conf:                -w ionull
compile/platforms/e2100l/xinu.conf:	on HARDWARE -i uartInit     -o ionull        -c ionull
compile/platforms/e2100l/xinu.conf:	            -r uartRead     -g uartGetc      -p uartPutc
compile/platforms/e2100l/xinu.conf:	            -w uartWrite    -n uartControl
compile/platforms/e2100l/xinu.conf:	            -intr uartInterrupt
compile/platforms/e2100l/xinu.conf:/* tty pseudo-devices */
compile/platforms/e2100l/xinu.conf:	on SOFTWARE -i ttyInit      -o ttyOpen       -c ttyClose
compile/platforms/e2100l/xinu.conf:	            -r ttyRead      -g ttyGetc       -p ttyPutc
compile/platforms/e2100l/xinu.conf:	            -w ttyWrite     -n ttyControl
compile/platforms/e2100l/xinu.conf:    on HARDWARE -i flashInit    -o flashOpen     -c flashClose
compile/platforms/e2100l/xinu.conf:                -r flashRead    -w flashWrite    -n flashControl
compile/platforms/e2100l/xinu.conf:	on HARDWARE -i etherInit    -o etherOpen     -c etherClose
compile/platforms/e2100l/xinu.conf:	            -r etherRead    -w etherWrite    -n etherControl
compile/platforms/e2100l/xinu.conf:	            -intr etherInterrupt
compile/platforms/e2100l/xinu.conf:	on ETHLOOP  -i ethloopInit  -o ethloopOpen   -c ethloopClose
compile/platforms/e2100l/xinu.conf:	            -r ethloopRead  -w ethloopWrite  -n ethloopControl
compile/platforms/e2100l/xinu.conf:	on SOFTWARE -i rawInit      -o rawOpen       -c rawClose
compile/platforms/e2100l/xinu.conf:                -r rawRead      -w rawWrite      -n rawControl
compile/platforms/e2100l/xinu.conf:    on NET      -i udpInit      -o udpOpen       -c udpClose
compile/platforms/e2100l/xinu.conf:                -r udpRead      -w udpWrite      -n udpControl
compile/platforms/e2100l/xinu.conf:    on SOFTWARE -i tcpInit      -o tcpOpen       -c tcpClose
compile/platforms/e2100l/xinu.conf:                -r tcpRead      -g tcpGetc       -w tcpWrite
compile/platforms/e2100l/xinu.conf:                -p tcpPutc      -n tcpControl
compile/platforms/e2100l/xinu.conf:/* http pseudo-devices */
compile/platforms/e2100l/xinu.conf:        on TCP      -i httpInit     -o httpOpen      -c httpClose
compile/platforms/e2100l/xinu.conf:                    -r httpRead     -g httpGetc      -p httpPutc
compile/platforms/e2100l/xinu.conf:                    -w httpWrite    -n httpControl
compile/platforms/e2100l/xinu.conf:    on TCP      -i telnetInit   -o telnetOpen   -c telnetClose
compile/platforms/e2100l/xinu.conf:                -r telnetRead   -g telnetGetc   -w telnetWrite
compile/platforms/e2100l/xinu.conf:                -p telnetPutc   -n telnetControl
compile/platforms/e2100l/xinu.conf:#define GPIO      FALSE         /* General-purpose I/O (leds)       */
compile/platforms/mipsel-qemu/platformVars:# Platform-specific Makefile definitions for the Mipsel QEMU port of Embedded
compile/platforms/mipsel-qemu/platformVars:           uart-ns16550
compile/platforms/mipsel-qemu/xinu.conf:/* Configuration - (device configuration specifications)  */
compile/platforms/mipsel-qemu/xinu.conf:/*  -i    init          -o    open      -c    close       */
compile/platforms/mipsel-qemu/xinu.conf:/*  -r    read          -g    getc      -p    putc        */
compile/platforms/mipsel-qemu/xinu.conf:/*  -w    write         -s    seek      -n    control     */
compile/platforms/mipsel-qemu/xinu.conf:/*  -intr interrupt     -csr  csr       -irq  irq         */
compile/platforms/mipsel-qemu/xinu.conf:/* "type" declarations for both real- and pseudo- devices */
compile/platforms/mipsel-qemu/xinu.conf:	on LOOPBACK -i loopbackInit -o loopbackOpen  -c loopbackClose
compile/platforms/mipsel-qemu/xinu.conf:	            -r loopbackRead -g loopbackGetc  -p loopbackPutc
compile/platforms/mipsel-qemu/xinu.conf:	            -w loopbackWrite -n loopbackControl
compile/platforms/mipsel-qemu/xinu.conf:    on NOTHING  -i ionull       -o ionull        -c ionull
compile/platforms/mipsel-qemu/xinu.conf:                -r ionull       -g ionull        -p ionull
compile/platforms/mipsel-qemu/xinu.conf:                -w ionull
compile/platforms/mipsel-qemu/xinu.conf:	on HARDWARE -i uartInit     -o ionull        -c ionull
compile/platforms/mipsel-qemu/xinu.conf:	            -r uartRead     -g uartGetc      -p uartPutc
compile/platforms/mipsel-qemu/xinu.conf:	            -w uartWrite    -n uartControl
compile/platforms/mipsel-qemu/xinu.conf:	            -intr uartInterrupt
compile/platforms/mipsel-qemu/xinu.conf:/* tty pseudo-devices */
compile/platforms/mipsel-qemu/xinu.conf:	on SOFTWARE -i ttyInit      -o ttyOpen       -c ttyClose
compile/platforms/mipsel-qemu/xinu.conf:	            -r ttyRead      -g ttyGetc       -p ttyPutc
compile/platforms/mipsel-qemu/xinu.conf:	            -w ttyWrite     -n ttyControl
compile/platforms/wl330ge/platformVars:# Platform-specific Makefile definitions for the ASUS WL-330gE port of Embedded
compile/platforms/wl330ge/platformVars:PLATFORM_NAME := ASUS WL-330gE
compile/platforms/wl330ge/platformVars:           uart-ns16550 \
compile/platforms/wl330ge/platformVars:DEFS += -DFLASH_ASUS
compile/platforms/wl330ge/xinu.conf:/* Configuration - (device configuration specifications)  */
compile/platforms/wl330ge/xinu.conf:/*  -i    init          -o    open      -c    close       */
compile/platforms/wl330ge/xinu.conf:/*  -r    read          -g    getc      -p    putc        */
compile/platforms/wl330ge/xinu.conf:/*  -w    write         -s    seek      -n    control     */
compile/platforms/wl330ge/xinu.conf:/*  -intr interrupt     -csr  csr       -irq  irq         */
compile/platforms/wl330ge/xinu.conf:/* "type" declarations for both real- and pseudo- devices */
compile/platforms/wl330ge/xinu.conf:	on LOOPBACK -i loopbackInit -o loopbackOpen  -c loopbackClose
compile/platforms/wl330ge/xinu.conf:	            -r loopbackRead -g loopbackGetc  -p loopbackPutc
compile/platforms/wl330ge/xinu.conf:	            -w loopbackWrite -n loopbackControl
compile/platforms/wl330ge/xinu.conf:    on NOTHING  -i ionull       -o ionull        -c ionull
compile/platforms/wl330ge/xinu.conf:                -r ionull       -g ionull        -p ionull
compile/platforms/wl330ge/xinu.conf:                -w ionull
compile/platforms/wl330ge/xinu.conf:	on HARDWARE -i uartInit     -o ionull        -c ionull
compile/platforms/wl330ge/xinu.conf:	            -r uartRead     -g uartGetc      -p uartPutc
compile/platforms/wl330ge/xinu.conf:	            -w uartWrite    -n uartControl
compile/platforms/wl330ge/xinu.conf:	            -intr uartInterrupt
compile/platforms/wl330ge/xinu.conf:/* tty pseudo-devices */
compile/platforms/wl330ge/xinu.conf:	on SOFTWARE -i ttyInit      -o ttyOpen       -c ttyClose
compile/platforms/wl330ge/xinu.conf:	            -r ttyRead      -g ttyGetc       -p ttyPutc
compile/platforms/wl330ge/xinu.conf:	            -w ttyWrite     -n ttyControl
compile/platforms/wl330ge/xinu.conf:    on HARDWARE -i flashInit    -o flashOpen     -c flashClose
compile/platforms/wl330ge/xinu.conf:                -r flashRead    -w flashWrite    -n flashControl
compile/platforms/wl330ge/xinu.conf:	on HARDWARE -i etherInit    -o etherOpen     -c etherClose
compile/platforms/wl330ge/xinu.conf:	            -r etherRead    -w etherWrite    -n etherControl
compile/platforms/wl330ge/xinu.conf:	            -intr etherInterrupt
compile/platforms/wl330ge/xinu.conf:	on SOFTWARE -i vlanInit     -o vlanOpen      -c vlanClose
compile/platforms/wl330ge/xinu.conf:	            -r etherRead    -w etherWrite    -n etherControl
compile/platforms/wl330ge/xinu.conf:	            -intr etherInterrupt
compile/platforms/wl330ge/xinu.conf:	on ETHLOOP  -i ethloopInit  -o ethloopOpen   -c ethloopClose
compile/platforms/wl330ge/xinu.conf:	            -r ethloopRead  -w ethloopWrite  -n ethloopControl
compile/platforms/wl330ge/xinu.conf:	on SOFTWARE -i rawInit      -o rawOpen       -c rawClose
compile/platforms/wl330ge/xinu.conf:                -r rawRead      -w rawWrite      -n rawControl
compile/platforms/wl330ge/xinu.conf:    on NET      -i udpInit      -o udpOpen       -c udpClose
compile/platforms/wl330ge/xinu.conf:                -r udpRead      -w udpWrite      -n udpControl
compile/platforms/wl330ge/xinu.conf:    on SOFTWARE -i tcpInit      -o tcpOpen       -c tcpClose
compile/platforms/wl330ge/xinu.conf:                -r tcpRead      -g tcpGetc       -w tcpWrite
compile/platforms/wl330ge/xinu.conf:                -p tcpPutc      -n tcpControl
compile/platforms/wl330ge/xinu.conf:/* http pseudo-devices */
compile/platforms/wl330ge/xinu.conf:        on TCP      -i httpInit     -o httpOpen      -c httpClose
compile/platforms/wl330ge/xinu.conf:                    -r httpRead     -g httpGetc      -p httpPutc
compile/platforms/wl330ge/xinu.conf:                    -w httpWrite    -n httpControl
compile/platforms/wl330ge/xinu.conf:    on TCP      -i telnetInit   -o telnetOpen   -c telnetClose
compile/platforms/wl330ge/xinu.conf:                -r telnetRead   -g telnetGetc   -w telnetWrite
compile/platforms/wl330ge/xinu.conf:                -p telnetPutc   -n telnetControl
compile/platforms/wl330ge/xinu.conf:#define GPIO      TRUE          /* General-purpose I/O (leds)       */
compile/platforms/wl330ge/xinu.conf:#define GPIO_BASE 0xB8000060    /* General-purpose I/O lines        */
compile/platforms/wrt160nl/platformVars:# Platform-specific Makefile definitions for the WRT160NL port of Embedded Xinu.
compile/platforms/wrt160nl/platformVars:# specific sub-architecture
compile/platforms/wrt160nl/platformVars:           uart-ns16550 \
compile/platforms/wrt160nl/platformVars:MKIMAGE   := uboot-tool/mkimage
compile/platforms/wrt160nl/platformVars:UBOOTOPTS := -A mips -O linux -T kernel -a 0x80010000 \
compile/platforms/wrt160nl/platformVars:             -C none -e 0x80010000 -n 'Xinu'
compile/platforms/wrt160nl/platformVars:	$(MKIMAGE) $(UBOOTOPTS) -d xinu.bin $@
compile/platforms/wrt160nl/platformVars:	@echo "ERROR: The U-Boot utilities are not part of Xinu."
compile/platforms/wrt160nl/platformVars:	$(OBJCOPY) -O binary $^ $@
compile/platforms/wrt160nl/xinu.conf:/* Configuration - (device configuration specifications)  */
compile/platforms/wrt160nl/xinu.conf:/*  -i    init          -o    open      -c    close       */
compile/platforms/wrt160nl/xinu.conf:/*  -r    read          -g    getc      -p    putc        */
compile/platforms/wrt160nl/xinu.conf:/*  -w    write         -s    seek      -n    control     */
compile/platforms/wrt160nl/xinu.conf:/*  -intr interrupt     -csr  csr       -irq  irq         */
compile/platforms/wrt160nl/xinu.conf:/* "type" declarations for both real- and pseudo- devices */
compile/platforms/wrt160nl/xinu.conf:	on LOOPBACK -i loopbackInit -o loopbackOpen  -c loopbackClose
compile/platforms/wrt160nl/xinu.conf:	            -r loopbackRead -g loopbackGetc  -p loopbackPutc
compile/platforms/wrt160nl/xinu.conf:	            -w loopbackWrite -n loopbackControl
compile/platforms/wrt160nl/xinu.conf:    on NOTHING  -i ionull       -o ionull        -c ionull
compile/platforms/wrt160nl/xinu.conf:                -r ionull       -g ionull        -p ionull
compile/platforms/wrt160nl/xinu.conf:                -w ionull
compile/platforms/wrt160nl/xinu.conf:	on HARDWARE -i uartInit     -o ionull        -c ionull
compile/platforms/wrt160nl/xinu.conf:	            -r uartRead     -g uartGetc      -p uartPutc
compile/platforms/wrt160nl/xinu.conf:	            -w uartWrite    -n uartControl
compile/platforms/wrt160nl/xinu.conf:	            -intr uartInterrupt
compile/platforms/wrt160nl/xinu.conf:/* tty pseudo-devices */
compile/platforms/wrt160nl/xinu.conf:	on SOFTWARE -i ttyInit      -o ttyOpen       -c ttyClose
compile/platforms/wrt160nl/xinu.conf:	            -r ttyRead      -g ttyGetc       -p ttyPutc
compile/platforms/wrt160nl/xinu.conf:	            -w ttyWrite     -n ttyControl
compile/platforms/wrt160nl/xinu.conf:	on HARDWARE -i etherInit    -o etherOpen     -c etherClose
compile/platforms/wrt160nl/xinu.conf:	            -r etherRead    -w etherWrite    -n etherControl
compile/platforms/wrt160nl/xinu.conf:	            -intr etherInterrupt
compile/platforms/wrt160nl/xinu.conf:	on ETHLOOP  -i ethloopInit  -o ethloopOpen   -c ethloopClose
compile/platforms/wrt160nl/xinu.conf:	            -r ethloopRead  -w ethloopWrite  -n ethloopControl
compile/platforms/wrt160nl/xinu.conf:	on SOFTWARE -i rawInit      -o rawOpen       -c rawClose
compile/platforms/wrt160nl/xinu.conf:                -r rawRead      -w rawWrite      -n rawControl
compile/platforms/wrt160nl/xinu.conf:    on NET      -i udpInit      -o udpOpen       -c udpClose
compile/platforms/wrt160nl/xinu.conf:                -r udpRead      -w udpWrite      -n udpControl
compile/platforms/wrt160nl/xinu.conf:    on SOFTWARE -i tcpInit      -o tcpOpen       -c tcpClose
compile/platforms/wrt160nl/xinu.conf:                -r tcpRead      -g tcpGetc       -w tcpWrite
compile/platforms/wrt160nl/xinu.conf:                -p tcpPutc      -n tcpControl
compile/platforms/wrt160nl/xinu.conf:/* http pseudo-devices */
compile/platforms/wrt160nl/xinu.conf:        on TCP      -i httpInit     -o httpOpen      -c httpClose
compile/platforms/wrt160nl/xinu.conf:                    -r httpRead     -g httpGetc      -p httpPutc
compile/platforms/wrt160nl/xinu.conf:                    -w httpWrite    -n httpControl
compile/platforms/wrt160nl/xinu.conf:    on TCP      -i telnetInit   -o telnetOpen   -c telnetClose
compile/platforms/wrt160nl/xinu.conf:                -r telnetRead   -g telnetGetc   -w telnetWrite
compile/platforms/wrt160nl/xinu.conf:                -p telnetPutc   -n telnetControl
compile/platforms/wrt160nl/xinu.conf:#define GPIO      FALSE         /* General-purpose I/O (leds)       */
compile/platforms/wrt160nl/xinu.conf:#define UART_CSR_SPACED TRUE    /* NS16550 UART registers are word-sized  */
compile/platforms/wrt54gl/platformVars:# Platform-specific Makefile definitions for the Linksys WRT54GL port of
compile/platforms/wrt54gl/platformVars:           uart-ns16550 \
compile/platforms/wrt54gl/xinu.conf:/* Configuration - (device configuration specifications)  */
compile/platforms/wrt54gl/xinu.conf:/*  -i    init          -o    open      -c    close       */
compile/platforms/wrt54gl/xinu.conf:/*  -r    read          -g    getc      -p    putc        */
compile/platforms/wrt54gl/xinu.conf:/*  -w    write         -s    seek      -n    control     */
compile/platforms/wrt54gl/xinu.conf:/*  -intr interrupt     -csr  csr       -irq  irq         */
compile/platforms/wrt54gl/xinu.conf:/* "type" declarations for both real- and pseudo- devices */
compile/platforms/wrt54gl/xinu.conf:	on LOOPBACK -i loopbackInit -o loopbackOpen  -c loopbackClose
compile/platforms/wrt54gl/xinu.conf:	            -r loopbackRead -g loopbackGetc  -p loopbackPutc
compile/platforms/wrt54gl/xinu.conf:	            -w loopbackWrite -n loopbackControl
compile/platforms/wrt54gl/xinu.conf:    on NOTHING  -i ionull       -o ionull        -c ionull
compile/platforms/wrt54gl/xinu.conf:                -r ionull       -g ionull        -p ionull
compile/platforms/wrt54gl/xinu.conf:                -w ionull
compile/platforms/wrt54gl/xinu.conf:	on HARDWARE -i uartInit     -o ionull        -c ionull
compile/platforms/wrt54gl/xinu.conf:	            -r uartRead     -g uartGetc      -p uartPutc
compile/platforms/wrt54gl/xinu.conf:	            -w uartWrite    -n uartControl
compile/platforms/wrt54gl/xinu.conf:	            -intr uartInterrupt
compile/platforms/wrt54gl/xinu.conf:/* tty pseudo-devices */
compile/platforms/wrt54gl/xinu.conf:	on SOFTWARE -i ttyInit      -o ttyOpen       -c ttyClose
compile/platforms/wrt54gl/xinu.conf:	            -r ttyRead      -g ttyGetc       -p ttyPutc
compile/platforms/wrt54gl/xinu.conf:	            -w ttyWrite     -n ttyControl
compile/platforms/wrt54gl/xinu.conf:    on HARDWARE -i flashInit    -o flashOpen     -c flashClose
compile/platforms/wrt54gl/xinu.conf:                -r flashRead    -w flashWrite    -n flashControl
compile/platforms/wrt54gl/xinu.conf:	on HARDWARE -i etherInit    -o etherOpen     -c etherClose
compile/platforms/wrt54gl/xinu.conf:	            -r etherRead    -w etherWrite    -n etherControl
compile/platforms/wrt54gl/xinu.conf:	            -intr etherInterrupt
compile/platforms/wrt54gl/xinu.conf:	on SOFTWARE -i vlanInit     -o vlanOpen      -c vlanClose
compile/platforms/wrt54gl/xinu.conf:	            -r etherRead    -w etherWrite    -n etherControl
compile/platforms/wrt54gl/xinu.conf:	            -intr etherInterrupt
compile/platforms/wrt54gl/xinu.conf:	on ETHLOOP  -i ethloopInit  -o ethloopOpen   -c ethloopClose
compile/platforms/wrt54gl/xinu.conf:	            -r ethloopRead  -w ethloopWrite  -n ethloopControl
compile/platforms/wrt54gl/xinu.conf:	on SOFTWARE -i rawInit      -o rawOpen       -c rawClose
compile/platforms/wrt54gl/xinu.conf:                -r rawRead      -w rawWrite      -n rawControl
compile/platforms/wrt54gl/xinu.conf:    on NET      -i udpInit      -o udpOpen       -c udpClose
compile/platforms/wrt54gl/xinu.conf:                -r udpRead      -w udpWrite      -n udpControl
compile/platforms/wrt54gl/xinu.conf:    on SOFTWARE -i tcpInit      -o tcpOpen       -c tcpClose
compile/platforms/wrt54gl/xinu.conf:                -r tcpRead      -g tcpGetc       -w tcpWrite
compile/platforms/wrt54gl/xinu.conf:                -p tcpPutc      -n tcpControl
compile/platforms/wrt54gl/xinu.conf:/* http pseudo-devices */
compile/platforms/wrt54gl/xinu.conf:        on TCP      -i httpInit     -o httpOpen      -c httpClose
compile/platforms/wrt54gl/xinu.conf:                    -r httpRead     -g httpGetc      -p httpPutc
compile/platforms/wrt54gl/xinu.conf:                    -w httpWrite    -n httpControl
compile/platforms/wrt54gl/xinu.conf:    on TCP      -i telnetInit   -o telnetOpen   -c telnetClose
compile/platforms/wrt54gl/xinu.conf:                -r telnetRead   -g telnetGetc   -w telnetWrite
compile/platforms/wrt54gl/xinu.conf:                -p telnetPutc   -n telnetControl
compile/platforms/wrt54gl/xinu.conf:#define GPIO      TRUE          /* General-purpose I/O (leds)       */
compile/platforms/wrt54gl/xinu.conf:#define GPIO_BASE 0xB8000060    /* General-purpose I/O lines        */
compile/platforms/x86/ld.script:		*(.rodata .rodata.*) /* S and C read-only data                */
compile/platforms/x86/ld.script:	* ".note.gnu.build-id" section before _start!  */
compile/platforms/x86/platformVars:# Platform-specific Makefile definitions for the x86 port of Embedded Xinu.
compile/platforms/x86/platformVars:CFLAGS        += -m32
compile/platforms/x86/platformVars:ASFLAGS       += --32
compile/platforms/x86/platformVars:DEFS          += -D_XINU_PLATFORM_X86_
compile/platforms/x86/platformVars:DEVICES       := loopback tty uart-x86
compile/platforms/x86/xinu.conf:/* Configuration - (device configuration specifications)  */
compile/platforms/x86/xinu.conf:/*  -i    init          -o    open      -c    close       */
compile/platforms/x86/xinu.conf:/*  -r    read          -g    getc      -p    putc        */
compile/platforms/x86/xinu.conf:/*  -w    write         -s    seek      -n    control     */
compile/platforms/x86/xinu.conf:/*  -intr interrupt     -csr  csr       -irq  irq         */
compile/platforms/x86/xinu.conf:/* "type" declarations for both real- and pseudo- devices */
compile/platforms/x86/xinu.conf:	on LOOPBACK -i loopbackInit -o loopbackOpen  -c loopbackClose
compile/platforms/x86/xinu.conf:	            -r loopbackRead -g loopbackGetc  -p loopbackPutc
compile/platforms/x86/xinu.conf:	            -w loopbackWrite -n loopbackControl
compile/platforms/x86/xinu.conf:    on NOTHING  -i ionull       -o ionull        -c ionull
compile/platforms/x86/xinu.conf:                -r ionull       -g ionull        -p ionull
compile/platforms/x86/xinu.conf:                -w ionull
compile/platforms/x86/xinu.conf:	on HARDWARE -i uartInit     -o ionull        -c ionull
compile/platforms/x86/xinu.conf:	            -r uartRead     -g uartGetc      -p uartPutc
compile/platforms/x86/xinu.conf:	            -w uartWrite    -n uartControl
compile/platforms/x86/xinu.conf:	            -intr uartInterrupt
compile/platforms/x86/xinu.conf:/* tty pseudo-devices */
compile/platforms/x86/xinu.conf:	on SOFTWARE -i ttyInit      -o ttyOpen       -c ttyClose
compile/platforms/x86/xinu.conf:	            -r ttyRead      -g ttyGetc       -p ttyPutc
compile/platforms/x86/xinu.conf:	            -w ttyWrite     -n ttyControl
compile/platforms/x86/xinu.conf:    on HARDWARE -i flashInit    -o flashOpen     -c flashClose
compile/platforms/x86/xinu.conf:                -r flashRead    -w flashWrite    -n flashControl
compile/platforms/x86/xinu.conf:	on HARDWARE -i etherInit    -o etherOpen     -c etherClose
compile/platforms/x86/xinu.conf:	            -r etherRead    -w etherWrite    -n etherControl
compile/platforms/x86/xinu.conf:	            -intr etherInterrupt
compile/platforms/x86/xinu.conf:	on SOFTWARE -i vlanInit     -o vlanOpen      -c vlanClose
compile/platforms/x86/xinu.conf:	            -r etherRead    -w etherWrite    -n etherControl
compile/platforms/x86/xinu.conf:	            -intr etherInterrupt
compile/platforms/x86/xinu.conf:	on ETHLOOP  -i ethloopInit  -o ethloopOpen   -c ethloopClose
compile/platforms/x86/xinu.conf:	            -r ethloopRead  -w ethloopWrite  -n ethloopControl
compile/platforms/x86/xinu.conf:	on SOFTWARE -i rawInit      -o rawOpen       -c rawClose
compile/platforms/x86/xinu.conf:                -r rawRead      -w rawWrite      -n rawControl
compile/platforms/x86/xinu.conf:    on NET      -i udpInit      -o udpOpen       -c udpClose
compile/platforms/x86/xinu.conf:                -r udpRead      -w udpWrite      -n udpControl
compile/platforms/x86/xinu.conf:    on SOFTWARE -i tcpInit      -o tcpOpen       -c tcpClose
compile/platforms/x86/xinu.conf:                -r tcpRead      -g tcpGetc       -w tcpWrite
compile/platforms/x86/xinu.conf:                -p tcpPutc      -n tcpControl
compile/platforms/x86/xinu.conf:/* http pseudo-devices */
compile/platforms/x86/xinu.conf:        on TCP      -i httpInit     -o httpOpen      -c httpClose
compile/platforms/x86/xinu.conf:                    -r httpRead     -g httpGetc      -p httpPutc
compile/platforms/x86/xinu.conf:                    -w httpWrite    -n httpControl
compile/platforms/x86/xinu.conf:    on TCP      -i telnetInit   -o telnetOpen   -c telnetClose
compile/platforms/x86/xinu.conf:                -r telnetRead   -g telnetGetc   -w telnetWrite
compile/platforms/x86/xinu.conf:                -p telnetPutc   -n telnetControl
compile/platforms/x86/xinu.conf:#define GPIO      TRUE          /* General-purpose I/O (leds)       */
compile/platforms/x86/xinu.conf:#define GPIO_BASE 0xB8000060    /* General-purpose I/O lines        */
compile/platforms/arm-rpi3/ld.script: * loads the kernel at address 0x8000 by default (in 32-bit mode, although the Pi 3
compile/platforms/arm-rpi3/ld.script: * does support 64-bit mode at 0x80000), and the ARM processor starts
compile/platforms/arm-rpi3/ld.script: * --gc-sections option, which removes all sections not reachable from the
compile/platforms/arm-rpi3/ld.script: * To be safe, we ensure that every section is aligned on a 64-byte (cache line)
compile/platforms/arm-rpi3/ld.script:     * ".note.gnu.build-id" section before _start!  */
compile/platforms/arm-rpi3/platformVars:# Platform-specific Makefile definitions for the Raspberry Pi port of Embedded
compile/platforms/arm-rpi3/platformVars:# Extra compiler and assembler flags to specifically target the cortex-a53 CPU
compile/platforms/arm-rpi3/platformVars:CFLAGS   += -mcpu=cortex-a53
compile/platforms/arm-rpi3/platformVars:ASFLAGS  += -mcpu=cortex-a53
compile/platforms/arm-rpi3/platformVars:CFLAGS	 += -mno-unaligned-access
compile/platforms/arm-rpi3/platformVars:DEFS     += -D_XINU_PLATFORM_ARM_RPI_3_
compile/platforms/arm-rpi3/platformVars:DEVICES  := uart-pl011      \
compile/platforms/arm-rpi3/xinu.conf:/* Configuration - (device configuration specifications)  */
compile/platforms/arm-rpi3/xinu.conf:/*  -i    init          -o    open      -c    close       */
compile/platforms/arm-rpi3/xinu.conf:/*  -r    read          -g    getc      -p    putc        */
compile/platforms/arm-rpi3/xinu.conf:/*  -w    write         -s    seek      -n    control     */
compile/platforms/arm-rpi3/xinu.conf:/*  -intr interrupt     -csr  csr       -irq  irq         */
compile/platforms/arm-rpi3/xinu.conf:/* "type" declarations for both real- and pseudo- devices */
compile/platforms/arm-rpi3/xinu.conf:	on LOOPBACK -i loopbackInit -o loopbackOpen  -c loopbackClose
compile/platforms/arm-rpi3/xinu.conf:	            -r loopbackRead -g loopbackGetc  -p loopbackPutc
compile/platforms/arm-rpi3/xinu.conf:	            -w loopbackWrite -n loopbackControl
compile/platforms/arm-rpi3/xinu.conf:    on NOTHING  -i ionull       -o ionull        -c ionull
compile/platforms/arm-rpi3/xinu.conf:                -r ionull       -g ionull        -p ionull
compile/platforms/arm-rpi3/xinu.conf:                -w ionull
compile/platforms/arm-rpi3/xinu.conf:	on HARDWARE -i uartInit     -o ionull        -c ionull
compile/platforms/arm-rpi3/xinu.conf:	            -r uartRead     -g uartGetc      -p uartPutc
compile/platforms/arm-rpi3/xinu.conf:	            -w uartWrite    -n uartControl
compile/platforms/arm-rpi3/xinu.conf:                -intr uartInterrupt
compile/platforms/arm-rpi3/xinu.conf:	on HARDWARE -i ionull     -o ionull        -c ionull
compile/platforms/arm-rpi3/xinu.conf:	            -r ioerr      -g ioerr         -p fbPutc
compile/platforms/arm-rpi3/xinu.conf:	            -w fbWrite
compile/platforms/arm-rpi3/xinu.conf:/* tty pseudo-devices */
compile/platforms/arm-rpi3/xinu.conf:	on SOFTWARE -i ttyInit      -o ttyOpen       -c ttyClose
compile/platforms/arm-rpi3/xinu.conf:	            -r ttyRead      -g ttyGetc       -p ttyPutc
compile/platforms/arm-rpi3/xinu.conf:	            -w ttyWrite     -n ttyControl
compile/platforms/arm-rpi3/xinu.conf:	on HARDWARE -i etherInit    -o etherOpen     -c etherClose
compile/platforms/arm-rpi3/xinu.conf:	            -r etherRead    -w etherWrite    -n etherControl
compile/platforms/arm-rpi3/xinu.conf:	on ETHLOOP  -i ethloopInit  -o ethloopOpen   -c ethloopClose
compile/platforms/arm-rpi3/xinu.conf:	            -r ethloopRead  -w ethloopWrite  -n ethloopControl
compile/platforms/arm-rpi3/xinu.conf:	on SOFTWARE -i rawInit      -o rawOpen       -c rawClose
compile/platforms/arm-rpi3/xinu.conf:                -r rawRead      -w rawWrite      -n rawControl
compile/platforms/arm-rpi3/xinu.conf:    on NET      -i udpInit      -o udpOpen       -c udpClose
compile/platforms/arm-rpi3/xinu.conf:                -r udpRead      -w udpWrite      -n udpControl
compile/platforms/arm-rpi3/xinu.conf:    on SOFTWARE -i tcpInit      -o tcpOpen       -c tcpClose
compile/platforms/arm-rpi3/xinu.conf:                -r tcpRead      -g tcpGetc       -w tcpWrite
compile/platforms/arm-rpi3/xinu.conf:                -p tcpPutc      -n tcpControl
compile/platforms/arm-rpi3/xinu.conf:    on TCP      -i telnetInit   -o telnetOpen   -c telnetClose
compile/platforms/arm-rpi3/xinu.conf:                -r telnetRead   -g telnetGetc   -w telnetWrite
compile/platforms/arm-rpi3/xinu.conf:                -p telnetPutc   -n telnetControl
compile/platforms/arm-rpi3/xinu.conf:    on USB      -i usbKbdInit   -o ionull       -c ionull
compile/platforms/arm-rpi3/xinu.conf:                -r usbKbdRead   -g usbKbdGetc   -w ioerr
compile/platforms/arm-rpi3/xinu.conf:                -p ioerr        -n usbKbdControl
compile/platforms/arm-rpi3/xinu.conf:    on OTHERDEVS -i ionull       -o ionull       -c ionull
compile/platforms/arm-rpi3/xinu.conf:                 -r usbKbdRead   -g usbKbdGetc   -w fbWrite
compile/platforms/arm-rpi3/xinu.conf:                 -p fbPutc       -n ioerr
compile/platforms/arm-rpi3/xinu.conf: * (BCM2835-ARM-Peripherals.pdf).  IRQ number is on page 113; registers address
compile/scripts/make-arm-cross-compiler:set -e
compile/scripts/make-arm-cross-compiler:TARGET=arm-none-eabi
compile/scripts/make-arm-cross-compiler:MAKEARGS="-j4"
compile/scripts/make-arm-cross-compiler:tar xf binutils-${BINUTILS_VERSION}.tar.bz2
compile/scripts/make-arm-cross-compiler:builddir=binutils-${BINUTILS_VERSION}-build.${TARGET}
compile/scripts/make-arm-cross-compiler:../binutils-${BINUTILS_VERSION}/configure --prefix=${PREFIX} \
compile/scripts/make-arm-cross-compiler:					  --target=${TARGET} \
compile/scripts/make-arm-cross-compiler:					  --disable-nls
compile/scripts/make-arm-cross-compiler:rm -rf ${builddir}
compile/scripts/make-arm-cross-compiler:tar xf gcc-${GCC_VERSION}.tar.bz2
compile/scripts/make-arm-cross-compiler:builddir=gcc-${GCC_VERSION}-build.${TARGET}
compile/scripts/make-arm-cross-compiler:../gcc-${GCC_VERSION}/configure --prefix=${PREFIX} --target=${TARGET}	\
compile/scripts/make-arm-cross-compiler:				--disable-nls --enable-languages=c,c++	\
compile/scripts/make-arm-cross-compiler:				--without-headers
compile/scripts/make-arm-cross-compiler:make ${MAKEARGS} all-gcc all-target-libgcc
compile/scripts/make-arm-cross-compiler:${INSTALLPRIV} make install-gcc install-target-libgcc
compile/scripts/make-arm-cross-compiler:rm -rf ${builddir}
compile/version:(Embedded Xinu) (arm-rpi3) #71 (pmcgee@traken.mscs.mu.edu) Wed Jul 25 11:32:57 CDT 2018
compile/test.map:../lib/libxc.a(doprnt.o)      ../device/uart-pl011/../uart/kvprintf.o (_doprnt)
compile/test.map:../lib/libxc.a(memcpy.o)      ../system/platforms/arm-rpi3/kexec.o (memcpy)
compile/test.map:../lib/libxc.a(printf.o)      ../device/uart-pl011/uartHwStat.o (printf)
compile/test.map:../lib/libxc.a(rand.o)        ../system/platforms/arm-rpi3/des.o (srand)
compile/test.map:../lib/libxc.a(strlcpy.o)     ../system/platforms/arm-rpi3/platforminit.o (strlcpy)
compile/test.map: .data          0x0000000000000000        0x0 ../loader/platforms/arm-rpi3/start.o
compile/test.map: .bss           0x0000000000000000        0x0 ../loader/platforms/arm-rpi3/start.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/ctxsw.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/ctxsw.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/halt.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/halt.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/intutils.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/intutils.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/irq_handler.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/irq_handler.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/memory_barrier.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/memory_barrier.o
compile/test.map: .text          0x0000000000000000        0x8 ../system/platforms/arm-rpi3/pause.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/pause.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/pause.o
compile/test.map:                0x0000000000000000       0x28 ../system/platforms/arm-rpi3/pause.o
compile/test.map: .text          0x0000000000000000        0x8 ../system/platforms/arm-rpi3/getmode.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/getmode.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/getmode.o
compile/test.map:                0x0000000000000000       0x28 ../system/platforms/arm-rpi3/getmode.o
compile/test.map: .text          0x0000000000000000        0xc ../system/platforms/arm-rpi3/getcpuid.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/getcpuid.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/getcpuid.o
compile/test.map:                0x0000000000000000       0x28 ../system/platforms/arm-rpi3/getcpuid.o
compile/test.map: .text          0x0000000000000000       0x64 ../system/platforms/arm-rpi3/setupCores.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/setupCores.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/setupCores.o
compile/test.map:                0x0000000000000000       0x28 ../system/platforms/arm-rpi3/setupCores.o
compile/test.map: .text          0x0000000000000000        0x8 ../system/platforms/arm-rpi3/setmode.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/setmode.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/setmode.o
compile/test.map:                0x0000000000000000       0x28 ../system/platforms/arm-rpi3/setmode.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/mutex.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/mutex.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/mmu_util.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/mmu_util.o
compile/test.map: .text          0x0000000000000000        0x8 ../system/platforms/arm-rpi3/preload_data.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/preload_data.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/preload_data.o
compile/test.map:                0x0000000000000000       0x28 ../system/platforms/arm-rpi3/preload_data.o
compile/test.map: .text          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/setupStack.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/setupStack.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/setupStack.o
compile/test.map: .comment       0x0000000000000000       0x22 ../system/platforms/arm-rpi3/setupStack.o
compile/test.map: .text          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/bcm2837_power.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/bcm2837_power.o
compile/test.map: .comment       0x0000000000000000       0x22 ../system/platforms/arm-rpi3/bcm2837_power.o
compile/test.map: .text          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/dispatch.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/dispatch.o
compile/test.map: .comment       0x0000000000000000       0x22 ../system/platforms/arm-rpi3/dispatch.o
compile/test.map: .text          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/kexec.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/kexec.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/kexec.o
compile/test.map: .text.kexec    0x0000000000000000       0x58 ../system/platforms/arm-rpi3/kexec.o
compile/test.map: .rodata        0x0000000000000000       0x18 ../system/platforms/arm-rpi3/kexec.o
compile/test.map: .comment       0x0000000000000000       0x22 ../system/platforms/arm-rpi3/kexec.o
compile/test.map:                0x0000000000000000       0x38 ../system/platforms/arm-rpi3/kexec.o
compile/test.map: .text          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/platforminit.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/platforminit.o
compile/test.map:                0x0000000000000000       0x24 ../system/platforms/arm-rpi3/platforminit.o
compile/test.map: .text.led_on   0x0000000000000000       0x14 ../system/platforms/arm-rpi3/platforminit.o
compile/test.map: .text.led_off  0x0000000000000000       0x14 ../system/platforms/arm-rpi3/platforminit.o
compile/test.map: .comment       0x0000000000000000       0x22 ../system/platforms/arm-rpi3/platforminit.o
compile/test.map: .text          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/timer.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/timer.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/timer.o
compile/test.map: .comment       0x0000000000000000       0x22 ../system/platforms/arm-rpi3/timer.o
compile/test.map: .text          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map: .comment       0x0000000000000000       0x22 ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map: .text          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/watchdog.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/watchdog.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/watchdog.o
compile/test.map:                0x0000000000000000       0x34 ../system/platforms/arm-rpi3/watchdog.o
compile/test.map: .comment       0x0000000000000000       0x22 ../system/platforms/arm-rpi3/watchdog.o
compile/test.map:                0x0000000000000000       0x38 ../system/platforms/arm-rpi3/watchdog.o
compile/test.map: .text          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/unparkcore.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/unparkcore.o
compile/test.map:                0x0000000000000000       0x44 ../system/platforms/arm-rpi3/unparkcore.o
compile/test.map:                0x0000000000000000       0x2c ../system/platforms/arm-rpi3/unparkcore.o
compile/test.map:                0x0000000000000000       0x40 ../system/platforms/arm-rpi3/unparkcore.o
compile/test.map:                0x0000000000000000       0x2d ../system/platforms/arm-rpi3/unparkcore.o
compile/test.map: .comment       0x0000000000000000       0x22 ../system/platforms/arm-rpi3/unparkcore.o
compile/test.map: .text          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/mmu.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/mmu.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/mmu.o
compile/test.map: .comment       0x0000000000000000       0x22 ../system/platforms/arm-rpi3/mmu.o
compile/test.map: .text          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/random.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/random.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/random.o
compile/test.map: .comment       0x0000000000000000       0x22 ../system/platforms/arm-rpi3/random.o
compile/test.map: .text          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/bcm2837_mbox.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/bcm2837_mbox.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/bcm2837_mbox.o
compile/test.map: .comment       0x0000000000000000       0x22 ../system/platforms/arm-rpi3/bcm2837_mbox.o
compile/test.map: .text          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/des.o
compile/test.map: .data          0x0000000000000000        0x0 ../system/platforms/arm-rpi3/des.o
compile/test.map: .bss           0x0000000000000000        0x0 ../system/platforms/arm-rpi3/des.o
compile/test.map:                0x0000000000000000       0x34 ../system/platforms/arm-rpi3/des.o
compile/test.map: .text.addbit   0x0000000000000000       0x38 ../system/platforms/arm-rpi3/des.o
compile/test.map:                0x0000000000000000       0xc8 ../system/platforms/arm-rpi3/des.o
compile/test.map:                0x0000000000000000       0x94 ../system/platforms/arm-rpi3/des.o
compile/test.map:                0x0000000000000000      0x2d0 ../system/platforms/arm-rpi3/des.o
compile/test.map: .text.rounds   0x0000000000000000      0x244 ../system/platforms/arm-rpi3/des.o
compile/test.map: .text.genkey   0x0000000000000000      0x164 ../system/platforms/arm-rpi3/des.o
compile/test.map:                0x0000000000000000       0xf4 ../system/platforms/arm-rpi3/des.o
compile/test.map:                0x0000000000000000      0x10c ../system/platforms/arm-rpi3/des.o
compile/test.map: .rodata        0x0000000000000000      0xd20 ../system/platforms/arm-rpi3/des.o
compile/test.map:                0x0000000000000000       0x55 ../system/platforms/arm-rpi3/des.o
compile/test.map: .comment       0x0000000000000000       0x22 ../system/platforms/arm-rpi3/des.o
compile/test.map:                0x0000000000000000       0x38 ../system/platforms/arm-rpi3/des.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/kgetc.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/kgetc.o
compile/test.map: .bss           0x0000000000000000        0x0 ../device/uart-pl011/kgetc.o
compile/test.map: .text.kgetc    0x0000000000000000       0x50 ../device/uart-pl011/kgetc.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/kgetc.o
compile/test.map:                0x0000000000000000       0x38 ../device/uart-pl011/kgetc.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/kputc.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/kputc.o
compile/test.map: .bss           0x0000000000000000        0x0 ../device/uart-pl011/kputc.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/kputc.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartControl.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartControl.o
compile/test.map: .bss           0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartControl.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/../uart/uartControl.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartGetc.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartGetc.o
compile/test.map: .bss           0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartGetc.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/../uart/uartGetc.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/uartHwInit.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/uartHwInit.o
compile/test.map: .bss           0x0000000000000000        0x0 ../device/uart-pl011/uartHwInit.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/uartHwInit.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/uartHwPutc.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/uartHwPutc.o
compile/test.map: .bss           0x0000000000000000        0x0 ../device/uart-pl011/uartHwPutc.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/uartHwPutc.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/uartHwStat.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/uartHwStat.o
compile/test.map: .bss           0x0000000000000000        0x0 ../device/uart-pl011/uartHwStat.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/uartHwStat.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartInit.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartInit.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/../uart/uartInit.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/uartInterrupt.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/uartInterrupt.o
compile/test.map: .bss           0x0000000000000000        0x0 ../device/uart-pl011/uartInterrupt.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/uartInterrupt.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartPutc.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartPutc.o
compile/test.map: .bss           0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartPutc.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/../uart/uartPutc.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartRead.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartRead.o
compile/test.map: .bss           0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartRead.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/../uart/uartRead.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartWrite.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartWrite.o
compile/test.map: .bss           0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartWrite.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/../uart/uartWrite.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartStat.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartStat.o
compile/test.map: .bss           0x0000000000000000        0x0 ../device/uart-pl011/../uart/uartStat.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/../uart/uartStat.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/../uart/kprintf.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/../uart/kprintf.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/../uart/kprintf.o
compile/test.map: .text          0x0000000000000000        0x0 ../device/uart-pl011/../uart/kvprintf.o
compile/test.map: .data          0x0000000000000000        0x0 ../device/uart-pl011/../uart/kvprintf.o
compile/test.map: .bss           0x0000000000000000        0x0 ../device/uart-pl011/../uart/kvprintf.o
compile/test.map: .comment       0x0000000000000000       0x22 ../device/uart-pl011/../uart/kvprintf.o
compile/test.map: .init          0x0000000000008000       0x84 ../loader/platforms/arm-rpi3/start.o
compile/test.map:                0x00000000000080c0       0xa8 ../system/platforms/arm-rpi3/setupStack.o
compile/test.map:                0x0000000000008168       0x24 ../system/platforms/arm-rpi3/bcm2837_power.o
compile/test.map:                0x000000000000818c       0x30 ../system/platforms/arm-rpi3/bcm2837_power.o
compile/test.map:                0x00000000000081bc       0x64 ../system/platforms/arm-rpi3/bcm2837_power.o
compile/test.map:                0x0000000000008220       0x24 ../system/platforms/arm-rpi3/bcm2837_power.o
compile/test.map:                0x0000000000008244       0xbc ../system/platforms/arm-rpi3/dispatch.o
compile/test.map:                0x0000000000008300       0x6c ../system/platforms/arm-rpi3/dispatch.o
compile/test.map:                0x000000000000836c       0x6c ../system/platforms/arm-rpi3/dispatch.o
compile/test.map:                0x00000000000083d8       0x6c ../system/platforms/arm-rpi3/platforminit.o
compile/test.map:                0x0000000000008444       0x20 ../system/platforms/arm-rpi3/timer.o
compile/test.map:                0x0000000000008464       0x30 ../system/platforms/arm-rpi3/timer.o
compile/test.map:                0x0000000000008494       0x14 ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:                0x00000000000084a8       0x38 ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:                0x00000000000084e0       0x90 ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:                0x0000000000008570      0x2ec ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:                0x000000000000885c       0x44 ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:                0x00000000000088a0       0xd0 ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:                0x0000000000008970      0x38c ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:                0x0000000000008cfc      0x670 ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:                0x000000000000936c      0x134 ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:                0x00000000000094a0       0x4c ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:                0x00000000000094ec       0x20 ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:                0x000000000000950c       0x30 ../system/platforms/arm-rpi3/mmu.o
compile/test.map:                0x000000000000953c       0x4c ../system/platforms/arm-rpi3/mmu.o
compile/test.map:                0x0000000000009588       0x3c ../system/platforms/arm-rpi3/random.o
compile/test.map: .text.random   0x00000000000095c4       0x10 ../system/platforms/arm-rpi3/random.o
compile/test.map:                0x00000000000095d4       0x70 ../system/platforms/arm-rpi3/bcm2837_mbox.o
compile/test.map:                0x0000000000009644       0x18 ../system/platforms/arm-rpi3/bcm2837_mbox.o
compile/test.map:                0x000000000000965c       0x3c ../system/platforms/arm-rpi3/bcm2837_mbox.o
compile/test.map: .text.kputc    0x000000000000b114       0x4c ../device/uart-pl011/kputc.o
compile/test.map:                0x000000000000b160      0x100 ../device/uart-pl011/../uart/uartControl.o
compile/test.map:                0x000000000000b260       0x24 ../device/uart-pl011/../uart/uartGetc.o
compile/test.map:                0x000000000000b284       0xc8 ../device/uart-pl011/uartHwInit.o
compile/test.map:                0x000000000000b34c        0x8 ../device/uart-pl011/uartHwPutc.o
compile/test.map:                0x000000000000b354       0x5c ../device/uart-pl011/uartHwStat.o
compile/test.map:                0x000000000000b3b0       0xf8 ../device/uart-pl011/../uart/uartInit.o
compile/test.map:                0x000000000000b4a8      0x160 ../device/uart-pl011/uartInterrupt.o
compile/test.map:                0x000000000000b608       0x2c ../device/uart-pl011/../uart/uartPutc.o
compile/test.map:                0x000000000000b634       0xd0 ../device/uart-pl011/../uart/uartRead.o
compile/test.map:                0x000000000000b704       0xf0 ../device/uart-pl011/../uart/uartWrite.o
compile/test.map:                0x000000000000b7f4       0xcc ../device/uart-pl011/../uart/uartStat.o
compile/test.map: .text.kprintf  0x000000000000b8c0       0x4c ../device/uart-pl011/../uart/kprintf.o
compile/test.map:                0x000000000000b90c       0x44 ../device/uart-pl011/../uart/kvprintf.o
compile/test.map:                0x0000000000011654       0x30 ../system/platforms/arm-rpi3/dispatch.o
compile/test.map:                0x0000000000011684       0x17 ../system/platforms/arm-rpi3/platforminit.o
compile/test.map: .rodata        0x000000000001169c       0x67 ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:                0x0000000000011703       0x1d ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map: .rodata        0x00000000000119e0        0x8 ../device/uart-pl011/uartHwStat.o
compile/test.map:                0x00000000000119e8       0x91 ../device/uart-pl011/uartHwStat.o
compile/test.map:                0x0000000000011a79       0xa3 ../device/uart-pl011/../uart/uartStat.o
compile/test.map: .text          0x0000000000013d84       0x84 ../loader/platforms/arm-rpi3/start.o
compile/test.map: .text          0x0000000000013e10       0x1c ../system/platforms/arm-rpi3/ctxsw.o
compile/test.map: .text          0x0000000000013e2c        0x4 ../system/platforms/arm-rpi3/halt.o
compile/test.map: .text          0x0000000000013e30       0x1c ../system/platforms/arm-rpi3/intutils.o
compile/test.map: .text          0x0000000000013e4c       0x30 ../system/platforms/arm-rpi3/irq_handler.o
compile/test.map: .text          0x0000000000013e7c       0x14 ../system/platforms/arm-rpi3/memory_barrier.o
compile/test.map: .text          0x0000000000013e90       0x40 ../system/platforms/arm-rpi3/mutex.o
compile/test.map: .text          0x0000000000013ed0       0x80 ../system/platforms/arm-rpi3/mmu_util.o
compile/test.map: .iplt          0x0000000000013f50        0x0 ../loader/platforms/arm-rpi3/start.o
compile/test.map: .rel.iplt      0x0000000000013f50        0x0 ../loader/platforms/arm-rpi3/start.o
compile/test.map: .data          0x0000000000013f80        0x4 ../system/platforms/arm-rpi3/platforminit.o
compile/test.map: .igot.plt      0x000000000001404c        0x0 ../loader/platforms/arm-rpi3/start.o
compile/test.map: .bss           0x0000000000014080        0x4 ../system/platforms/arm-rpi3/bcm2837_power.o
compile/test.map: .bss           0x0000000000014084      0x12c ../system/platforms/arm-rpi3/dispatch.o
compile/test.map: .bss           0x00000000000141b0     0x203c ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map: .bss           0x00000000000161ec       0x30 ../system/platforms/arm-rpi3/unparkcore.o
compile/test.map: .bss           0x000000000001970c      0x83c ../device/uart-pl011/../uart/uartInit.o
compile/test.map: .bss           0x0000000000019f48        0x4 ../device/uart-pl011/../uart/kprintf.o
compile/test.map:LOAD ../loader/platforms/arm-rpi3/start.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/ctxsw.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/halt.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/intutils.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/irq_handler.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/memory_barrier.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/pause.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/getmode.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/getcpuid.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/setupCores.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/setmode.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/mutex.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/mmu_util.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/preload_data.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/setupStack.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/bcm2837_power.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/dispatch.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/kexec.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/platforminit.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/timer.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/watchdog.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/unparkcore.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/mmu.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/random.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/bcm2837_mbox.o
compile/test.map:LOAD ../system/platforms/arm-rpi3/des.o
compile/test.map:LOAD ../device/uart-pl011/kgetc.o
compile/test.map:LOAD ../device/uart-pl011/kputc.o
compile/test.map:LOAD ../device/uart-pl011/../uart/uartControl.o
compile/test.map:LOAD ../device/uart-pl011/../uart/uartGetc.o
compile/test.map:LOAD ../device/uart-pl011/uartHwInit.o
compile/test.map:LOAD ../device/uart-pl011/uartHwPutc.o
compile/test.map:LOAD ../device/uart-pl011/uartHwStat.o
compile/test.map:LOAD ../device/uart-pl011/../uart/uartInit.o
compile/test.map:LOAD ../device/uart-pl011/uartInterrupt.o
compile/test.map:LOAD ../device/uart-pl011/../uart/uartPutc.o
compile/test.map:LOAD ../device/uart-pl011/../uart/uartRead.o
compile/test.map:LOAD ../device/uart-pl011/../uart/uartWrite.o
compile/test.map:LOAD ../device/uart-pl011/../uart/uartStat.o
compile/test.map:LOAD ../device/uart-pl011/../uart/kprintf.o
compile/test.map:LOAD ../device/uart-pl011/../uart/kvprintf.o
compile/test.map:OUTPUT(xinu.elf elf32-littlearm)
compile/test.map:                0x0000000000000000       0x28 ../loader/platforms/arm-rpi3/start.o
compile/test.map:                0x0000000000000028       0x28 ../system/platforms/arm-rpi3/ctxsw.o
compile/test.map:                0x0000000000000050       0x28 ../system/platforms/arm-rpi3/halt.o
compile/test.map:                0x0000000000000078       0x28 ../system/platforms/arm-rpi3/intutils.o
compile/test.map:                0x00000000000000a0       0x28 ../system/platforms/arm-rpi3/irq_handler.o
compile/test.map:                0x00000000000000c8       0x28 ../system/platforms/arm-rpi3/memory_barrier.o
compile/test.map:                0x00000000000000f0       0x28 ../system/platforms/arm-rpi3/mutex.o
compile/test.map:                0x0000000000000118       0x28 ../system/platforms/arm-rpi3/mmu_util.o
compile/test.map:                0x0000000000000140       0x38 ../system/platforms/arm-rpi3/setupStack.o
compile/test.map:                0x0000000000000178       0x38 ../system/platforms/arm-rpi3/bcm2837_power.o
compile/test.map:                0x00000000000001b0       0x38 ../system/platforms/arm-rpi3/dispatch.o
compile/test.map:                0x00000000000001e8       0x38 ../system/platforms/arm-rpi3/platforminit.o
compile/test.map:                0x0000000000000220       0x38 ../system/platforms/arm-rpi3/timer.o
compile/test.map:                0x0000000000000258       0x38 ../system/platforms/arm-rpi3/usb_dwc_hcd.o
compile/test.map:                0x0000000000000290       0x38 ../system/platforms/arm-rpi3/unparkcore.o
compile/test.map:                0x00000000000002c8       0x38 ../system/platforms/arm-rpi3/mmu.o
compile/test.map:                0x0000000000000300       0x38 ../system/platforms/arm-rpi3/random.o
compile/test.map:                0x0000000000000338       0x38 ../system/platforms/arm-rpi3/bcm2837_mbox.o
compile/test.map:                0x0000000000000d10       0x38 ../device/uart-pl011/kputc.o
compile/test.map:                0x0000000000000d48       0x38 ../device/uart-pl011/../uart/uartControl.o
compile/test.map:                0x0000000000000d80       0x38 ../device/uart-pl011/../uart/uartGetc.o
compile/test.map:                0x0000000000000db8       0x38 ../device/uart-pl011/uartHwInit.o
compile/test.map:                0x0000000000000df0       0x38 ../device/uart-pl011/uartHwPutc.o
compile/test.map:                0x0000000000000e28       0x38 ../device/uart-pl011/uartHwStat.o
compile/test.map:                0x0000000000000e60       0x38 ../device/uart-pl011/../uart/uartInit.o
compile/test.map:                0x0000000000000e98       0x38 ../device/uart-pl011/uartInterrupt.o
compile/test.map:                0x0000000000000ed0       0x38 ../device/uart-pl011/../uart/uartPutc.o
compile/test.map:                0x0000000000000f08       0x38 ../device/uart-pl011/../uart/uartRead.o
compile/test.map:                0x0000000000000f40       0x38 ../device/uart-pl011/../uart/uartWrite.o
compile/test.map:                0x0000000000000f78       0x38 ../device/uart-pl011/../uart/uartStat.o
compile/test.map:                0x0000000000000fb0       0x38 ../device/uart-pl011/../uart/kprintf.o
compile/test.map:                0x0000000000000fe8       0x38 ../device/uart-pl011/../uart/kvprintf.o
Binary file compile/xinu.elf matches
Binary file compile/xinu.boot matches
device/ag71xx/Doxygroup.c: * @defgroup etherspecific Ethernet Device-Specific Functions
device/ag71xx/allocRxBuffer.c:    destIndex %= ethptr->rxRingSize;
device/ag71xx/allocRxBuffer.c:    pkt = bufget(ethptr->inPool);
device/ag71xx/allocRxBuffer.c:    pkt->length = ETH_RX_BUF_SIZE;
device/ag71xx/allocRxBuffer.c:    pkt->buf = (uchar *)(pkt + 1);
device/ag71xx/allocRxBuffer.c:    pkt->data = pkt->buf + ethptr->rxOffset;
device/ag71xx/allocRxBuffer.c:    ethptr->rxBufs[destIndex] = pkt;
device/ag71xx/allocRxBuffer.c:    dmaptr = ethptr->rxRing + destIndex;
device/ag71xx/allocRxBuffer.c:    dmaptr->control = ETH_DESC_CTRL_EMPTY;
device/ag71xx/allocRxBuffer.c:    dmaptr->address = (ulong)(pkt->buf) & PMEM_MASK;
device/ag71xx/allocRxBuffer.c:            destIndex, ethptr->rxBufs[destIndex]);
device/ag71xx/allocRxBuffer.c:         dmaptr->control, dmaptr->address, pkt);
device/ag71xx/allocRxBuffer.c:             pkt->buf, pkt->data, pkt->length);
device/ag71xx/allocRxBuffer.c:        rh = (struct rxHeader *)pkt->buf;
device/ag71xx/allocRxBuffer.c:             rh, rh ? rh->length : 0, rh ? rh->flags : 0);
device/ag71xx/colon2mac.c: * Convert a colon-separated string representation of a MAC into
device/ag71xx/colon2mac.c: * @param src pointer to colon-separated MAC string
device/ag71xx/colon2mac.c:            digit = c - '0';
device/ag71xx/colon2mac.c:            digit = 10 + c - (isupper(c) ? 'A' : 'a');
device/ag71xx/colon2mac.c:            digit = c - '0';
device/ag71xx/colon2mac.c:            digit = 10 + c - (isupper(c) ? 'A' : 'a');
device/ag71xx/etherClose.c:    ethptr = &ethertab[devptr->minor];
device/ag71xx/etherClose.c:    nicptr = ethptr->csr;
device/ag71xx/etherClose.c:    ethptr->state = ETH_STATE_DOWN;
device/ag71xx/etherClose.c:    nicptr->interruptMask = ethptr->interruptMask = 0x0;
device/ag71xx/etherClose.c:    nicptr->interruptStatus = 0x0;
device/ag71xx/etherClose.c:    bfpfree(ethptr->inPool);
device/ag71xx/etherClose.c:    bfpfree(ethptr->outPool);
device/ag71xx/etherControl.c:    ethptr = &ethertab[devptr->minor];
device/ag71xx/etherControl.c:    if (NULL == ethptr->csr)
device/ag71xx/etherControl.c:    nicptr = ethptr->csr;
device/ag71xx/etherControl.c:/*         nicptr->mibControl = MIB_CTRL_CLR_ON_READ; */
device/ag71xx/etherControl.c:/*         preg = &nicptr->txGoodOctets; */
device/ag71xx/etherControl.c:/*         while (preg <= &nicptr->txPause) */
device/ag71xx/etherControl.c:/*         preg = &nicptr->rxGoodOctets; */
device/ag71xx/etherControl.c:/*         while (preg <= &nicptr->rxNonPause) */
device/ag71xx/etherControl.c:/*         temp = nicptr->mibControl & ~MIB_CTRL_CLR_ON_READ; */
device/ag71xx/etherControl.c:/*         nicptr->mibControl = temp; */
device/ag71xx/etherControl.c:        nicptr->macAddr1 = temp;
device/ag71xx/etherControl.c:        nicptr->macAddr2 = temp;
device/ag71xx/etherControl.c:        temp = nicptr->macAddr1;
device/ag71xx/etherControl.c:        temp = nicptr->macAddr2;
device/ag71xx/etherControl.c:            nicptr->macConfig1 |= MAC_CFG1_LOOPBACK;
device/ag71xx/etherControl.c:            nicptr->macConfig1 &= ~MAC_CFG1_LOOPBACK;
device/ag71xx/etherControl.c:/*         if (backplaneCoreUp(&(nicptr->bpConfig))) */
device/ag71xx/etherControl.c:/*         backplaneReset(&(nicptr->bpConfig)); */
device/ag71xx/etherControl.c:/*         nicptr->mdioControl = (MDIO_CTRL_PREAMBLE | MDIO_CTRL_FREQ); */
device/ag71xx/etherControl.c:/*         nicptr->enetControl = ENET_CTRL_EPSEL; */
device/ag71xx/etherControl.c:/*         nicptr->rcvLazy = 0;     /\* Turn off lazy reception. *\/ */
device/ag71xx/etherControl.c:/*         nicptr->enetControl;     /\* Read control register.   *\/ */
device/ag71xx/etherControl.c:/*         waitOnBit(&nicptr->enetControl, ENET_CTRL_DISABLE, 0, 100); */
device/ag71xx/etherControl.c:/*         nicptr->dmaTxControl = 0; */
device/ag71xx/etherControl.c:/*         ethptr->txHead = 0; */
device/ag71xx/etherControl.c:/*         ethptr->txTail = 0; */
device/ag71xx/etherControl.c:/*         if (nicptr->dmaRxStatus & DMARX_STAT_EMASK) */
device/ag71xx/etherControl.c:/*             waitOnBit(&nicptr->dmaRxStatus, DMARX_STAT_SIDLE, 1, 100); */
device/ag71xx/etherControl.c:/*         nicptr->dmaRxControl = 0; */
device/ag71xx/etherControl.c:/*         ethptr->rxHead = 0; */
device/ag71xx/etherControl.c:/*         ethptr->rxTail = 0; */
device/ag71xx/etherControl.c:        addr->type = NETADDR_ETHERNET;
device/ag71xx/etherControl.c:        addr->len = ETH_ADDR_LEN;
device/ag71xx/etherControl.c:        etherControl(devptr, ETH_CTRL_GET_MAC, (int)addr->addr, NULL);
device/ag71xx/etherControl.c:        addr->type = NETADDR_ETHERNET;
device/ag71xx/etherControl.c:        addr->len = ETH_ADDR_LEN;
device/ag71xx/etherControl.c:        addr->addr[0] = 0xFF;
device/ag71xx/etherControl.c:        addr->addr[1] = 0xFF;
device/ag71xx/etherControl.c:        addr->addr[2] = 0xFF;
device/ag71xx/etherControl.c:        addr->addr[3] = 0xFF;
device/ag71xx/etherControl.c:        addr->addr[4] = 0xFF;
device/ag71xx/etherControl.c:        addr->addr[5] = 0xFF;
device/ag71xx/etherInit.c:    ethptr = &ethertab[devptr->minor];
device/ag71xx/etherInit.c:    ethptr->dev = devptr;
device/ag71xx/etherInit.c:    ethptr->csr = devptr->csr;
device/ag71xx/etherInit.c:    nicptr = (struct ag71xx *)devptr->csr;
device/ag71xx/etherInit.c:    if (0 == devptr->minor)
device/ag71xx/etherInit.c:    ethptr->state = ETH_STATE_DOWN;
device/ag71xx/etherInit.c:    ethptr->rxRingSize = ETH_RX_RING_ENTRIES;
device/ag71xx/etherInit.c:    ethptr->txRingSize = ETH_TX_RING_ENTRIES;
device/ag71xx/etherInit.c:    ethptr->mtu = ETH_MTU;
device/ag71xx/etherInit.c:    ethptr->interruptMask = IRQ_TX_PKTSENT | IRQ_TX_BUSERR
device/ag71xx/etherInit.c:    ethptr->errors = 0;
device/ag71xx/etherInit.c:    ethptr->isema = semcreate(0);
device/ag71xx/etherInit.c:    ethptr->istart = 0;
device/ag71xx/etherInit.c:    ethptr->icount = 0;
device/ag71xx/etherInit.c:    ethptr->ovrrun = 0;
device/ag71xx/etherInit.c:    ethptr->rxOffset = ETH_PKT_RESERVE;
device/ag71xx/etherInit.c:    colon2mac(nvramGet("et0macaddr"), ethptr->devAddress);
device/ag71xx/etherInit.c:    ethptr->addressLength = ETH_ADDR_LEN;
device/ag71xx/etherInit.c:    nicptr->macConfig1 |= MAC_CFG1_SOFTRESET;
device/ag71xx/etherInit.c:    nicptr->macConfig1 = MAC_CFG1_TX | MAC_CFG1_SYNC_TX |
device/ag71xx/etherInit.c:    nicptr->macConfig2 |=
device/ag71xx/etherInit.c:    nicptr->fifoConfig0 = FIFO_CFG0_WTMENREQ | FIFO_CFG0_SRFENREQ |
device/ag71xx/etherInit.c:    // -> ag71xx_mii_ctrl_set_if(ag, pdata->mii_if);
device/ag71xx/etherInit.c:    nicptr->fifoConfig1 = 0x0FFF0000;
device/ag71xx/etherInit.c:    nicptr->fifoConfig2 = 0x00001FFF;
device/ag71xx/etherInit.c:    nicptr->fifoConfig4 = 0x0003FFFF;
device/ag71xx/etherInit.c:    nicptr->fifoConfig5 = 0x0003FFFF;
device/ag71xx/etherInit.c:    /*  page-aligned (and cache-aligned) boundaries.                */
device/ag71xx/etherInit.c:    ethptr->rxBufs = stkget(PAGE_SIZE);
device/ag71xx/etherInit.c:    ethptr->txBufs = stkget(PAGE_SIZE);
device/ag71xx/etherInit.c:    ethptr->rxRing = stkget(PAGE_SIZE);
device/ag71xx/etherInit.c:    ethptr->txRing = stkget(PAGE_SIZE);
device/ag71xx/etherInit.c:    if ((SYSERR == (int)ethptr->rxBufs)
device/ag71xx/etherInit.c:        || (SYSERR == (int)ethptr->txBufs)
device/ag71xx/etherInit.c:        || (SYSERR == (int)ethptr->rxRing)
device/ag71xx/etherInit.c:        || (SYSERR == (int)ethptr->txRing))
device/ag71xx/etherInit.c:        kprintf("eth%d ring buffer allocation error.\r\n", devptr->minor);
device/ag71xx/etherInit.c:    ethptr->rxBufs =
device/ag71xx/etherInit.c:         **)(((ulong)ethptr->rxBufs - PAGE_SIZE +
device/ag71xx/etherInit.c:    ethptr->txBufs =
device/ag71xx/etherInit.c:         **)(((ulong)ethptr->txBufs - PAGE_SIZE +
device/ag71xx/etherInit.c:    ethptr->rxRing =
device/ag71xx/etherInit.c:         *)(((ulong)ethptr->rxRing - PAGE_SIZE +
device/ag71xx/etherInit.c:    ethptr->txRing =
device/ag71xx/etherInit.c:         *)(((ulong)ethptr->txRing - PAGE_SIZE +
device/ag71xx/etherInit.c:    bzero(ethptr->rxBufs, PAGE_SIZE);
device/ag71xx/etherInit.c:    bzero(ethptr->txBufs, PAGE_SIZE);
device/ag71xx/etherInit.c:    bzero(ethptr->rxRing, PAGE_SIZE);
device/ag71xx/etherInit.c:    bzero(ethptr->txRing, PAGE_SIZE);
device/ag71xx/etherInit.c:    interruptVector[devptr->irq] = devptr->intr;
device/ag71xx/etherInit.c:    enable_irq(devptr->irq);
device/ag71xx/etherInterrupt.c:        head = ethptr->rxHead % ETH_RX_RING_ENTRIES;
device/ag71xx/etherInterrupt.c:        dmaptr = &ethptr->rxRing[head];
device/ag71xx/etherInterrupt.c:        if (dmaptr->control & ETH_DESC_CTRL_EMPTY)
device/ag71xx/etherInterrupt.c:            nicptr->rxStatus = RX_STAT_RECVD;
device/ag71xx/etherInterrupt.c:        pkt = ethptr->rxBufs[head];
device/ag71xx/etherInterrupt.c:        pkt->length = dmaptr->control & ETH_DESC_CTRL_LEN;
device/ag71xx/etherInterrupt.c:        if (ethptr->icount < ETH_IBLEN)
device/ag71xx/etherInterrupt.c:            ethptr->in[(ethptr->istart + ethptr->icount) % ETH_IBLEN] =
device/ag71xx/etherInterrupt.c:            ethptr->icount++;
device/ag71xx/etherInterrupt.c:            signaln(ethptr->isema, 1);
device/ag71xx/etherInterrupt.c:            ethptr->ovrrun++;
device/ag71xx/etherInterrupt.c:            bzero(pkt->buf, pkt->length);
device/ag71xx/etherInterrupt.c:        ethptr->rxHead++;
device/ag71xx/etherInterrupt.c:        nicptr->rxStatus = RX_STAT_RECVD;
device/ag71xx/etherInterrupt.c:    // kprintf("txS=0x%08X\r\n", nicptr->txStatus);
device/ag71xx/etherInterrupt.c:    if (ethptr->txHead == ethptr->txTail)
device/ag71xx/etherInterrupt.c:        nicptr->txStatus = TX_STAT_SENT;
device/ag71xx/etherInterrupt.c:    while (ethptr->txHead != ethptr->txTail)
device/ag71xx/etherInterrupt.c:        head = ethptr->txHead % ETH_TX_RING_ENTRIES;
device/ag71xx/etherInterrupt.c:        dmaptr = &ethptr->txRing[head];
device/ag71xx/etherInterrupt.c:        if (!(dmaptr->control & ETH_DESC_CTRL_EMPTY))
device/ag71xx/etherInterrupt.c:        epb = &ethptr->txBufs[head];
device/ag71xx/etherInterrupt.c:        nicptr->txStatus = TX_STAT_SENT;
device/ag71xx/etherInterrupt.c:        ethptr->txHead++;
device/ag71xx/etherInterrupt.c:    nicptr = ethptr->csr;
device/ag71xx/etherInterrupt.c:    mask = nicptr->interruptMask;
device/ag71xx/etherInterrupt.c:    status = nicptr->interruptStatus & mask;
device/ag71xx/etherInterrupt.c:    ethptr->interruptStatus = status;
device/ag71xx/etherInterrupt.c:        ethptr->txirq++;
device/ag71xx/etherInterrupt.c:        ethptr->rxirq++;
device/ag71xx/etherInterrupt.c:        nicptr->rxStatus = RX_STAT_OVERFLOW;
device/ag71xx/etherInterrupt.c:        nicptr->rxControl = RX_CTRL_RXE;
device/ag71xx/etherInterrupt.c:        ethptr->errors++;
device/ag71xx/etherInterrupt.c:        ethptr->errors++;
device/ag71xx/etherInterrupt.c:        // etherClose(ethptr->dev);
device/ag71xx/etherInterrupt.c:    if (--resdefer > 0)
device/ag71xx/etherOpen.c:    ethptr = &ethertab[devptr->minor];
device/ag71xx/etherOpen.c:    nicptr = ethptr->csr;
device/ag71xx/etherOpen.c:    while (nicptr->rxStatus & RX_STAT_COUNT)
device/ag71xx/etherOpen.c:        nicptr->rxStatus = RX_STAT_RECVD;
device/ag71xx/etherOpen.c:        ethptr->txRing[i].next =
device/ag71xx/etherOpen.c:            (ulong)(ethptr->txRing + ((i + 1) % ETH_TX_RING_ENTRIES))
device/ag71xx/etherOpen.c:        ethptr->txRing[i].control = ETH_DESC_CTRL_EMPTY;
device/ag71xx/etherOpen.c:        ethptr->txBufs[i] = NULL;
device/ag71xx/etherOpen.c:    nicptr->txDMA = ((ulong)ethptr->txRing) & PMEM_MASK;
device/ag71xx/etherOpen.c:    ethptr->outPool =
device/ag71xx/etherOpen.c:    if (SYSERR == ethptr->outPool)
device/ag71xx/etherOpen.c:        ETH_TRACE("eth%d outPool buffer error.\r\n", devptr->minor);
device/ag71xx/etherOpen.c:    ethptr->inPool =
device/ag71xx/etherOpen.c:    if (SYSERR == ethptr->inPool)
device/ag71xx/etherOpen.c:        ETH_TRACE("eth%d inPool buffer error.\r\n", devptr->minor);
device/ag71xx/etherOpen.c:        ethptr->rxRing[i].next =
device/ag71xx/etherOpen.c:            (ulong)(ethptr->rxRing + ((i + 1) % ETH_RX_RING_ENTRIES))
device/ag71xx/etherOpen.c:    for (i = 0; i < ethptr->rxRingSize; i++)
device/ag71xx/etherOpen.c:    nicptr->rxDMA = ((ulong)ethptr->rxRing) & PMEM_MASK;
device/ag71xx/etherOpen.c:    etherControl(devptr, ETH_CTRL_SET_MAC, (long)ethptr->devAddress, 0);
device/ag71xx/etherOpen.c:    nicptr->rxControl = RX_CTRL_RXE;
device/ag71xx/etherOpen.c:    ethptr->state = ETH_STATE_UP;
device/ag71xx/etherOpen.c:    nicptr->interruptMask = ethptr->interruptMask;
device/ag71xx/etherRead.c:    ethptr = &ethertab[devptr->minor];
device/ag71xx/etherRead.c:    if (ETH_STATE_UP != ethptr->state)
device/ag71xx/etherRead.c:    wait(ethptr->isema);
device/ag71xx/etherRead.c:    pkt = ethptr->in[ethptr->istart];
device/ag71xx/etherRead.c:    ethptr->in[ethptr->istart] = NULL;
device/ag71xx/etherRead.c:    ethptr->istart = (ethptr->istart + 1) % ETH_IBLEN;
device/ag71xx/etherRead.c:    ethptr->icount--;
device/ag71xx/etherRead.c:/*     rh = (struct rxHeader *)pkt->buf; */
device/ag71xx/etherRead.c:/*     pvlan = (struct vlanPkt *)pkt->data; */
device/ag71xx/etherRead.c:/*     rh->length -= ETH_CRC_LEN; */
device/ag71xx/etherRead.c:/*     if (ETH_TYPE_VLAN == net2hs(pvlan->tpi)) */
device/ag71xx/etherRead.c:/*         rh->length -= 4;        /\* Account for vlan tag removal *\/ */
device/ag71xx/etherRead.c:/*     length = (rh->length < len) ? rh->length : len; */
device/ag71xx/etherRead.c:/*     if (ETH_TYPE_VLAN == net2hs(pvlan->tpi)) */
device/ag71xx/etherRead.c:/*         memcpy(buffer, pkt->data, 12); */
device/ag71xx/etherRead.c:/*         memcpy(buffer + 12, pkt->data + 16, length - 12); */
device/ag71xx/etherRead.c:    length = pkt->length;
device/ag71xx/etherRead.c:    memcpy(buf, (uchar *)(((ulong)pkt->buf) | KSEG1_BASE), length);
device/ag71xx/etherStat.c:    nicptr = ethptr->csr;
device/ag71xx/etherStat.c:    control(ethptr->dev->num, ETH_CTRL_GET_MAC, (long)mac, 0);
device/ag71xx/etherStat.c:    fprintf(stdout, "      %8d MTU", ethptr->mtu);
device/ag71xx/etherStat.c:    tmp = ethptr->state;
device/ag71xx/etherStat.c:    fprintf(stdout, "  Errors %d\n", ethptr->errors);
device/ag71xx/etherStat.c:    tmp = ethptr->interruptStatus;
device/ag71xx/etherStat.c:    tmp = ethptr->interruptMask;
device/ag71xx/etherStat.c:    tmp = nicptr->macConfig1;
device/ag71xx/etherStat.c:    tmp = nicptr->macConfig2;
device/ag71xx/etherStat.c:    fprintf(stdout, "  FIFO Config0 0x%08X", nicptr->fifoConfig0);
device/ag71xx/etherStat.c:    fprintf(stdout, "  FIFO Config1 0x%08X", nicptr->fifoConfig1);
device/ag71xx/etherStat.c:    fprintf(stdout, "  FIFO Config2 0x%08X\n", nicptr->fifoConfig2);
device/ag71xx/etherStat.c:    fprintf(stdout, "  FIFO Config3 0x%08X", nicptr->fifoConfig3);
device/ag71xx/etherStat.c:    fprintf(stdout, "  FIFO Config4 0x%08X", nicptr->fifoConfig4);
device/ag71xx/etherStat.c:    fprintf(stdout, "  FIFO Config5 0x%08X\n", nicptr->fifoConfig5);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Tx Ring      0x%08X", ethptr->txRing);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Tx Bufs      0x%08X", ethptr->txBufs);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Tx Ring Size   %8d\n", ethptr->txRingSize);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Tx IRQ Count   %8d", ethptr->txirq);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Tx Head        %8d", ethptr->txHead);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Tx Tail        %8d\n", ethptr->txTail);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Tx Control   0x%08X", nicptr->txControl);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Tx DMA       0x%08X", nicptr->txDMA);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Tx Status    0x%08X\n", nicptr->txStatus);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Rx Ring      0x%08X", ethptr->rxRing);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Rx Bufs      0x%08X", ethptr->rxBufs);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Rx Ring Size   %8d\n", ethptr->rxRingSize);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Rx IRQ Count   %8d", ethptr->rxirq);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Rx Head        %8d", ethptr->rxHead);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Rx Errors      %8d\n", ethptr->rxErrors);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Rx Control   0x%08X", nicptr->rxControl);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Rx DMA       0x%08X", nicptr->rxDMA);
device/ag71xx/etherStat.c:    fprintf(stdout, "  Rx Status    0x%08X\n", nicptr->rxStatus);
device/ag71xx/etherStat.c:        dmaptr = &ethptr->rxRing[i];
device/ag71xx/etherStat.c:        if (0 == dmaptr->control)
device/ag71xx/etherStat.c:                    dmaptr->address);
device/ag71xx/etherStat.c:            kprintf("  Rx Cntl 0x%08X", dmaptr->control);
device/ag71xx/etherStat.c:            kprintf("  Rx Next 0x%08X\r\n", dmaptr->next);
device/ag71xx/etherStat.c:    nicptr = ethptr->csr;
device/ag71xx/etherStat.c:    if (ethptr->dev != ethptr->phy)
device/ag71xx/etherWrite.c:    ethptr = &ethertab[devptr->minor];
device/ag71xx/etherWrite.c:    nicptr = ethptr->csr;
device/ag71xx/etherWrite.c:    if ((ETH_STATE_UP != ethptr->state)
device/ag71xx/etherWrite.c:        || (len > (ETH_TX_BUF_SIZE - ETH_VLAN_LEN)))
device/ag71xx/etherWrite.c:    tail = ethptr->txTail % ETH_TX_RING_ENTRIES;
device/ag71xx/etherWrite.c:    dmaptr = &ethptr->txRing[tail];
device/ag71xx/etherWrite.c:    if (!(dmaptr->control & ETH_DESC_CTRL_EMPTY))
device/ag71xx/etherWrite.c:        ethptr->errors++;
device/ag71xx/etherWrite.c:    pkt = (struct ethPktBuffer *)bufget(ethptr->outPool);
device/ag71xx/etherWrite.c:        ethptr->errors++;
device/ag71xx/etherWrite.c:    pkt->buf = (uchar *)(pkt + 1);
device/ag71xx/etherWrite.c:    pkt->data = pkt->buf;
device/ag71xx/etherWrite.c:    memcpy(pkt->data, buffer, len);
device/ag71xx/etherWrite.c:    ethptr->txBufs[tail] = pkt;
device/ag71xx/etherWrite.c:    ethptr->txRing[tail].address = (ulong)pkt->data & PMEM_MASK;
device/ag71xx/etherWrite.c:    ethptr->txRing[tail].control = len & ETH_DESC_CTRL_LEN;
device/ag71xx/etherWrite.c:    ethptr->txTail++;
device/ag71xx/etherWrite.c:    if (nicptr->txStatus & TX_STAT_UNDER)
device/ag71xx/etherWrite.c:        nicptr->txDMA = ((ulong)(ethptr->txRing + tail)) & PMEM_MASK;
device/ag71xx/etherWrite.c:        nicptr->txStatus = TX_STAT_UNDER;
device/ag71xx/etherWrite.c:    nicptr->txControl = TX_CTRL_ENABLE;
device/ag71xx/waitOnBit.c:         * - if expected value is non-zero, check if the register & mask has
device/ag71xx/waitOnBit.c:         *   a non-zero value
device/ag71xx/waitOnBit.c:         * - if expected value is zero, check if the register & mask has
device/ag71xx/waitOnBit.c:        for (j = 100; j; j--)
device/bcm4713/Doxygroup.c: * @defgroup etherspecific Ethernet Device-Specific Functions
device/bcm4713/allocRxBuffer.c:    destIndex %= ethptr->rxRingSize;
device/bcm4713/allocRxBuffer.c:    pkt = bufget(ethptr->inPool);
device/bcm4713/allocRxBuffer.c:    pkt->length = ETH_RX_BUF_SIZE;
device/bcm4713/allocRxBuffer.c:    pkt->buf = (uchar *)(pkt + 1);
device/bcm4713/allocRxBuffer.c:    pkt->data = pkt->buf + ethptr->rxOffset;
device/bcm4713/allocRxBuffer.c:    ethptr->rxBufs[destIndex] = pkt;
device/bcm4713/allocRxBuffer.c:    dmaptr = ethptr->rxRing + destIndex;
device/bcm4713/allocRxBuffer.c:    dmaptr->control = ETH_DESC_CTRL_LEN & pkt->length;
device/bcm4713/allocRxBuffer.c:    if ((ethptr->rxRingSize - 1) == destIndex)
device/bcm4713/allocRxBuffer.c:        dmaptr->control |= ETH_DESC_CTRL_EOT;
device/bcm4713/allocRxBuffer.c:    dmaptr->address = (ulong)(pkt->buf) & PMEM_MASK;
device/bcm4713/allocRxBuffer.c:            destIndex, ethptr->rxBufs[destIndex]);
device/bcm4713/allocRxBuffer.c:         dmaptr->control, dmaptr->address, pkt);
device/bcm4713/allocRxBuffer.c:             pkt->buf, pkt->data, pkt->length);
device/bcm4713/allocRxBuffer.c:        rh = (struct rxHeader *)pkt->buf;
device/bcm4713/allocRxBuffer.c:             rh, rh ? rh->length : 0, rh ? rh->flags : 0);
device/bcm4713/bcm4713.h:    /* Direct Memory Access (DMA) features 0x200 - 0x2FF                */
device/bcm4713/bcm4713.h:#define DMARX_STAT_EBEBW     0x00030000 /* Bus Error - Buffer Write    */
device/bcm4713/bcm4713.h:#define DMARX_STAT_EBEDA     0x00040000 /* Bus Error - Desc. Access    */
device/bcm4713/bcm4713.h:    /* Don't know what's in blocks 0x300 - 0x3FF                        */
device/bcm4713/bcm4713.h:    /* EMAC features in block 0x400 - 0x4FF                             */
device/bcm4713/bcm4713.h:    /* MIB statistics in block 0x500 - 0x5FF                            */
device/bcm4713/bcm4713.h:    volatile uint rxNonPause;         /**< MIB Rx Non-Pause Packets     */
device/bcm4713/bcm4713.h:    /* Don't know what's in blocks 0x600 - 0xEFF                        */
device/bcm4713/bcm4713.h:    /* Silicon Backplane configuration space in 0xF00 - 0xFFF           */
device/bcm4713/bcmswitch.h:#define SWT_CPUPORT (SWT_PORTS - 1)
device/bcm4713/colon2mac.c: * Convert a colon-separated string representation of a MAC into
device/bcm4713/colon2mac.c: * @param src pointer to colon-separated MAC string
device/bcm4713/colon2mac.c:            digit = c - '0';
device/bcm4713/colon2mac.c:            digit = 10 + c - (isupper(c) ? 'A' : 'a');
device/bcm4713/colon2mac.c:            digit = c - '0';
device/bcm4713/colon2mac.c:            digit = 10 + c - (isupper(c) ? 'A' : 'a');
device/bcm4713/etherClose.c:    ethptr = &ethertab[devptr->minor];
device/bcm4713/etherClose.c:    nicptr = ethptr->csr;
device/bcm4713/etherClose.c:    ethptr->state = ETH_STATE_DOWN;
device/bcm4713/etherClose.c:    nicptr->interruptMask = ethptr->interruptMask = 0x0;
device/bcm4713/etherClose.c:    nicptr->interruptStatus = 0x0;
device/bcm4713/etherClose.c:    bfpfree(ethptr->inPool);
device/bcm4713/etherClose.c:    bfpfree(ethptr->outPool);
device/bcm4713/etherControl.c:    ethptr = &ethertab[devptr->minor];
device/bcm4713/etherControl.c:    if (NULL == ethptr->csr)
device/bcm4713/etherControl.c:    nicptr = ethptr->csr;
device/bcm4713/etherControl.c:        nicptr->mibControl = MIB_CTRL_CLR_ON_READ;
device/bcm4713/etherControl.c:        regptr = &nicptr->txGoodOctets;
device/bcm4713/etherControl.c:        while (regptr <= &nicptr->txPause)
device/bcm4713/etherControl.c:        regptr = &nicptr->rxGoodOctets;
device/bcm4713/etherControl.c:        while (regptr <= &nicptr->rxNonPause)
device/bcm4713/etherControl.c:        temp = nicptr->mibControl & ~MIB_CTRL_CLR_ON_READ;
device/bcm4713/etherControl.c:        nicptr->mibControl = temp;
device/bcm4713/etherControl.c:        nicptr->camControl = 0;
device/bcm4713/etherControl.c:        nicptr->camDataLo = temp;
device/bcm4713/etherControl.c:        nicptr->camDataHi = temp;
device/bcm4713/etherControl.c:        nicptr->camControl =
device/bcm4713/etherControl.c:            (devptr->minor << CAM_CTRL_INDEX_SHIFT) | CAM_CTRL_WRITE;
device/bcm4713/etherControl.c:        waitOnBit(&nicptr->camControl, CAM_CTRL_BUSY, 0, 100);
device/bcm4713/etherControl.c:        /* Re-enable CAM control */
device/bcm4713/etherControl.c:        nicptr->camControl |= CAM_CTRL_ENABLE;
device/bcm4713/etherControl.c:        nicptr->camControl =
device/bcm4713/etherControl.c:            (devptr->minor << CAM_CTRL_INDEX_SHIFT) | CAM_CTRL_READ;
device/bcm4713/etherControl.c:        waitOnBit(&nicptr->camControl, CAM_CTRL_BUSY, 0, 100);
device/bcm4713/etherControl.c:        temp = nicptr->camDataLo;
device/bcm4713/etherControl.c:        temp = nicptr->camDataHi;
device/bcm4713/etherControl.c:        /* Re-enable CAM control */
device/bcm4713/etherControl.c:        nicptr->camControl = CAM_CTRL_ENABLE;
device/bcm4713/etherControl.c:        addr->type = NETADDR_ETHERNET;
device/bcm4713/etherControl.c:        addr->len = ETH_ADDR_LEN;
device/bcm4713/etherControl.c:        etherControl(devptr, ETH_CTRL_GET_MAC, (int)addr->addr, NULL);
device/bcm4713/etherControl.c:        addr->type = NETADDR_ETHERNET;
device/bcm4713/etherControl.c:        addr->len = ETH_ADDR_LEN;
device/bcm4713/etherControl.c:        addr->addr[0] = 0xFF;
device/bcm4713/etherControl.c:        addr->addr[1] = 0xFF;
device/bcm4713/etherControl.c:        addr->addr[2] = 0xFF;
device/bcm4713/etherControl.c:        addr->addr[3] = 0xFF;
device/bcm4713/etherControl.c:        addr->addr[4] = 0xFF;
device/bcm4713/etherControl.c:        addr->addr[5] = 0xFF;
device/bcm4713/etherControl.c:            nicptr->rxConfig = RXCONFIG_LPBACK;
device/bcm4713/etherControl.c:            nicptr->rxConfig = 0;
device/bcm4713/etherControl.c:        if (backplaneCoreUp(&(nicptr->bpConfig)))
device/bcm4713/etherControl.c:        backplaneReset(&(nicptr->bpConfig));
device/bcm4713/etherControl.c:        nicptr->mdioControl = (MDIO_CTRL_PREAMBLE | MDIO_CTRL_FREQ);
device/bcm4713/etherControl.c:        nicptr->enetControl = ENET_CTRL_EPSEL;
device/bcm4713/etherControl.c:        nicptr->rcvLazy = 0;    /* Turn off lazy reception. */
device/bcm4713/etherControl.c:        nicptr->enetControl;    /* Read control register.   */
device/bcm4713/etherControl.c:        waitOnBit(&nicptr->enetControl, ENET_CTRL_DISABLE, 0, 100);
device/bcm4713/etherControl.c:        nicptr->dmaTxControl = 0;
device/bcm4713/etherControl.c:        ethptr->txHead = 0;
device/bcm4713/etherControl.c:        ethptr->txTail = 0;
device/bcm4713/etherControl.c:        if (nicptr->dmaRxStatus & DMARX_STAT_EMASK)
device/bcm4713/etherControl.c:            waitOnBit(&nicptr->dmaRxStatus, DMARX_STAT_SIDLE, 1, 100);
device/bcm4713/etherControl.c:        nicptr->dmaRxControl = 0;
device/bcm4713/etherControl.c:        ethptr->rxHead = 0;
device/bcm4713/etherControl.c:        ethptr->rxTail = 0;
device/bcm4713/etherInit.c:    ethptr = &ethertab[devptr->minor];
device/bcm4713/etherInit.c:    ethptr->dev = devptr;
device/bcm4713/etherInit.c:    ethptr->csr = devptr->csr;
device/bcm4713/etherInit.c:    ethptr->phy = devptr;
device/bcm4713/etherInit.c:    ethptr->state = ETH_STATE_DOWN;
device/bcm4713/etherInit.c:    ethptr->rxRingSize = ETH_RX_RING_ENTRIES;
device/bcm4713/etherInit.c:    ethptr->txRingSize = ETH_TX_RING_ENTRIES;
device/bcm4713/etherInit.c:    ethptr->mtu = ETH_MTU;
device/bcm4713/etherInit.c:    ethptr->interruptMask = IMASK_DEF;
device/bcm4713/etherInit.c:    ethptr->errors = 0;
device/bcm4713/etherInit.c:    ethptr->isema = semcreate(0);
device/bcm4713/etherInit.c:    ethptr->istart = 0;
device/bcm4713/etherInit.c:    ethptr->icount = 0;
device/bcm4713/etherInit.c:    ethptr->ovrrun = 0;
device/bcm4713/etherInit.c:    ethptr->rxOffset = sizeof(struct rxHeader);
device/bcm4713/etherInit.c:    colon2mac(nvramGet("et0macaddr"), ethptr->devAddress);
device/bcm4713/etherInit.c:    /*  page-aligned (and cache-aligned) boundaries.                */
device/bcm4713/etherInit.c:    ethptr->rxBufs = stkget(PAGE_SIZE);
device/bcm4713/etherInit.c:    ethptr->txBufs = stkget(PAGE_SIZE);
device/bcm4713/etherInit.c:    ethptr->rxRing = stkget(PAGE_SIZE);
device/bcm4713/etherInit.c:    ethptr->txRing = stkget(PAGE_SIZE);
device/bcm4713/etherInit.c:    if ((SYSERR == (int)ethptr->rxBufs)
device/bcm4713/etherInit.c:        || (SYSERR == (int)ethptr->txBufs)
device/bcm4713/etherInit.c:        || (SYSERR == (int)ethptr->rxRing)
device/bcm4713/etherInit.c:        || (SYSERR == (int)ethptr->txRing))
device/bcm4713/etherInit.c:        kprintf("eth%d ring buffer allocation error.\r\n", devptr->minor);
device/bcm4713/etherInit.c:    ethptr->rxBufs =
device/bcm4713/etherInit.c:         **)(((ulong)ethptr->rxBufs - PAGE_SIZE +
device/bcm4713/etherInit.c:    ethptr->txBufs =
device/bcm4713/etherInit.c:         **)(((ulong)ethptr->txBufs - PAGE_SIZE +
device/bcm4713/etherInit.c:    ethptr->rxRing =
device/bcm4713/etherInit.c:         *)(((ulong)ethptr->rxRing - PAGE_SIZE +
device/bcm4713/etherInit.c:    ethptr->txRing =
device/bcm4713/etherInit.c:         *)(((ulong)ethptr->txRing - PAGE_SIZE +
device/bcm4713/etherInit.c:    bzero(ethptr->rxBufs, PAGE_SIZE);
device/bcm4713/etherInit.c:    bzero(ethptr->txBufs, PAGE_SIZE);
device/bcm4713/etherInit.c:    bzero(ethptr->rxRing, PAGE_SIZE);
device/bcm4713/etherInit.c:    bzero(ethptr->txRing, PAGE_SIZE);
device/bcm4713/etherInit.c:    switchInit((struct bcm4713 *)ethptr->csr);
device/bcm4713/etherInit.c:    interruptVector[devptr->irq] = devptr->intr;
device/bcm4713/etherInit.c:    enable_irq(devptr->irq);
device/bcm4713/etherInterrupt.c:    /* 12-bit descriptor indicates where card is currently placing   */
device/bcm4713/etherInterrupt.c:    tail = (nicptr->dmaRxStatus & DMARX_STAT_CDMASK)
device/bcm4713/etherInterrupt.c:    head = ethptr->rxHead;
device/bcm4713/etherInterrupt.c:        pkt = ethptr->rxBufs[head];
device/bcm4713/etherInterrupt.c:        rh = (struct rxHeader *)pkt->buf;
device/bcm4713/etherInterrupt.c:        lanptr = (struct vlanPkt *)pkt->data;
device/bcm4713/etherInterrupt.c:        if (ETH_TYPE_VLAN == net2hs(lanptr->tpi))
device/bcm4713/etherInterrupt.c:            phyptr = &ethertab[net2hs(lanptr->vlanId) & ETH_VLAN_IDMASK];
device/bcm4713/etherInterrupt.c:        if ((rh->length >
device/bcm4713/etherInterrupt.c:            || (rh->flags & ETH_RX_FLAG_ERRORS))
device/bcm4713/etherInterrupt.c:            phyptr->rxErrors++;
device/bcm4713/etherInterrupt.c:            bzero(pkt->buf, pkt->length);
device/bcm4713/etherInterrupt.c:            if (phyptr->icount < ETH_IBLEN)
device/bcm4713/etherInterrupt.c:                phyptr->in[(phyptr->istart + phyptr->icount) %
device/bcm4713/etherInterrupt.c:                phyptr->icount++;
device/bcm4713/etherInterrupt.c:                signaln(phyptr->isema, 1);
device/bcm4713/etherInterrupt.c:                phyptr->ovrrun++;
device/bcm4713/etherInterrupt.c:                bzero(pkt->buf, pkt->length);
device/bcm4713/etherInterrupt.c:        ethptr->rxTail = (ethptr->rxTail + 1) % ethptr->rxRingSize;
device/bcm4713/etherInterrupt.c:        nicptr->dmaRxLast = ethptr->rxTail * sizeof(struct dmaDescriptor);
device/bcm4713/etherInterrupt.c:        head = (head + 1) % ethptr->rxRingSize;
device/bcm4713/etherInterrupt.c:    ethptr->rxHead = head;
device/bcm4713/etherInterrupt.c:    current = (nicptr->dmaTxStatus & DMATX_STAT_CDMASK)
device/bcm4713/etherInterrupt.c:    for (head = ethptr->txHead; head != current;
device/bcm4713/etherInterrupt.c:         head = (head + 1) % ethptr->txRingSize)
device/bcm4713/etherInterrupt.c:        epb = &ethptr->txBufs[head];
device/bcm4713/etherInterrupt.c:    ethptr->txHead = head;
device/bcm4713/etherInterrupt.c:    nicptr->gpTimer = 0;
device/bcm4713/etherInterrupt.c:    nicptr = ethptr->csr;
device/bcm4713/etherInterrupt.c:    mask = nicptr->interruptMask;
device/bcm4713/etherInterrupt.c:    status = nicptr->interruptStatus & mask;
device/bcm4713/etherInterrupt.c:    ethptr->interruptStatus = status;
device/bcm4713/etherInterrupt.c:        ethptr->txirq++;
device/bcm4713/etherInterrupt.c:        nicptr->gpTimer = 2 * platform.clkfreq;
device/bcm4713/etherInterrupt.c:        ethptr->rxirq++;
device/bcm4713/etherInterrupt.c:        nicptr->gpTimer = 0;
device/bcm4713/etherInterrupt.c:            ethptr->errors++;
device/bcm4713/etherInterrupt.c:            etherClose(ethptr->dev);
device/bcm4713/etherInterrupt.c:    nicptr->interruptStatus = status;
device/bcm4713/etherInterrupt.c:    if (--resdefer > 0)
device/bcm4713/etherOpen.c:    ethptr = &ethertab[devptr->minor];
device/bcm4713/etherOpen.c:    nicptr = ethptr->csr;
device/bcm4713/etherOpen.c:       all ethernet devices--both real and virtual */
device/bcm4713/etherOpen.c:    ethptr->inPool =
device/bcm4713/etherOpen.c:                devptr->minor, ethptr->inPool);
device/bcm4713/etherOpen.c:    if (SYSERR == ethptr->inPool)
device/bcm4713/etherOpen.c:        kprintf("eth%d inPool buffer error.\r\n", devptr->minor);
device/bcm4713/etherOpen.c:    ethptr->outPool =
device/bcm4713/etherOpen.c:                 ETH_TX_RING_ENTRIES - 1);
device/bcm4713/etherOpen.c:                devptr->minor, ethptr->outPool);
device/bcm4713/etherOpen.c:    if (SYSERR == ethptr->outPool)
device/bcm4713/etherOpen.c:        kprintf("eth%d outPool buffer error.\r\n", devptr->minor);
device/bcm4713/etherOpen.c:    nicptr->dmaTxControl = DMATX_CTRL_ENABLE;
device/bcm4713/etherOpen.c:    nicptr->dmaTxAddress = (ulong)ethptr->txRing & PMEM_MASK;
device/bcm4713/etherOpen.c:    nicptr->dmaRxControl = DMARX_CTRL_ENABLE |
device/bcm4713/etherOpen.c:        (ethptr->rxOffset << DMARX_CTRL_ROSHIFT);
device/bcm4713/etherOpen.c:    nicptr->dmaRxAddress = (ulong)ethptr->rxRing & PMEM_MASK;
device/bcm4713/etherOpen.c:    for (i = 0; i < ethptr->rxRingSize; i++)
device/bcm4713/etherOpen.c:    nicptr->dmaRxLast = ethptr->rxRingSize * sizeof(struct dmaDescriptor);
device/bcm4713/etherOpen.c:    ethptr->rxTail = ethptr->rxRingSize;        // Producer goes to tail.
device/bcm4713/etherOpen.c:    nicptr->macControl |= MAC_CTRL_CRC32_ENAB;  /* enable crc32 */
device/bcm4713/etherOpen.c:    nicptr->rcvLazy = (1 << RCV_LAZY_FC_SHIFT); /* enable lazy Rx intr */
device/bcm4713/etherOpen.c:    etherControl(devptr, ETH_CTRL_SET_MAC, (long)ethptr->devAddress, 0);
device/bcm4713/etherOpen.c:    nicptr->rxMaxLength = ETH_HEADER_LEN + ETH_VLAN_LEN
device/bcm4713/etherOpen.c:        + ethptr->mtu + ETH_CRC_LEN;
device/bcm4713/etherOpen.c:    nicptr->txMaxLength = ETH_HEADER_LEN + ETH_VLAN_LEN
device/bcm4713/etherOpen.c:        + ethptr->mtu + ETH_CRC_LEN;
device/bcm4713/etherOpen.c:    nicptr->txWatermark = TX_WATERMARK;
device/bcm4713/etherOpen.c:    nicptr->enetControl |= ENET_CTRL_ENABLE;
device/bcm4713/etherOpen.c:    ethptr->state = ETH_STATE_UP;
device/bcm4713/etherOpen.c:    nicptr->interruptMask = ethptr->interruptMask;
device/bcm4713/etherRead.c:    ethptr = &ethertab[devptr->minor];
device/bcm4713/etherRead.c:    if (ETH_STATE_UP != ethptr->state)
device/bcm4713/etherRead.c:    wait(ethptr->isema);
device/bcm4713/etherRead.c:    pkt = ethptr->in[ethptr->istart];
device/bcm4713/etherRead.c:    ethptr->in[ethptr->istart] = NULL;
device/bcm4713/etherRead.c:    ethptr->istart = (ethptr->istart + 1) % ETH_IBLEN;
device/bcm4713/etherRead.c:    ethptr->icount--;
device/bcm4713/etherRead.c:    rh = (struct rxHeader *)pkt->buf;
device/bcm4713/etherRead.c:    lanptr = (struct vlanPkt *)pkt->data;
device/bcm4713/etherRead.c:    rh->length -= ETH_CRC_LEN;
device/bcm4713/etherRead.c:    if (ETH_TYPE_VLAN == net2hs(lanptr->tpi))
device/bcm4713/etherRead.c:        rh->length -= 4;        /* Account for vlan tag removal */
device/bcm4713/etherRead.c:    length = (rh->length < len) ? rh->length : len;
device/bcm4713/etherRead.c:    if (ETH_TYPE_VLAN == net2hs(lanptr->tpi))
device/bcm4713/etherRead.c:        memcpy(buffer, pkt->data, 12);
device/bcm4713/etherRead.c:        memcpy(buffer + 12, pkt->data + 16, length - 12);
device/bcm4713/etherRead.c:        memcpy(buffer, pkt->data, length);
device/bcm4713/etherStat.c:    nicptr = ethptr->csr;
device/bcm4713/etherStat.c:    printf("%s:\n", (ethptr->dev)->name);
device/bcm4713/etherStat.c:    control(ethptr->dev->num, ETH_CTRL_GET_MAC, (long)mac, 0);
device/bcm4713/etherStat.c:    if (ethptr->dev != ethptr->phy)
device/bcm4713/etherStat.c:    printf("  %8d MTU\n", ethptr->mtu);
device/bcm4713/etherStat.c:    tmp = ethptr->state;
device/bcm4713/etherStat.c:    printf("  RxErrors %lu           ", ethptr->rxErrors);
device/bcm4713/etherStat.c:    printf("  Errors %lu\n", ethptr->errors);
device/bcm4713/etherStat.c:    tmp = ethptr->interruptStatus;
device/bcm4713/etherStat.c:    tmp = ethptr->interruptMask;
device/bcm4713/etherStat.c:    printf("  Tx IRQ Count   %8lu", ethptr->txirq);
device/bcm4713/etherStat.c:    printf("  Tx Octets      %8u", nicptr->txGoodOctets);
device/bcm4713/etherStat.c:    printf("  Tx Packets     %8u\n", nicptr->txGoodPackets);
device/bcm4713/etherStat.c:    printf("  Tx < 65 octets %8u", nicptr->tx_64);
device/bcm4713/etherStat.c:    printf("  Tx < 128       %8u", nicptr->tx_65_127);
device/bcm4713/etherStat.c:    printf("  Tx < 256       %8u\n", nicptr->tx_128_255);
device/bcm4713/etherStat.c:    printf("  Tx < 512       %8u", nicptr->tx_256_511);
device/bcm4713/etherStat.c:    printf("  Tx < 1024      %8u", nicptr->tx_512_1023);
device/bcm4713/etherStat.c:    printf("  Tx >= 1024     %8u\n", nicptr->tx_1024_max);
device/bcm4713/etherStat.c:    printf("  Tx Broadcast   %8u", nicptr->txBroadcast);
device/bcm4713/etherStat.c:    printf("  Tx Multicast   %8u", nicptr->txMulticast);
device/bcm4713/etherStat.c:    printf("  Tx Jabber      %8u\n", nicptr->txJabber);
device/bcm4713/etherStat.c:    printf("  Tx Oversize    %8d", nicptr->txOversize);
device/bcm4713/etherStat.c:    printf("  Tx Fragment    %8u", nicptr->txFragment);
device/bcm4713/etherStat.c:    printf("  Tx Underruns   %8u\n", nicptr->txUnderruns);
device/bcm4713/etherStat.c:    printf("  Tx Collisions  %8u", nicptr->txCollisions);
device/bcm4713/etherStat.c:    printf("  Tx Status    0x%08X\n", nicptr->dmaTxStatus);
device/bcm4713/etherStat.c:    printf("  Rx IRQ Count   %8lu", ethptr->rxirq);
device/bcm4713/etherStat.c:    printf("  Rx Octets      %8u", nicptr->rxGoodOctets);
device/bcm4713/etherStat.c:    printf("  Rx Packets     %8u\n", nicptr->rxGoodPackets);
device/bcm4713/etherStat.c:    printf("  Rx < 65 octets %8u", nicptr->rx_64);
device/bcm4713/etherStat.c:    printf("  Rx < 128       %8u", nicptr->rx_65_127);
device/bcm4713/etherStat.c:    printf("  Rx < 256       %8u\n", nicptr->rx_128_255);
device/bcm4713/etherStat.c:    printf("  Rx < 512       %8u", nicptr->rx_256_511);
device/bcm4713/etherStat.c:    printf("  Rx < 1024      %8u", nicptr->rx_512_1023);
device/bcm4713/etherStat.c:    printf("  Rx >= 1024     %8u\n", nicptr->rx_1024_max);
device/bcm4713/etherStat.c:    printf("  Rx Broadcast   %8u", nicptr->rxBroadcast);
device/bcm4713/etherStat.c:    printf("  Rx Multicast   %8u", nicptr->rxMulticast);
device/bcm4713/etherStat.c:    printf("  Rx Jabber      %8u\n", nicptr->rxJabber);
device/bcm4713/etherStat.c:    printf("  Rx Oversize    %8u", nicptr->rxOversize);
device/bcm4713/etherStat.c:    printf("  Rx Fragment    %8u", nicptr->rxFragment);
device/bcm4713/etherStat.c:    printf("  Rx Missed      %8u\n", nicptr->rxMissed);
device/bcm4713/etherStat.c:    printf("  Rx CRC Align   %8u", nicptr->rxCrcAlign);
device/bcm4713/etherStat.c:    printf("  Rx Undersize   %8u", nicptr->rxUndersize);
device/bcm4713/etherStat.c:    printf("  Rx CRC Error   %8u\n", nicptr->rxCrc);
device/bcm4713/etherStat.c:    printf("  Rx Alignment   %8u", nicptr->rxAlign);
device/bcm4713/etherStat.c:    printf("  Rx Symbol Err  %8u", nicptr->rxSymbol);
device/bcm4713/etherStat.c:    printf("  Rx Pause       %8u\n", nicptr->rxPause);
device/bcm4713/etherStat.c:    printf("  Rx Non-Pause   %8u", nicptr->rxNonPause);
device/bcm4713/etherStat.c:    tmp = nicptr->dmaRxLast / sizeof(struct dmaDescriptor);
device/bcm4713/etherStat.c:    tmp = (nicptr->dmaRxStatus & DMARX_STAT_CDMASK)
device/bcm4713/etherStat.c:    nicptr = ethptr->csr;
device/bcm4713/etherStat.c:    if (ethptr->dev != ethptr->phy)
device/bcm4713/etherStat.c:        tx = nicptr->txGoodOctets;
device/bcm4713/etherStat.c:        rx = nicptr->rxGoodOctets;
device/bcm4713/etherStat.c:        printf("Tx: %4d bytes/sec, ", nicptr->txGoodOctets - tx);
device/bcm4713/etherStat.c:        printf("Rx: %4d bytes/sec\n", nicptr->rxGoodOctets - rx);
device/bcm4713/etherStat.c:    tmp = ethptr->state;
device/bcm4713/etherStat.c:    printf("  RxErrors %lu\n\n", ethptr->rxErrors);
device/bcm4713/etherWrite.c:    ethptr = &ethertab[devptr->minor];
device/bcm4713/etherWrite.c:    nicptr = ethptr->csr;
device/bcm4713/etherWrite.c:    if (ETH_STATE_UP != ethptr->state)
device/bcm4713/etherWrite.c:    phyptr = &ethertab[ethptr->phy->minor];
device/bcm4713/etherWrite.c:    if (ETH_STATE_UP != phyptr->state)
device/bcm4713/etherWrite.c:    if (len > (ETH_TX_BUF_SIZE - ETH_VLAN_LEN))
device/bcm4713/etherWrite.c:    pkt = (struct ethPktBuffer *)bufget(phyptr->outPool);
device/bcm4713/etherWrite.c:    pkt->buf = (uchar *)(pkt + 1);
device/bcm4713/etherWrite.c:    pkt->data = pkt->buf;
device/bcm4713/etherWrite.c:    lanptr = (struct vlanPkt *)pkt->data;
device/bcm4713/etherWrite.c:    memcpy(pkt->data, buffer, 12);
device/bcm4713/etherWrite.c:    lanptr->tpi = hs2net(ETH_TYPE_VLAN);
device/bcm4713/etherWrite.c:    lanptr->vlanId = hs2net(devptr->minor);
device/bcm4713/etherWrite.c:    memcpy(pkt->data + 16, buffer + 12, outlen - 12);
device/bcm4713/etherWrite.c:    pkt->length = outlen;
device/bcm4713/etherWrite.c:    entry = phyptr->txTail;
device/bcm4713/etherWrite.c:    phyptr->txBufs[entry] = pkt;
device/bcm4713/etherWrite.c:    if (phyptr->txRingSize - 1 == entry)
device/bcm4713/etherWrite.c:    phyptr->txRing[entry].control = control;
device/bcm4713/etherWrite.c:    phyptr->txRing[entry].address = (ulong)pkt->data & PMEM_MASK;
device/bcm4713/etherWrite.c:    phyptr->txTail = (entry + 1) % phyptr->txRingSize;
device/bcm4713/etherWrite.c:    entry = phyptr->txTail;
device/bcm4713/etherWrite.c:    nicptr->dmaTxLast = entry * sizeof(struct dmaDescriptor);
device/bcm4713/switchInit.c:    swtregs.page = -1;
device/bcm4713/switchInit.c:    mdio = (struct mdioregs *)&nicptr->mdioControl;
device/bcm4713/switchInit.c:    for (port = 0; port < (SWT_PORTS - NETHER); port++)
device/bcm4713/switchInit.c:    for (port = (SWT_PORTS - NETHER); port < SWT_CPUPORT; port++)
device/bcm4713/switchInit.c:    mdio->emacIntstatus = EI_MII;
device/bcm4713/switchInit.c:    mdio->mdioData =
device/bcm4713/switchInit.c:    waitOnBit((uint *)&mdio->emacIntstatus, EI_MII, 1, 100);
device/bcm4713/switchInit.c:    return (mdio->mdioData & MD_DATA_MASK);
device/bcm4713/switchInit.c:    mdio->emacIntstatus = EI_MII;
device/bcm4713/switchInit.c:    mdio->mdioData =
device/bcm4713/switchInit.c:    waitOnBit((uint *)&mdio->emacIntstatus, EI_MII, 1, 100);
device/bcm4713/switchInit.c:    /* write data - MII register 0x18-0x1B */
device/bcm4713/switchInit.c:    /* set register address - MII register 0x11 */
device/bcm4713/switchInit.c:    for (i = MII_MAX_RETRY; i > 0; i--)
device/bcm4713/switchInit.c:    /* set register address - MII register 0x11 */
device/bcm4713/switchInit.c:    for (i = MII_MAX_RETRY; i > 0; i--)
device/bcm4713/switchInit.c:    /* read data - MII register 0x18-0x1B */
device/bcm4713/vlanClose.c:    ethptr = &ethertab[devptr->minor];
device/bcm4713/vlanClose.c:    ethptr->state = ETH_STATE_DOWN;
device/bcm4713/vlanInit.c:    ethptr = &ethertab[devptr->minor];
device/bcm4713/vlanInit.c:    ethptr->dev = devptr;
device/bcm4713/vlanInit.c:    ethptr->csr = (struct bcm4713 *)devptr->csr;
device/bcm4713/vlanInit.c:    ethptr->phy = (device *)&devtab[ETH0];
device/bcm4713/vlanInit.c:    ethptr->errors = 0;
device/bcm4713/vlanInit.c:    ethptr->state = ETH_STATE_DOWN;
device/bcm4713/vlanInit.c:    ethptr->rxRingSize = ETH_RX_RING_ENTRIES;
device/bcm4713/vlanInit.c:    ethptr->txRingSize = ETH_TX_RING_ENTRIES;
device/bcm4713/vlanInit.c:    ethptr->mtu = ETH_MTU;
device/bcm4713/vlanInit.c:    ethptr->isema = semcreate(0);
device/bcm4713/vlanInit.c:    ethptr->istart = 0;
device/bcm4713/vlanInit.c:    ethptr->icount = 0;
device/bcm4713/vlanInit.c:    ethptr->ovrrun = 0;
device/bcm4713/vlanInit.c:    ethptr->rxOffset = sizeof(struct rxHeader);
device/bcm4713/vlanInit.c:    colon2mac(nvramGet("et0macaddr"), ethptr->devAddress);
device/bcm4713/vlanInit.c:    ethptr->devAddress[0] |= ((uchar)devptr->minor << 2) | ETH_LOCAL_MAC;
device/bcm4713/vlanInit.c:    ethptr->interruptMask = IMASK_DEF;
device/bcm4713/vlanInit.c:    ethptr->rxBufs = (struct ethPktBuffer **)ETH_INVALID;
device/bcm4713/vlanInit.c:    ethptr->txBufs = (struct ethPktBuffer **)ETH_INVALID;
device/bcm4713/vlanInit.c:    ethptr->rxRing = (struct dmaDescriptor *)ETH_INVALID;
device/bcm4713/vlanInit.c:    ethptr->txRing = (struct dmaDescriptor *)ETH_INVALID;
device/bcm4713/vlanOpen.c:    ethptr = &ethertab[devptr->minor];
device/bcm4713/vlanOpen.c:    ethptr->inPool = ETH_INVALID;
device/bcm4713/vlanOpen.c:    ethptr->outPool = ETH_INVALID;
device/bcm4713/vlanOpen.c:    ethptr->state = ETH_STATE_UP;
device/bcm4713/vlanOpen.c:    etherControl(devptr, ETH_CTRL_SET_MAC, (ulong)ethptr->devAddress, 0);
device/bcm4713/waitOnBit.c:         * - if expected value is non-zero, check if the register & mask has
device/bcm4713/waitOnBit.c:         *   a non-zero value
device/bcm4713/waitOnBit.c:         * - if expected value is zero, check if the register & mask has
device/bcm4713/waitOnBit.c:        for (j = 100; j; j--)
device/bcmbus/backplaneCoreDisable.c:#define	SBTML_FL_MASK		0x3ffc0000      /* core-specific flags */
device/bcmbus/backplaneCoreDisable.c:    if (bpConfig->tmStateLow & SBTML_RESET)
device/bcmbus/backplaneCoreDisable.c:    bpConfig->tmStateLow = (SBTML_REJ | SBTML_CLK);
device/bcmbus/backplaneCoreDisable.c:    waitOnBit(&bpConfig->tmStateLow, SBTML_REJ, 1, 100000);
device/bcmbus/backplaneCoreDisable.c:    waitOnBit(&bpConfig->tmStateHigh, SBTMH_BUSY, 0, 100000);
device/bcmbus/backplaneCoreDisable.c:    bpConfig->tmStateLow =
device/bcmbus/backplaneCoreDisable.c:    bpConfig->tmStateLow;
device/bcmbus/backplaneCoreDisable.c:    for (i = 100; i; i--)
device/bcmbus/backplaneCoreDisable.c:    bpConfig->tmStateLow = (SBTML_REJ | SBTML_RESET);
device/bcmbus/backplaneCoreDisable.c:    bpConfig->tmStateLow;
device/bcmbus/backplaneCoreDisable.c:    for (i = 100; i; i--)
device/bcmbus/backplaneCoreReset.c:    bpConfig->tmStateLow = (SBTML_RESET | SBTML_CLK | SBTML_FGC);
device/bcmbus/backplaneCoreReset.c:    bpConfig->tmStateLow;
device/bcmbus/backplaneCoreReset.c:    for (i = 10; i; i--)
device/bcmbus/backplaneCoreReset.c:    if (bpConfig->tmStateHigh & SBTMH_SERR)
device/bcmbus/backplaneCoreReset.c:        bpConfig->tmStateHigh = 0;
device/bcmbus/backplaneCoreReset.c:    i = bpConfig->imState;
device/bcmbus/backplaneCoreReset.c:        bpConfig->imState = i & ~(SBIM_IBE | SBIM_TO);
device/bcmbus/backplaneCoreReset.c:    bpConfig->tmStateLow = (SBTML_CLK | SBTML_FGC);
device/bcmbus/backplaneCoreReset.c:    bpConfig->tmStateLow;
device/bcmbus/backplaneCoreReset.c:    for (i = 10; i; i--)
device/bcmbus/backplaneCoreReset.c:    bpConfig->tmStateLow = SBTML_CLK;
device/bcmbus/backplaneCoreReset.c:    bpConfig->tmStateLow;
device/bcmbus/backplaneCoreReset.c:    for (i = 10; i; i--)
device/bcmbus/backplaneCoreUp.c:            (bpConfig->tmStateLow &
device/bcmbus/backplaneInit.c: * @param devptr pointer to an sb-bus device
device/bcmbus/backplaneInit.c:    numcores = (sbCore->chipid & CID_CC_MASK) >> CID_CC_SHIFT;
device/bcmbus/backplaneInit.c:         sbCore->chipid & CID_ID_MASK,
device/bcmbus/backplaneInit.c:         (sbCore->chipid & CID_REV_MASK) >> CID_REV_SHIFT, numcores);
device/ethloop/ethloopClose.c:    elpptr = &elooptab[devptr->minor];
device/ethloop/ethloopClose.c:    if (ELOOP_STATE_ALLOC != elpptr->state)
device/ethloop/ethloopClose.c:    semfree(elpptr->sem);
device/ethloop/ethloopClose.c:    semfree(elpptr->hsem);
device/ethloop/ethloopClose.c:    bfpfree(elpptr->poolid);
device/ethloop/ethloopClose.c:    elpptr->dev = NULL;
device/ethloop/ethloopClose.c:    elpptr->state = ELOOP_STATE_FREE;
device/ethloop/ethloopControl.c:    elpptr = &elooptab[devptr->minor];
device/ethloop/ethloopControl.c:    if (ELOOP_STATE_ALLOC != elpptr->state)
device/ethloop/ethloopControl.c:        addr->type = NETADDR_ETHERNET;
device/ethloop/ethloopControl.c:        addr->len = ETH_ADDR_LEN;
device/ethloop/ethloopControl.c:        addr->addr[0] = 0xAA;
device/ethloop/ethloopControl.c:        addr->addr[1] = 0xBB;
device/ethloop/ethloopControl.c:        addr->addr[2] = 0xCC;
device/ethloop/ethloopControl.c:        addr->addr[3] = 0xDD;
device/ethloop/ethloopControl.c:        addr->addr[4] = 0xEE;
device/ethloop/ethloopControl.c:        addr->addr[5] = 0xFF;
device/ethloop/ethloopControl.c:        addr->type = NETADDR_ETHERNET;
device/ethloop/ethloopControl.c:        addr->len = ETH_ADDR_LEN;
device/ethloop/ethloopControl.c:        addr->addr[0] = 0xFF;
device/ethloop/ethloopControl.c:        addr->addr[1] = 0xFF;
device/ethloop/ethloopControl.c:        addr->addr[2] = 0xFF;
device/ethloop/ethloopControl.c:        addr->addr[3] = 0xFF;
device/ethloop/ethloopControl.c:        addr->addr[4] = 0xFF;
device/ethloop/ethloopControl.c:        addr->addr[5] = 0xFF;
device/ethloop/ethloopControl.c:        wait(elpptr->hsem);
device/ethloop/ethloopControl.c:        hold = elpptr->hold;
device/ethloop/ethloopControl.c:        holdlen = elpptr->holdlen;
device/ethloop/ethloopControl.c:        elpptr->hold = NULL;
device/ethloop/ethloopControl.c:        elpptr->holdlen = 0;
device/ethloop/ethloopControl.c:        old = elpptr->flags & arg1;
device/ethloop/ethloopControl.c:        elpptr->flags |= (arg1);
device/ethloop/ethloopControl.c:        old = elpptr->flags & arg1;
device/ethloop/ethloopControl.c:        elpptr->flags &= ~(arg1);
device/ethloop/ethloopInit.c:    elpptr = &elooptab[devptr->minor];
device/ethloop/ethloopInit.c:    elpptr->state = ELOOP_STATE_FREE;
device/ethloop/ethloopOpen.c:    elpptr = &elooptab[devptr->minor];
device/ethloop/ethloopOpen.c:    if (ELOOP_STATE_FREE != elpptr->state)
device/ethloop/ethloopOpen.c:    elpptr->flags = 0;
device/ethloop/ethloopOpen.c:    elpptr->nout = 0;
device/ethloop/ethloopOpen.c:    elpptr->sem = semcreate(0);
device/ethloop/ethloopOpen.c:    if (SYSERR == (int)elpptr->sem)
device/ethloop/ethloopOpen.c:    elpptr->hsem = semcreate(0);
device/ethloop/ethloopOpen.c:    if (SYSERR == (int)elpptr->hsem)
device/ethloop/ethloopOpen.c:    bzero(elpptr->buffer, sizeof(elpptr->buffer));
device/ethloop/ethloopOpen.c:    bzero(elpptr->pktlen, sizeof(elpptr->pktlen));
device/ethloop/ethloopOpen.c:    elpptr->index = 0;
device/ethloop/ethloopOpen.c:    elpptr->hold = NULL;
device/ethloop/ethloopOpen.c:    elpptr->holdlen = 0;
device/ethloop/ethloopOpen.c:    elpptr->count = 0;
device/ethloop/ethloopOpen.c:    elpptr->poolid = bfpalloc(ELOOP_BUFSIZE, ELOOP_NBUF);
device/ethloop/ethloopOpen.c:    if (SYSERR == elpptr->poolid)
device/ethloop/ethloopOpen.c:    elpptr->state = ELOOP_STATE_ALLOC;
device/ethloop/ethloopOpen.c:    elpptr->dev = devptr;
device/ethloop/ethloopOpen.c:    semfree(elpptr->hsem);
device/ethloop/ethloopOpen.c:    semfree(elpptr->sem);
device/ethloop/ethloopRead.c:    elpptr = &elooptab[devptr->minor];
device/ethloop/ethloopRead.c:    if (ELOOP_STATE_ALLOC != elpptr->state)
device/ethloop/ethloopRead.c:    wait(elpptr->sem);
device/ethloop/ethloopRead.c:    pkt = elpptr->buffer[elpptr->index];
device/ethloop/ethloopRead.c:    pktlen = elpptr->pktlen[elpptr->index];
device/ethloop/ethloopRead.c:    elpptr->buffer[elpptr->index] = NULL;
device/ethloop/ethloopRead.c:    elpptr->pktlen[elpptr->index] = 0;
device/ethloop/ethloopRead.c:    elpptr->count--;
device/ethloop/ethloopRead.c:    elpptr->index = (elpptr->index + 1) % ELOOP_NBUF;
device/ethloop/ethloopWrite.c:    elpptr = &elooptab[devptr->minor];
device/ethloop/ethloopWrite.c:    if (ELOOP_STATE_ALLOC != elpptr->state)
device/ethloop/ethloopWrite.c:    if (elpptr->flags & (ELOOP_FLAG_DROPNXT | ELOOP_FLAG_DROPALL))
device/ethloop/ethloopWrite.c:        elpptr->flags &= ~ELOOP_FLAG_DROPNXT;
device/ethloop/ethloopWrite.c:    pkt = (char *)bufget(elpptr->poolid);
device/ethloop/ethloopWrite.c:    if (elpptr->flags & ELOOP_FLAG_HOLDNXT)
device/ethloop/ethloopWrite.c:        elpptr->flags &= ~ELOOP_FLAG_HOLDNXT;
device/ethloop/ethloopWrite.c:        if (elpptr->hold != NULL)
device/ethloop/ethloopWrite.c:            buffree(elpptr->hold);
device/ethloop/ethloopWrite.c:        elpptr->hold = pkt;
device/ethloop/ethloopWrite.c:        elpptr->holdlen = len;
device/ethloop/ethloopWrite.c:        signal(elpptr->hsem);
device/ethloop/ethloopWrite.c:    if (elpptr->count >= ELOOP_NBUF)
device/ethloop/ethloopWrite.c:    index = (elpptr->count + elpptr->index) % ELOOP_NBUF;
device/ethloop/ethloopWrite.c:    elpptr->buffer[index] = pkt;
device/ethloop/ethloopWrite.c:    elpptr->pktlen[index] = len;
device/ethloop/ethloopWrite.c:    elpptr->count++;
device/ethloop/ethloopWrite.c:    elpptr->nout++;
device/ethloop/ethloopWrite.c:    signal(elpptr->sem);
device/flash/flashClose.c:    flash = &flashtab[devptr->minor];
device/flash/flashClose.c:        block = flash->erase_blocks[n];
device/flash/flashClose.c:        flash->erase_blocks[n] = block;
device/flash/flashClose.c:    signal(flash->lock);
device/flash/flashControl.c:    flash = &flashtab[devptr->minor];
device/flash/flashControl.c:        return flash->log_size;
device/flash/flashControl.c:        v = flash->nlog_blocks;
device/flash/flashControl.c:        v -= (CFE_MAX_BLOCK - CFE_MIN_BLOCK);
device/flash/flashControl.c:        v -= (KERNEL_MAX_BLOCK - KERNEL_MIN_BLOCK);
device/flash/flashControl.c:        v -= (NVRAM_MAX_BLOCK - NVRAM_MIN_BLOCK);
device/flash/flashControl.c:        /* Force synchronization of erase-blocks in RAM and on Flash */
device/flash/flashControl.c:                v = (flash->curr_block + n) % MAX_LIVE_BLOCKS;
device/flash/flashControl.c:                if (l_block.start_pos == flash->erase_blocks[v].start_pos)
device/flash/flashControl.c:                                         &(flash->erase_blocks[v]));
device/flash/flashControl.c:                e_block = &(flash->erase_blocks[n]);
device/flash/flashInit.c:    flash = &flashtab[devptr->minor];
device/flash/flashInit.c:    flash->device = devptr;
device/flash/flashInit.c:    flash->base = (ulong)devptr->csr;
device/flash/flashInit.c:    flash->lock = semcreate(1);
device/flash/flashInit.c:    CFI_PUT_8(flash->base, CFI_QUERY_ADDR, CFI_QUERY_MODE);
device/flash/flashInit.c:    if (!(CFI_GET_8(flash->base, CFI_SIGNATURE + 0) == 'Q'
device/flash/flashInit.c:          && CFI_GET_8(flash->base, CFI_SIGNATURE + 1) == 'R'
device/flash/flashInit.c:          && CFI_GET_8(flash->base, CFI_SIGNATURE + 2) == 'Y'))
device/flash/flashInit.c:        CFI_PUT_8(flash->base, CFI_QUERY_ADDR, CFI_QUERY_EXIT);
device/flash/flashInit.c:    flash->commands = CFI_GET_8(flash->base, CFI_COMMAND_SET);
device/flash/flashInit.c:    if (!(flash->commands == FLASH_INTEL_SCS
device/flash/flashInit.c:          || flash->commands == FLASH_AMD_SCS))
device/flash/flashInit.c:        CFI_PUT_8(flash->base, CFI_QUERY_ADDR, CFI_QUERY_EXIT);
device/flash/flashInit.c:    flash->size = 1 << CFI_GET_8(flash->base, CFI_DEV_SIZE);
device/flash/flashInit.c:    /* number of erase-block regions */
device/flash/flashInit.c:    flash->nregions = CFI_GET_8(flash->base, CFI_REGION_COUNT);
device/flash/flashInit.c:    if (flash->nregions >= MAX_REGIONS)
device/flash/flashInit.c:        CFI_PUT_8(flash->base, CFI_QUERY_ADDR, CFI_QUERY_EXIT);
device/flash/flashInit.c:    for (n = 0; n < flash->nregions; n++)
device/flash/flashInit.c:        r = flash->regions[n];
device/flash/flashInit.c:        /* number of erase-blocks in region */
device/flash/flashInit.c:        r.nblocks = 1 + CFI_GET_8(flash->base, CFI_REGION_TAB + n * 4 + 0)
device/flash/flashInit.c:            + (CFI_GET_8(flash->base, CFI_REGION_TAB + n * 4 + 1) << 8);
device/flash/flashInit.c:        /* size of erase-blocks within region */
device/flash/flashInit.c:        r.block_size = (CFI_GET_8(flash->base, CFI_REGION_TAB + n * 4 + 2)
device/flash/flashInit.c:                         (flash->base, CFI_REGION_TAB + n * 4 + 3) << 8));
device/flash/flashInit.c:        flash->regions[n] = r;
device/flash/flashInit.c:    if (position != flash->size)
device/flash/flashInit.c:        CFI_PUT_8(flash->base, CFI_QUERY_ADDR, CFI_QUERY_EXIT);
device/flash/flashInit.c:    flash->log_size = FLASH_BLK_SIZE;
device/flash/flashInit.c:    flash->nlog_blocks = flash->size / flash->log_size;
device/flash/flashInit.c:    CFI_PUT_8(flash->base, CFI_QUERY_ADDR, CFI_QUERY_EXIT);
device/flash/flashInit.c:    flash->mode = INTEL_READ;
device/flash/flashInit.c:    kprintf("Found CFI (Flash) device at 0x%08x\r\n", flash->base);
device/flash/flashInit.c:    kprintf("  Using 0x%04x command set\r\n", flash->commands);
device/flash/flashInit.c:            flash->size, flash->nlog_blocks, flash->log_size);
device/flash/flashInit.c:    kprintf("  Physically split into %d erase-regions\r\n",
device/flash/flashInit.c:            flash->nregions);
device/flash/flashInit.c:    for (n = 0; n < flash->nregions; n++)
device/flash/flashInit.c:        r = flash->regions[n];
device/flash/flashOpen.c:    flash = &flashtab[devptr->minor];
device/flash/flashOpen.c:    wait(flash->lock);
device/flash/flashOpen.c:        block = flash->erase_blocks[n];
device/flash/flashOpen.c:        flash->erase_blocks[n] = block;
device/flash/flashOpen.c:    //superblockOpen(dptr->num);
device/flash/flashRead.c: * A simple, high-level interface to read from flash.
device/flash/flashRead.c: * @param *buffer buffer to store contents into (should be flash->log_size)
device/flash/flashRead.c:    flash = &flashtab[devptr->minor];
device/flash/flashRead.c:    if (!(0 <= block && block < flash->nlog_blocks))
device/flash/flashRead.c:    wait(flash->lock);
device/flash/flashRead.c:    signal(flash->lock);
device/flash/flashWrite.c: * A simple, high-level interface to write to flash.
device/flash/flashWrite.c: * @param *buffer buffer holding content to write (should be flash->log_size)
device/flash/flashWrite.c:    flash = &flashtab[devptr->minor];
device/flash/flashWrite.c:    if (!(0 <= block && block < flash->nlog_blocks))
device/flash/flashWrite.c:    wait(flash->lock);
device/flash/flashWrite.c:    signal(flash->lock);
device/flash/logical.c: * buffer. This will check if the erase-block is already in memory and if
device/flash/logical.c: * store an erase-block it will automatically write to the oldest
device/flash/logical.c: * erase-block to flash and read in the requested block.
device/flash/logical.c:        pos = (flash->curr_block + n) % MAX_LIVE_BLOCKS;
device/flash/logical.c:        test_block = flash->erase_blocks[pos];
device/flash/logical.c:        physicalWrite(flash, &(flash->erase_blocks[flash->curr_block]));
device/flash/logical.c:    block = block * flash->log_size;
device/flash/logical.c:    /* make block an offset into the erase-block */
device/flash/logical.c:    block -= new_block.start_pos;
device/flash/logical.c:    memcpy(buffer, new_block.buffer + block, flash->log_size);
device/flash/logical.c:    return flash->log_size;
device/flash/logical.c: * write the data. This function will check if the erase-block is in memory
device/flash/logical.c: * flash. If no more room is available it will evict the oldest erase-block
device/flash/logical.c:        pos = (flash->curr_block + n) % MAX_LIVE_BLOCKS;
device/flash/logical.c:        test_block = flash->erase_blocks[pos];
device/flash/logical.c:        physicalWrite(flash, &(flash->erase_blocks[flash->curr_block]));
device/flash/logical.c:        flash->erase_blocks[pos] = new_block;
device/flash/logical.c:    block = block * flash->log_size;
device/flash/logical.c:    /* make block an offset into the erase-block */
device/flash/logical.c:    block -= new_block.start_pos;
device/flash/logical.c:    memcpy(new_block.buffer + block, buffer, flash->log_size);
device/flash/logical.c:    return flash->log_size;
device/flash/logical.c: * discover the physical erase-block (and region) of that block.
device/flash/logical.c: * flash_block structure with the region and erase-block filled in.
device/flash/logical.c:    while (e_region < flash->nregions)
device/flash/logical.c:        f_region = flash->regions[e_region];
device/flash/logical.c:        if ((position / flash->log_size) > block)
device/flash/logical.c:    if (e_region >= flash->nregions)
device/flash/logical.c:    position -= f_region.region_size;
device/flash/logical.c:        /* skipping this erase-block is too far */
device/flash/logical.c:        if ((position / flash->log_size) > block)
device/flash/logical.c:    f_block.start_pos = position - f_region.block_size;
device/flash/nvram.c:    if (nvram_header != NULL && NVRAM_MAGIC == nvram_header->magic)
device/flash/nvram.c:    flash = &flashtab[devptr->minor];
device/flash/nvram.c:    nvbase = flash->base + flash->size - NVRAM_SIZE;
device/flash/nvram.c:    while (nvbase > flash->base)
device/flash/nvram.c:        nvbase -= NVRAM_SIZE;
device/flash/nvram.c:    if (nvram_header->magic != NVRAM_MAGIC)
device/flash/nvram.c:    nvram_length = nvram_header->length;
device/flash/nvram.c:    nvram_header->length = sizeof(struct nvram_header);
device/flash/nvram.c:        pair_len = strnlen(pair, nvram_length - offset);
device/flash/nvram.c:        memcpy(tuple->pair, pair, pair_len);
device/flash/nvram.c:        memcpy(tuple->pair + pair_len, "\0", 1);
device/flash/nvram.c:    index = nvramHash(tuple->pair);
device/flash/nvram.c:    while (curr != NULL && curr->next != NULL)
device/flash/nvram.c:        curr = curr->next;
device/flash/nvram.c:        curr->next = NULL;
device/flash/nvram.c:        curr->next = tuple;
device/flash/nvram.c:        tuple->next = NULL;
device/flash/nvram.c:    nvram_header->length += (strnlen(tuple->pair, NVRAM_STRMAX) + 1);
device/flash/nvram.c:           (strncmp(name, tuple->pair, strnlen(name, NVRAM_STRMAX)) != 0))
device/flash/nvram.c:        tuple = tuple->next;
device/flash/nvram.c:    return tuple->pair + strnlen(name, NVRAM_STRMAX) + 1;
device/flash/nvram.c:    strncpy(tuple->pair, name, strnlen(name, NVRAM_STRMAX));
device/flash/nvram.c:    strncpy(tuple->pair + offset, "=", 1);
device/flash/nvram.c:    strncpy(tuple->pair + offset, value, strnlen(value, NVRAM_STRMAX));
device/flash/nvram.c:    strncpy(tuple->pair + offset, "\0", 1);
device/flash/nvram.c:           strncmp(tuple->pair, name, strnlen(name, NVRAM_STRMAX)))
device/flash/nvram.c:        tuple = tuple->next;
device/flash/nvram.c:        nvram_tuples[index] = tuple->next;
device/flash/nvram.c:        prev->next = tuple->next;
device/flash/nvram.c:    length = strnlen(tuple->pair, NVRAM_STRMAX) + 1;
device/flash/nvram.c:    nvram_header->length -= length;
device/flash/nvram.c:    flash = &flashtab[devptr->minor];
device/flash/nvram.c:    nvram_header->length = (nvram_header->length + 2 + 3) & ~0x03;
device/flash/nvram.c:    buffer = (uchar *)memget(nvram_header->length);
device/flash/nvram.c:    bzero(buffer, nvram_header->length);
device/flash/nvram.c:    nvram_header->crc_ver_init &= ~NVRAM_CRC_MASK;
device/flash/nvram.c:            memcpy(buffer + offset, tuple->pair,
device/flash/nvram.c:                   strnlen(tuple->pair, NVRAM_STRMAX));
device/flash/nvram.c:            /* next position + 1 for null-terminiation */
device/flash/nvram.c:            offset += strnlen(tuple->pair, NVRAM_STRMAX) + 1;
device/flash/nvram.c:        while ((tuple = tuple->next) != NULL);
device/flash/nvram.c:    nvram_header->crc_ver_init |= ((uchar)nvramCrc(buffer));
device/flash/nvram.c:        pos = (flash->curr_block + n) % MAX_LIVE_BLOCKS;
device/flash/nvram.c:        test_block = flash->erase_blocks[pos];
device/flash/nvram.c:        physicalWrite(flash, &(flash->erase_blocks[flash->curr_block]));
device/flash/nvram.c:    offset = block.size - NVRAM_SIZE;
device/flash/nvram.c:    memcpy(block.buffer + offset, buffer, nvram_header->length);
device/flash/nvram.c:    memfree((void *)buffer, nvram_header->length);
device/flash/nvram.c:    for (offset = 9; offset < nvram_header->length; offset++)
device/flash/nvram.c: * NVRAM_NHASH-1 (inclusive).
device/flash/physical.c:    switch (flash->commands)
device/flash/physical.c:                flash->commands);
device/flash/physical.c:    switch (flash->commands)
device/flash/physical.c:                flash->commands);
device/flash/physical.c: * Erase an erase-block from Flash memory. Flash memory can only change
device/flash/physical.c:    switch (flash->commands)
device/flash/physical.c:                flash->commands);
device/flash/physical.c:    switch (flash->commands)
device/flash/physical.c:                flash->commands);
device/flash/physicalAMD.c:    position = flash->base | block->start_pos;
device/flash/physicalAMD.c:    size = block->size;
device/flash/physicalAMD.c:    if (FLASH_BLOCK_FREE == block->state)
device/flash/physicalAMD.c:        block->state = FLASH_BLOCK_CLEAN;
device/flash/physicalAMD.c:    block->buffer = buffer;
device/flash/physicalAMD.c:    flash->erase_blocks[flash->curr_block] = *block;
device/flash/physicalAMD.c:    flash->curr_block = (flash->curr_block + 1) % MAX_LIVE_BLOCKS;
device/flash/physicalIntel.c:    position = flash->base | block->start_pos;
device/flash/physicalIntel.c:    size = block->size;
device/flash/physicalIntel.c:    if (FLASH_BLOCK_FREE == block->state)
device/flash/physicalIntel.c:        block->state = FLASH_BLOCK_CLEAN;
device/flash/physicalIntel.c:    block->buffer = buffer;
device/flash/physicalIntel.c:    flash->erase_blocks[flash->curr_block] = *block;
device/flash/physicalIntel.c:    flash->curr_block = (flash->curr_block + 1) % MAX_LIVE_BLOCKS;
device/flash/physicalIntel.c:    if (FLASH_BLOCK_FREE == block->state)
device/flash/physicalIntel.c:    /* not in CFE-land */
device/flash/physicalIntel.c:    if (!(block->start_pos > ((CFE_MAX_BLOCK + 1) * FLASH_BLK_SIZE) - 1))
device/flash/physicalIntel.c:    if (FLASH_BLOCK_CLEAN == block->state)
device/flash/physicalIntel.c:        return block->size;
device/flash/physicalIntel.c:    /* change erase-block to all 0xff (erase erase-block) */
device/flash/physicalIntel.c:    buffer = (uchar *)block->buffer;
device/flash/physicalIntel.c:    position = flash->base | block->start_pos;
device/flash/physicalIntel.c:    for (count = 0; count < block->size; count += 2)
device/flash/physicalIntel.c:        /* convert 2-bytes to a word to write */
device/flash/physicalIntel.c:    /* if it was locked, re-lock it */
device/flash/physicalIntel.c:    block->state = FLASH_BLOCK_CLEAN;
device/flash/physicalIntel.c: * Erase an erase-block from Flash memory. Flash memory can only change
device/flash/physicalIntel.c:    ulong position = flash->base | block->start_pos;
device/flash/physicalIntel.c:        if (flash->mode == arg)
device/flash/physicalIntel.c:        flash->mode = arg;
device/flash/physicalIntel.c:        /* Move the erase-block to an unlocked state */
device/flash/physicalIntel.c:        /* Move the erase-block to an locked state */
device/flash/validateTrx.c:    header = (struct trx_header *)checkme->data;
device/flash/validateTrx.c:    magic = header->magic;
device/flash/validateTrx.c:    len = header->len;
device/flash/validateTrx.c:    crc = header->crc;
device/flash/validateTrx.c:    if (len != checkme->len)
device/flash/validateTrx.c:                "\tlen found: %d\tlen expected: %d\n", len, checkme->len);
device/flash/validateTrx.c:        calc_crc = crc32buf((char *)(&header->flags_vers),
device/flash/validateTrx.c:                            len - 3 * sizeof(int));
device/flash/validateTrx.c:    for (; len; len--, buf++)
device/framebuffer_rpi/drawShapes.c:		deltax = x2 - x1;
device/framebuffer_rpi/drawShapes.c:		deltax = x1 - x2;
device/framebuffer_rpi/drawShapes.c:		stepx = -1;
device/framebuffer_rpi/drawShapes.c:		deltay = y2 - y1;
device/framebuffer_rpi/drawShapes.c:		deltay = y1 - y2;
device/framebuffer_rpi/drawShapes.c:		stepy = -1;
device/framebuffer_rpi/drawShapes.c:	error = deltax - deltay;
device/framebuffer_rpi/drawShapes.c:		if (error * 2 >= -1 * deltay) {
device/framebuffer_rpi/drawShapes.c:			error = error - deltay;
device/framebuffer_rpi/drawShapes.c:    int maxy = DEFAULT_HEIGHT - (CHAR_HEIGHT * MINISHELLMINROW) - 1;
device/framebuffer_rpi/drawShapes.c:		deltax = x2 - x1;
device/framebuffer_rpi/drawShapes.c:		deltax = x1 - x2;
device/framebuffer_rpi/drawShapes.c:		stepx = -1;
device/framebuffer_rpi/drawShapes.c:		deltay = y2 - y1;
device/framebuffer_rpi/drawShapes.c:		deltay = y1 - y2;
device/framebuffer_rpi/drawShapes.c:		stepy = -1;
device/framebuffer_rpi/drawShapes.c:	error = deltax - deltay;
device/framebuffer_rpi/drawShapes.c:		if (error * 2 >= -1 * deltay) {
device/framebuffer_rpi/drawShapes.c:			error = error - deltay;
device/framebuffer_rpi/drawShapes.c:	if ( (x2 - x1) > (y2 - y1) )
device/framebuffer_rpi/drawShapes.c:		iterations = (x2 - x1) / 2;
device/framebuffer_rpi/drawShapes.c:	else iterations = (y2 - y1) / 2;
device/framebuffer_rpi/drawShapes.c:		drawRect(x1 + iterations, y1 + iterations, x2 - iterations, y2 - iterations, color);
device/framebuffer_rpi/drawShapes.c:		iterations--;
device/framebuffer_rpi/drawShapes.c:  	int radiusError = 1 - x;
device/framebuffer_rpi/drawShapes.c:    	drawPixel(-x + x0, y + y0, color);
device/framebuffer_rpi/drawShapes.c:    	drawPixel(-y + x0, x + y0, color);
device/framebuffer_rpi/drawShapes.c:    	drawPixel(-x + x0, -y + y0, color);
device/framebuffer_rpi/drawShapes.c:    	drawPixel(-y + x0, -x + y0, color);
device/framebuffer_rpi/drawShapes.c:    	drawPixel(x + x0, -y + y0, color);
device/framebuffer_rpi/drawShapes.c:    	drawPixel(y + x0, -x + y0, color);
device/framebuffer_rpi/drawShapes.c:           	x--;
device/framebuffer_rpi/drawShapes.c:           	radiusError += 2 * (y - x + 1);
device/framebuffer_rpi/drawShapes.c:		rad--;
device/framebuffer_rpi/drawShapes.c:  	int radiusError = 1 - x;
device/framebuffer_rpi/drawShapes.c:    //the maximum y-value we can have so that we don't draw any part of turtle in the minishell area
device/framebuffer_rpi/drawShapes.c:    int maxy = DEFAULT_HEIGHT - (MINISHELLMINROW * CHAR_HEIGHT) - BODY_RADIUS - (HEAD_RADIUS * 2);
device/framebuffer_rpi/drawShapes.c:        		drawPixel(-x + x0, y + y0, linemap[(y+y0) * DEFAULT_WIDTH + (-x+x0)] );
device/framebuffer_rpi/drawShapes.c:        		drawPixel(-y + x0, x + y0, linemap[(x+y0) * DEFAULT_WIDTH + (-y+x0)] );
device/framebuffer_rpi/drawShapes.c:        		drawPixel(-x + x0, -y + y0, linemap[(-y+y0) * DEFAULT_WIDTH + (-x+x0)] );
device/framebuffer_rpi/drawShapes.c:        		drawPixel(-y + x0, -x + y0, linemap[(-x+y0) * DEFAULT_WIDTH + (-y+x0)] );
device/framebuffer_rpi/drawShapes.c:        		drawPixel(x + x0, -y + y0, linemap[(-y+y0) * DEFAULT_WIDTH + (x+x0)] );
device/framebuffer_rpi/drawShapes.c:        		drawPixel(y + x0, -x + y0, linemap[(-x+y0) * DEFAULT_WIDTH + (y+x0)] );
device/framebuffer_rpi/drawShapes.c:        	    drawPixel(-x + x0, y + y0, color);
device/framebuffer_rpi/drawShapes.c:        	    drawPixel(-y + x0, x + y0, color);
device/framebuffer_rpi/drawShapes.c:        	    drawPixel(-x + x0, -y + y0, color);
device/framebuffer_rpi/drawShapes.c:        	    drawPixel(-y + x0, -x + y0, color);
device/framebuffer_rpi/drawShapes.c:        	    drawPixel(x + x0, -y + y0, color);
device/framebuffer_rpi/drawShapes.c:        	    drawPixel(y + x0, -x + y0, color);
device/framebuffer_rpi/drawShapes.c:              	x--;
device/framebuffer_rpi/drawShapes.c:               	radiusError += 2 * (y - x + 1);
device/framebuffer_rpi/drawShapes.c:		rad--;
device/framebuffer_rpi/fbPutc.c:            cursor_row = rows - MINISHELLMINROW;
device/framebuffer_rpi/font.c:0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, /*'-'*/
device/framebuffer_rpi/screenInit.c:    ulong *address = (ulong *)(framebufferAddress + (pitch * (DEFAULT_HEIGHT - (MINISHELLMINROW * CHAR_HEIGHT))) +  (DEFAULT_WIDTH * (BIT_DEPTH / 8)));
device/framebuffer_rpi/screenInit.c:        i--;
device/framebuffer_rpi/trig.c: * Cannot handle values above 215 degrees--will cause overflow.
device/framebuffer_rpi/trig.c:    return num*factorial(num-1);
device/framebuffer_rpi/trig.c:        result += power(-1.0,i)*power(x,i*2)/factorial(i*2);
device/framebuffer_rpi/trig.c:    else if ((x % 180) == 0) return -1;
device/framebuffer_rpi/trig.c:    else if ( ((x > -360) && (x < -270)) || ((x > 0) && (x < 90)) ) {
device/framebuffer_rpi/trig.c:    else if ( ((x > -270) && (x < -180)) || ((x > 90) && (x < 180)) ) {
device/framebuffer_rpi/trig.c:        radx = PI * (180 - x) / 180;
device/framebuffer_rpi/trig.c:        return -1 * cosine_taylor(radx, 10);
device/framebuffer_rpi/trig.c:    else if ( ((x > -180) && (x < -90)) || ((x > 180) && (x < 270)) ) {
device/framebuffer_rpi/trig.c:        radx = PI * (x - 180) / 180;
device/framebuffer_rpi/trig.c:        return -1 * cosine_taylor(radx, 10);
device/framebuffer_rpi/trig.c:        radx = PI * (360 - x) / 180;
device/framebuffer_rpi/trig.c:        result += power(-1,i)*power(x,i*2+1)/factorial(i*2+1);
device/framebuffer_rpi/trig.c:    else if ((x == 90) || (x == -270)) return -1;
device/framebuffer_rpi/trig.c:    else if ((x == -90) || (x == 270)) return 1;
device/framebuffer_rpi/trig.c:    else if ( ((x > -360) && (x < -270)) || ((x > 0) && (x < 90)) ) {
device/framebuffer_rpi/trig.c:        return -1 * sine_taylor(radx, 10);
device/framebuffer_rpi/trig.c:    else if ( ((x > -270) && (x < -180)) || ((x > 90) && (x < 180)) ) {
device/framebuffer_rpi/trig.c:        radx = PI * (180 - x) / 180;
device/framebuffer_rpi/trig.c:        return -1 * sine_taylor(radx, 10);
device/framebuffer_rpi/trig.c:    else if ( ((x > -180) && (x < -90)) || ((x > 180) && (x < 270)) ) {
device/framebuffer_rpi/trig.c:        radx = PI * (x - 180) / 180;
device/framebuffer_rpi/trig.c:        radx = PI * (360 - x) / 180;
device/http/httpCleanPrompts.c:        && !(webptr->flags & HTTP_FLAG_CLEANSED))
device/http/httpCleanPrompts.c:                    lentoend = len - (uint)(found - buf) + 1;
device/http/httpCleanPrompts.c:                    promptlen = (uint)(end - found);
device/http/httpCleanPrompts.c:                           lentoend - promptlen);
device/http/httpCleanPrompts.c:                    len -= promptlen;
device/http/httpCleanPrompts.c:                    bzero(found + (lentoend - promptlen), promptlen);
device/http/httpCleanPrompts.c:            (webptr->flags & HTTP_FLAG_WAITONSHELL))
device/http/httpClose.c:    webptr = &httptab[devptr->minor];
device/http/httpClose.c:    if (HTTP_STATE_ALLOC != webptr->state)
device/http/httpClose.c:    semfree(webptr->closeall);
device/http/httpClose.c:    if (NULL != webptr->content)
device/http/httpClose.c:        free(webptr->content);
device/http/httpClose.c:    if (NULL != webptr->boundary)
device/http/httpClose.c:        free(webptr->boundary);
device/http/httpClose.c:    if (NULL != webptr->hostname_str)
device/http/httpClose.c:        free(webptr->hostname_str);
device/http/httpClose.c:    if (NULL != webptr->domainname_str)
device/http/httpClose.c:        free(webptr->domainname_str);
device/http/httpClose.c:    if (NULL != webptr->lan_ip_str)
device/http/httpClose.c:        free(webptr->lan_ip_str);
device/http/httpClose.c:    if (NULL != webptr->subnet_mask_str)
device/http/httpClose.c:        free(webptr->subnet_mask_str);
device/http/httpClose.c:    if (NULL != webptr->gate_ip_str)
device/http/httpClose.c:        free(webptr->gate_ip_str);
device/http/httpClose.c:    webptr->state = HTTP_STATE_FREE;
device/http/httpConfigPage.c:    if (*webptr->content != NULL)
device/http/httpConfigPage.c:        for (cntr = 0; cntr < webptr->contentlen; cntr++)
device/http/httpConfigPage.c:                name = (webptr->content + cntr);
device/http/httpConfigPage.c:            if ('+' == *(webptr->content + cntr))
device/http/httpConfigPage.c:                *(webptr->content + cntr) = ' ';
device/http/httpConfigPage.c:            else if ('=' == *(webptr->content + cntr))
device/http/httpConfigPage.c:                *(webptr->content + cntr) = '\0';
device/http/httpConfigPage.c:                value = (webptr->content + (cntr + 1));
device/http/httpConfigPage.c:            else if ('&' == *(webptr->content + cntr))
device/http/httpConfigPage.c:                *(webptr->content + (cntr)) = '\0';
device/http/httpConfigPage.c:    webptr->hostname_str = (char *)malloc(hostname_strsz + DEVMAXNAME);
device/http/httpConfigPage.c:    if (NULL == webptr->hostname_str)
device/http/httpConfigPage.c:    webptr->domainname_str =
device/http/httpConfigPage.c:    if (NULL == webptr->domainname_str)
device/http/httpConfigPage.c:        free(webptr->hostname_str);
device/http/httpConfigPage.c:    webptr->lan_ip_str = (char *)malloc(lan_ip_strsz + DEVMAXNAME);
device/http/httpConfigPage.c:    if (NULL == webptr->lan_ip_str)
device/http/httpConfigPage.c:        free(webptr->hostname_str);
device/http/httpConfigPage.c:        free(webptr->domainname_str);
device/http/httpConfigPage.c:    webptr->subnet_mask_str =
device/http/httpConfigPage.c:    if (NULL == webptr->subnet_mask_str)
device/http/httpConfigPage.c:        free(webptr->hostname_str);
device/http/httpConfigPage.c:        free(webptr->domainname_str);
device/http/httpConfigPage.c:        free(webptr->lan_ip_str);
device/http/httpConfigPage.c:    webptr->gate_ip_str = (char *)malloc(gate_ip_strsz + DEVMAXNAME);
device/http/httpConfigPage.c:    if (NULL == webptr->gate_ip_str)
device/http/httpConfigPage.c:        free(webptr->hostname_str);
device/http/httpConfigPage.c:        free(webptr->domainname_str);
device/http/httpConfigPage.c:        free(webptr->lan_ip_str);
device/http/httpConfigPage.c:        free(webptr->subnet_mask_str);
device/http/httpConfigPage.c:    webptr = &httptab[devptr->minor];
device/http/httpConfigPage.c:    char *hostname_str = webptr->hostname_str;
device/http/httpConfigPage.c:    char *domainname_str = webptr->domainname_str;
device/http/httpConfigPage.c:    char *lan_ip_str = webptr->lan_ip_str;
device/http/httpConfigPage.c:    char *subnet_mask_str = webptr->subnet_mask_str;
device/http/httpConfigPage.c:    char *gate_ip_str = webptr->gate_ip_str;
device/http/httpConfigPage.c:        sprintf(hostname_str, "%s_%s", ethptr->name, NET_HOSTNAME);
device/http/httpConfigPage.c:        sprintf(domainname_str, "%s_%s", ethptr->name, NET_DOMAINNAME);
device/http/httpConfigPage.c:        sprintf(lan_ip_str, "%s_%s", ethptr->name, NET_LAN_IPADDR);
device/http/httpConfigPage.c:        sprintf(subnet_mask_str, "%s_%s", ethptr->name, NET_SUBNET_MASK);
device/http/httpConfigPage.c:               ethptr->name,    /* Device name */
device/http/httpControl.c:    webptr = &httptab[devptr->minor];
device/http/httpControl.c:    if (HTTP_STATE_ALLOC != webptr->state)
device/http/httpControl.c:        old = webptr->flags & arg1;
device/http/httpControl.c:        webptr->flags |= (arg1);
device/http/httpControl.c:        old = webptr->flags & arg1;
device/http/httpControl.c:        webptr->flags &= ~(arg1);
device/http/httpErrorResponse.c:    webptr = &httptab[devptr->minor];
device/http/httpErrorResponse.c:    if (HTTP_STATE_ALLOC != webptr->state)
device/http/httpErrorResponse.c:        "Content-Type: text/html; charset=ISO-8859-1\r\n"
device/http/httpErrorResponse.c:        "Content-Length: %d\r\n\r\n"
device/http/httpErrorResponse.c:    signal(webptr->closeall);
device/http/httpFree.c:    httptab[devptr->minor].state = HTTP_STATE_FREE;
device/http/httpHtmlBegin.c:        "<div style='font-family:courier;font-size:13;font-weight:bold;"
device/http/httpHtmlBegin.c:        "<div style='font-family:courier;font-size:13'>";
device/http/httpHtmlBegin.c:            "style='text-decoration:none'>%s</a>";
device/http/httpInit.c:semaphore maxhttp = -1;
device/http/httpInit.c:semaphore activeXWeb = -1;
device/http/httpInit.c:    webptr = &httptab[devptr->minor];
device/http/httpInit.c:    webptr->state = HTTP_STATE_FREE;
device/http/httpOpen.c:    webptr = &httptab[devptr->minor];
device/http/httpOpen.c:    if (HTTP_STATE_FREE != webptr->state)
device/http/httpOpen.c:    webptr->state = HTTP_STATE_ALLOC;
device/http/httpOpen.c:    webptr->phw = (device *)&devtab[dvnum];
device/http/httpOpen.c:    webptr->rstart = 0;
device/http/httpOpen.c:    webptr->rcount = 0;
device/http/httpOpen.c:    webptr->wstart = 0;
device/http/httpOpen.c:    webptr->wcount = 0;
device/http/httpOpen.c:    webptr->closeall = semcreate(0);
device/http/httpPutc.c:    webptr = &httptab[devptr->minor];
device/http/httpPutc.c:    phw = webptr->phw;
device/http/httpRead.c:    methodint = -1;
device/http/httpRead.c:    flashSuccess = -1;
device/http/httpRead.c:    webptr = &httptab[devptr->minor];
device/http/httpRead.c:    phw = webptr->phw;
device/http/httpRead.c:    webptr->rcount = 0;
device/http/httpRead.c:    webptr->hdrcount = httpReadRqst(devptr);
device/http/httpRead.c:    if (SYSERR == webptr->hdrcount)
device/http/httpRead.c:        webptr->hdrcount = 0;
device/http/httpRead.c:        signal(webptr->closeall);
device/http/httpRead.c:    /* Acquire the remaining webptr->content of the request */
device/http/httpRead.c:    if (webptr->contentlen > 0)
device/http/httpRead.c:        webptr->content = (char *)malloc(webptr->contentlen + 1);
device/http/httpRead.c:        if (NULL == webptr->content)
device/http/httpRead.c:        bzero(webptr->content, webptr->contentlen + 1);
device/http/httpRead.c:        for (i = 0; i < webptr->contentlen; i++)
device/http/httpRead.c:            *(webptr->content + i) = (*phw->getc) (phw);
device/http/httpRead.c:        webptr->content = NULL;
device/http/httpRead.c:    for (; webptr->rin[i] == ' ' && i < webptr->hdrend[0]; i++)
device/http/httpRead.c:    for (; webptr->rin[i] != ' ' && i < webptr->hdrend[0]; i++)
device/http/httpRead.c:    slen = i - start;
device/http/httpRead.c:    methodint = validMethod(&webptr->rin[start], slen);
device/http/httpRead.c:    else if (HTTP_METHOD_POST == methodint && 0 == webptr->contentlen)
device/http/httpRead.c:    for (; webptr->rin[i] == ' ' && i < webptr->hdrend[0]; i++)
device/http/httpRead.c:    for (; webptr->rin[i] != ' ' && i < webptr->hdrend[0]; i++)
device/http/httpRead.c:    for (; webptr->rin[i] == ' ' && i < webptr->hdrend[0]; i++)
device/http/httpRead.c:    for (; webptr->rin[i] != ' ' && i < webptr->hdrend[0]; i++)
device/http/httpRead.c:    slen = i - start;
device/http/httpRead.c:    if (SYSERR == validVersion(&webptr->rin[start], slen))
device/http/httpRead.c:    cmdindex = validURI(&webptr->rin[uriStart], uriEnd - uriStart);
device/http/httpRead.c:        "Content-Type: text/html; charset=ISO-8859-1\r\n"
device/http/httpRead.c:        "Transfer-Encoding: chunked\r\n\r\n";
device/http/httpRead.c:    if (webptr->content != NULL)
device/http/httpRead.c:        free(webptr->content);
device/http/httpRead.c:    if (webptr->boundary != NULL)
device/http/httpRead.c:        free(webptr->boundary);
device/http/httpReadHdrs.c:char *allowed_hdr[] = { "Content-Length: ", "Content-Type: " };
device/http/httpReadHdrs.c:    for (cntr = 1; cntr < webptr->hdrcount; cntr++)
device/http/httpReadHdrs.c:        starthdr = webptr->hdrend[cntr - 1] + 2;        /* Starts after a newline */
device/http/httpReadHdrs.c:        endhdr = webptr->hdrend[cntr];
device/http/httpReadHdrs.c:        hdrlen = endhdr - starthdr;
device/http/httpReadHdrs.c:        memcpy(header, &webptr->rin[starthdr], hdrlen);
device/http/httpReadHdrs.c:        /* Content-Length header */
device/http/httpReadHdrs.c:                    sum += (int)(*value - '0');
device/http/httpReadHdrs.c:            webptr->contentlen = sum;
device/http/httpReadHdrs.c:        /* Content-Type header */
device/http/httpReadHdrs.c:                    valuelen = (uint)valueend - (uint)value;
device/http/httpReadHdrs.c:                webptr->boundarylen = valuelen;
device/http/httpReadHdrs.c:                webptr->boundary = (char *)malloc(valuelen);
device/http/httpReadHdrs.c:                if (NULL == webptr->boundary)
device/http/httpReadHdrs.c:                memcpy(webptr->boundary, value, valuelen);
device/http/httpReadHdrs.c:                webptr->boundary = NULL;
device/http/httpReadHdrs.c:                webptr->boundarylen = 0;
device/http/httpReadRqst.c:    webptr = &httptab[devptr->minor];
device/http/httpReadRqst.c:    phw = webptr->phw;
device/http/httpReadRqst.c:    while (!(webptr->flags & HTTP_FLAG_RQSTEND) &&
device/http/httpReadRqst.c:           (webptr->rcount < HTTP_RBLEN) && (hdrcount < HTTP_MAX_HDRS))
device/http/httpReadRqst.c:        ch = (*phw->getc) (phw);
device/http/httpReadRqst.c:        if (webptr->rcount >= 1)
device/http/httpReadRqst.c:            if ('\r' == webptr->rin[webptr->rcount - 1] && '\n' == ch)
device/http/httpReadRqst.c:                    webptr->hdrend[hdrcount] = webptr->rcount - 1;
device/http/httpReadRqst.c:        webptr->rin[webptr->rcount] = ch;
device/http/httpReadRqst.c:        webptr->rcount++;
device/http/httpServer.c:    host = &(nif->ip);
device/http/httpServer.c:    webptr = &httptab[devptr->minor];
device/http/httpServer.c:    wait(webptr->closeall);
device/http/httpValidations.c:    ulen--;
device/http/httpWrite.c:    webptr = &httptab[devptr->minor];
device/http/httpWrite.c:    phw = webptr->phw;
device/http/httpWrite.c:    if (webptr->flags & HTTP_FLAG_AWAITINGRQST)
device/http/httpWrite.c:    if (webptr->flags & HTTP_FLAG_CLEARWOUT)
device/http/httpWrite.c:        bzero(&webptr->wout, HTTP_WBLEN);
device/http/httpWrite.c:        webptr->wcount = 0;
device/http/httpWrite.c:    if ((webptr->wcount > 0) &&
device/http/httpWrite.c:        ((webptr->flags & HTTP_FLAG_FLUSHWOUT) ||
device/http/httpWrite.c:         ((webptr->wcount + len) > HTTP_WBLEN)))
device/http/httpWrite.c:        bzero(webptr->out, HTTP_OBLEN);
device/http/httpWrite.c:        if (webptr->flags & HTTP_FLAG_CHUNKED)
device/http/httpWrite.c:            sprintf(webptr->out, "%x\r\n", webptr->wcount);
device/http/httpWrite.c:            cursize = strnlen(webptr->out, HTTP_MAX_CHUNK);
device/http/httpWrite.c:        memcpy(&webptr->out[cursize], webptr->wout, webptr->wcount);
device/http/httpWrite.c:        cursize += webptr->wcount;
device/http/httpWrite.c:        bzero(webptr->wout, webptr->wcount);
device/http/httpWrite.c:        webptr->wcount = 0;
device/http/httpWrite.c:        if (webptr->flags & HTTP_FLAG_CHUNKED)
device/http/httpWrite.c:            webptr->out[cursize++] = '\r';
device/http/httpWrite.c:            webptr->out[cursize++] = '\n';
device/http/httpWrite.c:        (*phw->write) (phw, webptr->out, cursize);
device/http/httpWrite.c:        bzero(webptr->out, HTTP_OBLEN);
device/http/httpWrite.c:        if (webptr->flags & HTTP_FLAG_CHUNKED)
device/http/httpWrite.c:            sprintf(webptr->out, "%x\r\n", len);
device/http/httpWrite.c:            cursize = strnlen(webptr->out, HTTP_MAX_CHUNK);
device/http/httpWrite.c:            (*phw->write) (phw, webptr->out, cursize);
device/http/httpWrite.c:            bzero(webptr->out, cursize);
device/http/httpWrite.c:        (*phw->write) (phw, buffer, cursize);
device/http/httpWrite.c:        if (webptr->flags & HTTP_FLAG_CHUNKED)
device/http/httpWrite.c:            webptr->out[0] = '\r';
device/http/httpWrite.c:            webptr->out[1] = '\n';
device/http/httpWrite.c:            (*phw->write) (phw, webptr->out, cursize);
device/http/httpWrite.c:            bzero(webptr->out, cursize);
device/http/httpWrite.c:        memcpy(&webptr->wout[webptr->wstart + webptr->wcount],
device/http/httpWrite.c:        webptr->wcount += len;
device/http/httpWrite.c:        webptr->wcount =
device/http/httpWrite.c:            cleanPrompts(devptr, webptr->wout, webptr->wcount, webptr);
device/http/httpWrite.c:    if (!(webptr->flags & HTTP_FLAG_WAITONSHELL) &&
device/http/httpWrite.c:        (webptr->flags & HTTP_FLAG_ENDREADOUTPUT))
device/http/httpWrite.c:        if (webptr->wcount > 0)
device/http/httpWrite.c:            bzero(webptr->out, HTTP_OBLEN);
device/http/httpWrite.c:            if (webptr->flags & HTTP_FLAG_CHUNKED)
device/http/httpWrite.c:                sprintf(webptr->out, "%x\r\n", webptr->wcount);
device/http/httpWrite.c:                cursize = strnlen(webptr->out, HTTP_MAX_CHUNK);
device/http/httpWrite.c:            memcpy(&webptr->out[cursize], webptr->wout, webptr->wcount);
device/http/httpWrite.c:            cursize += webptr->wcount;
device/http/httpWrite.c:            bzero(webptr->wout, webptr->wcount);
device/http/httpWrite.c:            webptr->wcount = 0;
device/http/httpWrite.c:            webptr->out[cursize++] = '\r';
device/http/httpWrite.c:            webptr->out[cursize++] = '\n';
device/http/httpWrite.c:            (*phw->write) (phw, webptr->out, cursize);
device/http/httpWrite.c:        bzero(webptr->out, HTTP_OBLEN);
device/http/httpWrite.c:        if (webptr->flags & HTTP_FLAG_CHUNKED)
device/http/httpWrite.c:            sprintf(webptr->out, "%x\r\n%s\r\n%x\r\n\r\n",
device/http/httpWrite.c:            sprintf(webptr->out, "%s\r\n\r\n", endpage);
device/http/httpWrite.c:        (*phw->write) (phw, webptr->out,
device/http/httpWrite.c:                       strnlen(webptr->out, HTTP_OBLEN));
device/http/httpWrite.c:        webptr->wcount = 0;
device/http/httpWrite.c:        signal(webptr->closeall);
device/loopback/loopbackClose.c:    lbkptr = &looptab[devptr->minor];
device/loopback/loopbackClose.c:    if (LOOP_STATE_ALLOC != lbkptr->state)
device/loopback/loopbackClose.c:    semfree(lbkptr->sem);
device/loopback/loopbackClose.c:    lbkptr->state = LOOP_STATE_FREE;
device/loopback/loopbackControl.c:    lbkptr = &looptab[devptr->minor];
device/loopback/loopbackControl.c:    if (LOOP_STATE_ALLOC != lbkptr->state)
device/loopback/loopbackControl.c:        old = lbkptr->flags;
device/loopback/loopbackControl.c:        lbkptr->flags |= arg1;
device/loopback/loopbackControl.c:        old = lbkptr->flags & arg1;
device/loopback/loopbackControl.c:        lbkptr->flags &= ~(ulong)arg1;
device/loopback/loopbackGetc.c:    lbkptr = &looptab[devptr->minor];
device/loopback/loopbackGetc.c:    if (LOOP_NONBLOCK == (lbkptr->flags & LOOP_NONBLOCK)) {
device/loopback/loopbackGetc.c:        if (semcount(lbkptr->sem) <= 0) {
device/loopback/loopbackGetc.c:    wait(lbkptr->sem);
device/loopback/loopbackGetc.c:    ch = lbkptr->buffer[lbkptr->index];
device/loopback/loopbackGetc.c:    lbkptr->index = (lbkptr->index + 1) % LOOP_BUFFER;
device/loopback/loopbackInit.c:    lbkptr = &looptab[devptr->minor];
device/loopback/loopbackInit.c:    lbkptr->state = LOOP_STATE_FREE;
device/loopback/loopbackInit.c:    lbkptr->index = 0;
device/loopback/loopbackOpen.c:    lbkptr = &looptab[devptr->minor];
device/loopback/loopbackOpen.c:    if (LOOP_STATE_FREE != lbkptr->state)
device/loopback/loopbackOpen.c:    lbkptr->sem = semcreate(0);
device/loopback/loopbackOpen.c:    if (SYSERR == lbkptr->sem)
device/loopback/loopbackOpen.c:    bzero(lbkptr->buffer, LOOP_BUFFER);
device/loopback/loopbackOpen.c:    lbkptr->flags = 0;
device/loopback/loopbackOpen.c:    lbkptr->state = LOOP_STATE_ALLOC;
device/loopback/loopbackPutc.c:    lbkptr = &looptab[devptr->minor];
device/loopback/loopbackPutc.c:    if (LOOP_BUFFER <= semcount(lbkptr->sem))
device/loopback/loopbackPutc.c:    i = (lbkptr->index + semcount(lbkptr->sem)) % LOOP_BUFFER;
device/loopback/loopbackPutc.c:    lbkptr->buffer[i] = ch;
device/loopback/loopbackPutc.c:    signal(lbkptr->sem);
device/loopback/loopbackRead.c:    lbkptr = &looptab[devptr->minor];
device/loopback/loopbackRead.c:    if (LOOP_STATE_ALLOC != lbkptr->state)
device/loopback/loopbackWrite.c:    lbkptr = &looptab[devptr->minor];
device/loopback/loopbackWrite.c:    if (LOOP_STATE_ALLOC != lbkptr->state)
device/raw/rawClose.c:    rawptr = &rawtab[devptr->minor];
device/raw/rawClose.c:    if (RAW_ALLOC != rawptr->state)
device/raw/rawClose.c:    if (SYSERR == semfree(rawptr->isema))
device/raw/rawClose.c:    while (rawptr->icount > 0)
device/raw/rawClose.c:        netFreebuf(rawptr->in[rawptr->istart]);
device/raw/rawClose.c:        rawptr->istart = (rawptr->istart + 1) % RAW_IBLEN;
device/raw/rawClose.c:        rawptr->icount--;
device/raw/rawControl.c:    rawptr = &rawtab[devptr->minor];
device/raw/rawControl.c:    if (RAW_ALLOC != rawptr->state)
device/raw/rawControl.c:        old = rawptr->flags & arg1;
device/raw/rawControl.c:        rawptr->flags |= (arg1);
device/raw/rawControl.c:        old = rawptr->flags & arg1;
device/raw/rawControl.c:        rawptr->flags &= ~(arg1);
device/raw/rawInit.c:    rawptr = &rawtab[devptr->minor];
device/raw/rawOpen.c:    rawptr = &rawtab[devptr->minor];
device/raw/rawOpen.c:    if (RAW_FREE != rawptr->state)
device/raw/rawOpen.c:    rawptr->state = RAW_ALLOC;
device/raw/rawOpen.c:    rawptr->dev = devptr;
device/raw/rawOpen.c:    rawptr->proto = proto;
device/raw/rawOpen.c:        rawptr->localip.type = NULL;
device/raw/rawOpen.c:        netaddrcpy(&rawptr->localip, localip);
device/raw/rawOpen.c:        rawptr->remoteip.type = NULL;
device/raw/rawOpen.c:        netaddrcpy(&rawptr->remoteip, remoteip);
device/raw/rawOpen.c:    rawptr->istart = 0;
device/raw/rawOpen.c:    rawptr->icount = 0;
device/raw/rawOpen.c:    rawptr->isema = semcreate(0);
device/raw/rawOpen.c:    if (SYSERR == (int)rawptr->isema)
device/raw/rawOpen.c:    rawptr->flags = NULL;
device/raw/rawRead.c:    rawptr = &rawtab[devptr->minor];
device/raw/rawRead.c:    if (RAW_ALLOC != rawptr->state)
device/raw/rawRead.c:    wait(rawptr->isema);
device/raw/rawRead.c:    pkt = rawptr->in[rawptr->istart];
device/raw/rawRead.c:    RAW_TRACE("Read packet from pos %d", rawptr->istart);
device/raw/rawRead.c:    if (rawptr->flags & RAW_IACCEPT)
device/raw/rawRead.c:        netaddrcpy(&rawptr->remoteip, &rawptr->src[rawptr->istart]);
device/raw/rawRead.c:        rawptr->flags = rawptr->flags & ~RAW_IACCEPT;
device/raw/rawRead.c:        netaddrsprintf(str, &rawptr->remoteip);
device/raw/rawRead.c:    rawptr->in[rawptr->istart] = NULL;
device/raw/rawRead.c:    rawptr->icount--;
device/raw/rawRead.c:    rawptr->istart = (rawptr->istart + 1) % RAW_IBLEN;
device/raw/rawRead.c:    if (rawptr->flags & RAW_IHDR)
device/raw/rawRead.c:        data = pkt->nethdr;
device/raw/rawRead.c:        dlen = pkt->len - (pkt->nethdr - pkt->linkhdr);
device/raw/rawRead.c:        data = pkt->curr;
device/raw/rawRead.c:        dlen = pkt->len - (pkt->curr - pkt->linkhdr);
device/raw/rawRecv.c:    if (rawptr->icount >= RAW_IBLEN)
device/raw/rawRecv.c:    index = (rawptr->istart + rawptr->icount) % RAW_IBLEN;
device/raw/rawRecv.c:    rawptr->in[index] = pkt;
device/raw/rawRecv.c:    netaddrcpy(&rawptr->src[index], src);
device/raw/rawRecv.c:    rawptr->icount++;
device/raw/rawRecv.c:    signal(rawptr->isema);
device/raw/rawSend.c:    if ((NULL == rawptr) || (NULL == buf) || (RAW_ALLOC != rawptr->state))
device/raw/rawSend.c:    if (rawptr->flags & RAW_OHDR)
device/raw/rawSend.c:        if ((NULL == rawptr->localip.type)
device/raw/rawSend.c:            || (NULL == rawptr->remoteip.type))
device/raw/rawSend.c:            RAW_TRACE("Under-specified socket");
device/raw/rawSend.c:        if ((NULL == rawptr->proto) || (NULL == rawptr->remoteip.type))
device/raw/rawSend.c:            RAW_TRACE("Under-specified socket");
device/raw/rawSend.c:    pkt->curr -= len;
device/raw/rawSend.c:    pkt->len += len;
device/raw/rawSend.c:    memcpy(pkt->curr, buf, len);
device/raw/rawSend.c:    if (rawptr->flags & RAW_OHDR)
device/raw/rawSend.c:        pkt->nethdr = pkt->curr;
device/raw/rawSend.c:        rtptr = rtLookup(&rawptr->remoteip);
device/raw/rawSend.c:        if ((NULL == rtptr) || (NULL == rtptr->nif))
device/raw/rawSend.c:        pkt->nif = rtptr->nif;
device/raw/rawSend.c:        result = netSend(pkt, NULL, &rawptr->remoteip,
device/raw/rawSend.c:                         rawptr->remoteip.type);
device/raw/rawSend.c:        switch (rawptr->remoteip.type)
device/raw/rawSend.c:            result = ipv4Send(pkt, &rawptr->localip, &rawptr->remoteip,
device/raw/rawSend.c:                              rawptr->proto);
device/raw/rawWrite.c:    rawptr = &rawtab[devptr->minor];
device/rtp/rtpClose.c:    rtpptr = &rtptab[devptr->minor];
device/rtp/rtpClose.c:    bfpfree(rtpptr->inPool);
device/rtp/rtpClose.c:    semfree(rtpptr->isem);
device/rtp/rtpClose.c:    rtpptr->state = RTP_FREE;
device/rtp/rtpGetbuf.c:    rtppkt = bufget(rtpptr->inPool);
device/rtp/rtpInit.c:    rtpptr = &rtptab[devptr->minor];
device/rtp/rtpOpen.c:    rtpptr->sequence = 0;       // Random number        
device/rtp/rtpOpen.c:    rtpptr->tp = 0;
device/rtp/rtpOpen.c:    rtpptr->tc = 0;
device/rtp/rtpOpen.c:    rtpptr->senders = 0;
device/rtp/rtpOpen.c:    rtpptr->pmembers = 0;
device/rtp/rtpOpen.c:    rtpptr->members = 1;
device/rtp/rtpOpen.c:    rtpptr->we_sent = false;
device/rtp/rtpOpen.c:    //rtpptr->rtcp_bw = //specified fraction of session bandwidth
device/rtp/rtpOpen.c:    rtpptr->inital = true;
device/rtp/rtpOpen.c:    //rtpptr->avg_rtcp_size = (1/16) * //packet_size + (15/16) * rtpptr->avg_rtcp_size;
device/rtp/rtpOpen.c:    rtpptr = &rtptab[devptr->minor];
device/rtp/rtpOpen.c:    if (RTP_OPEN == rtpptr->state)
device/rtp/rtpOpen.c:        RTP_TRACE("rtp%d has already been opened.", devptr->minor);
device/rtp/rtpOpen.c:    rtpptr->state = RTP_OPEN;
device/rtp/rtpOpen.c:    rtpptr->dev = devptr;
device/rtp/rtpOpen.c:    rtpptr->icount = 0;
device/rtp/rtpOpen.c:    rtpptr->istart = 0;
device/rtp/rtpOpen.c:    rtpptr->isem = semcreate(0);
device/rtp/rtpOpen.c:    rtpptr->inPool = bfpalloc(NET_MAX_PKTLEN, RTP_MAX_PKTS);
device/rtp/rtpOpen.c:              devptr->minor, rtpptr->inPool);
device/rtp/rtpOpen.c:    nextport = (nextport + 1) % (RTP_PMAX - RTP_PSTART);
device/rtp/rtpOpen.c:            nextport = (nextport + 1) % (RTP_PMAX - RTP_PSTART);
device/rtp/rtpRead.c:    rtpptr = &rtptab[devptr->minor];
device/rtp/rtpRead.c:    wait(rtpptr->isem);
device/rtp/rtpRead.c:    //rtppktext = (struct rtpPktExt *)rtpptr->in[rtpptr->istart];
device/rtp/rtpRead.c:    rtpptr->istart = (rtpptr->istart + 1) % RTP_MAX_PKTS;
device/rtp/rtpRead.c:    rtpptr->icount--;
device/rtp/rtpRead.c:    count = rtppkt->len - RTP_HDR_LEN;
device/rtp/rtpRead.c:    data = rtppkt->data;
device/rtp/rtpRecv.c:    rtppkt = (struct rtpPkt *)pkt->curr;
device/rtp/rtpRecv.c:    //          rtppkt->srcPort, strB, rtppkt->dstPort);
device/rtp/rtpRecv.c:    if (rtpptr->icount >= RTP_MAX_PKTS)
device/rtp/rtpRecv.c:    memcpy((rtpext + 1), rtppkt, rtppkt->len);
device/rtp/rtpRecv.c:    rtpptr->in[(rtpptr->istart + rtpptr->icount) % RTP_MAX_PKTS] = tpkt;
device/rtp/rtpRecv.c:    rtpptr->icount++;
device/rtp/rtpRecv.c:    signal(rtpptr->isem);
device/rtp/rtpSend.c:    pkt->len = datalen;
device/rtp/rtpSend.c:    pkt->curr -= (3 + (ulong)(pkt->len)) & ~0x03;
device/rtp/rtpSend.c:    memcpy(pkt->curr, (rtppktext + 1), datalen);
device/rtp/rtpSend.c:    rtppkt = (struct rtpPkt *)(pkt->curr);
device/rtp/rtpSend.c:    pkt->len = datalen;
device/rtp/rtpSend.c:    pkt->curr -= (3 + (ulong)(pkt->len)) & ~0x03;
device/rtp/rtpSend.c:    rtppkt = (struct rtpPkt *)(pkt->curr);
device/rtp/rtpSend.c:    rtppkt->control = 0;
device/rtp/rtpSend.c:    rtppkt->seqNum = rtpptr->sequence;
device/rtp/rtpSend.c:    rtpptr->sequence++;
device/rtp/rtpSend.c:    rtppkt->timestamp =;
device/rtp/rtpSend.c:    rtppkt->ssrc =;
device/rtp/rtpSend.c:    rtppkt->csrc[0] =;
device/rtp/rtpSend.c:    memcpy(rtppkt->data, buf, datalen - RTP_HDR_LEN);
device/rtp/rtpWrite.c:    rtpptr = &rtptab[devptr->minor];
device/rtp/rtpWrite.c:            len -= RTP_MAX_DATALEN;
device/smsc9512/Doxygroup.c: * @defgroup etherspecific Ethernet Device-Specific Functions
device/smsc9512/colon2mac.c: * Convert a colon-separated string representation of a MAC into
device/smsc9512/colon2mac.c: * @param src pointer to colon-separated MAC string
device/smsc9512/colon2mac.c:            digit = c - '0';
device/smsc9512/colon2mac.c:            digit = 10 + c - (isupper(c) ? 'A' : 'a');
device/smsc9512/colon2mac.c:            digit = c - '0';
device/smsc9512/colon2mac.c:            digit = 10 + c - (isupper(c) ? 'A' : 'a');
device/smsc9512/etherControl.c:    ethptr = &ethertab[devptr->minor];
device/smsc9512/etherControl.c:    udev = ethptr->csr;
device/smsc9512/etherControl.c:        addr->type = NETADDR_ETHERNET;
device/smsc9512/etherControl.c:        addr->len = ETH_ADDR_LEN;
device/smsc9512/etherControl.c:        return etherControl(devptr, ETH_CTRL_GET_MAC, (long)addr->addr, 0);
device/smsc9512/etherControl.c:        addr->type = NETADDR_ETHERNET;
device/smsc9512/etherControl.c:        addr->len = ETH_ADDR_LEN;
device/smsc9512/etherControl.c:        memset(addr->addr, 0xFF, ETH_ADDR_LEN);
device/smsc9512/etherInit.c:    if (udev->descriptor.idVendor != SMSC9512_VENDOR_ID ||
device/smsc9512/etherInit.c:        udev->descriptor.idProduct != SMSC9512_PRODUCT_ID ||
device/smsc9512/etherInit.c:        udev->interfaces[0]->bNumEndpoints < 2 ||
device/smsc9512/etherInit.c:        (udev->endpoints[0][0]->bmAttributes & 0x3) != USB_TRANSFER_TYPE_BULK ||
device/smsc9512/etherInit.c:        (udev->endpoints[0][1]->bmAttributes & 0x3) != USB_TRANSFER_TYPE_BULK ||
device/smsc9512/etherInit.c:        (udev->endpoints[0][0]->bEndpointAddress >> 7) != USB_DIRECTION_IN ||
device/smsc9512/etherInit.c:        (udev->endpoints[0][1]->bEndpointAddress >> 7) != USB_DIRECTION_OUT ||
device/smsc9512/etherInit.c:        udev->speed != USB_SPEED_HIGH)
device/smsc9512/etherInit.c:    if (ethptr->csr != NULL)
device/smsc9512/etherInit.c:    udev->last_error = USB_STATUS_SUCCESS;
device/smsc9512/etherInit.c:    smsc9512_set_mac_address(udev, ethptr->devAddress);
device/smsc9512/etherInit.c:    if (udev->last_error != USB_STATUS_SUCCESS)
device/smsc9512/etherInit.c:        return udev->last_error;
device/smsc9512/etherInit.c:    ethptr->csr = udev;
device/smsc9512/etherInit.c:    udev->driver_private = ethptr;
device/smsc9512/etherInit.c:    signal(smsc9512_attached[ethptr - ethertab]);
device/smsc9512/etherInit.c:    struct ether *ethptr = udev->driver_private;
device/smsc9512/etherInit.c:    wait(smsc9512_attached[ethptr - ethertab]);
device/smsc9512/etherInit.c:    etherClose(ethptr->dev);
device/smsc9512/etherInit.c:         * is that we must generate a 48-bit MAC address from a 64-bit serial
device/smsc9512/etherInit.c:         * hash the serial number to remove any obvious non-randomness in the
device/smsc9512/etherInit.c: * SMSC LAN9512-specific notes:  This function returns ::OK if the Ethernet
device/smsc9512/etherInit.c: * This is a work-around to use USB's dynamic device model at the same time as
device/smsc9512/etherInit.c:    ethptr = &ethertab[devptr->minor];
device/smsc9512/etherInit.c:    ethptr->dev = devptr;
device/smsc9512/etherInit.c:    ethptr->state = ETH_STATE_DOWN;
device/smsc9512/etherInit.c:    ethptr->mtu = ETH_MTU;
device/smsc9512/etherInit.c:    ethptr->addressLength = ETH_ADDR_LEN;
device/smsc9512/etherInit.c:    ethptr->isema = semcreate(0);
device/smsc9512/etherInit.c:    if (isbadsem(ethptr->isema))
device/smsc9512/etherInit.c:    smsc9512_attached[devptr->minor] = semcreate(0);
device/smsc9512/etherInit.c:    if (isbadsem(smsc9512_attached[devptr->minor]))
device/smsc9512/etherInit.c:    randomEthAddr(ethptr->devAddress);
device/smsc9512/etherInit.c:    semfree(smsc9512_attached[devptr->minor]);
device/smsc9512/etherInit.c:    semfree(ethptr->isema);
device/smsc9512/etherInterrupt.c: * LAN9512 cannot actually issue an interrupt by itself--- what actually happens
device/smsc9512/etherInterrupt.c:    struct ether *ethptr = req->private;
device/smsc9512/etherInterrupt.c:    ethptr->txirq++;
device/smsc9512/etherInterrupt.c:    usb_dev_debug(req->dev, "SMSC9512: Tx complete\n");
device/smsc9512/etherInterrupt.c: * new packets).  It then must re-submit the USB bulk transfer request so that
device/smsc9512/etherInterrupt.c:    struct ether *ethptr = req->private;
device/smsc9512/etherInterrupt.c:    ethptr->rxirq++;
device/smsc9512/etherInterrupt.c:    if (req->status == USB_STATUS_SUCCESS)
device/smsc9512/etherInterrupt.c:        for (data = req->recvbuf, edata = req->recvbuf + req->actual_size;
device/smsc9512/etherInterrupt.c:                (frame_length + SMSC9512_RX_OVERHEAD > edata - data) ||
device/smsc9512/etherInterrupt.c:                usb_dev_debug(req->dev, "SMSC9512: Tallying rx error "
device/smsc9512/etherInterrupt.c:                ethptr->errors++;
device/smsc9512/etherInterrupt.c:            else if (ethptr->icount == ETH_IBLEN)
device/smsc9512/etherInterrupt.c:                usb_dev_debug(req->dev, "SMSC9512: Tallying overrun\n");
device/smsc9512/etherInterrupt.c:                ethptr->ovrrun++;
device/smsc9512/etherInterrupt.c:                pkt = bufget(ethptr->inPool);
device/smsc9512/etherInterrupt.c:                pkt->buf = pkt->data = (uint8_t*)(pkt + 1);
device/smsc9512/etherInterrupt.c:                pkt->length = frame_length - ETH_CRC_LEN;
device/smsc9512/etherInterrupt.c:                memcpy(pkt->buf, data + SMSC9512_RX_OVERHEAD, pkt->length);
device/smsc9512/etherInterrupt.c:                ethptr->in[(ethptr->istart + ethptr->icount) % ETH_IBLEN] = pkt;
device/smsc9512/etherInterrupt.c:                ethptr->icount++;
device/smsc9512/etherInterrupt.c:                usb_dev_debug(req->dev, "SMSC9512: Receiving "
device/smsc9512/etherInterrupt.c:                              pkt->length, ethptr->icount);
device/smsc9512/etherInterrupt.c:                signal(ethptr->isema);
device/smsc9512/etherInterrupt.c:        usb_dev_debug(req->dev, "SMSC9512: USB Rx transfer failed\n");
device/smsc9512/etherInterrupt.c:        ethptr->errors++;
device/smsc9512/etherInterrupt.c:    usb_dev_debug(req->dev, "SMSC9512: Re-submitting USB Rx request\n");
device/smsc9512/etherOpen.c: * SMSC LAN9512-specific notes:  as a work-around to use USB's dynamic device
device/smsc9512/etherOpen.c: * occur, even if the device is non-removable.
device/smsc9512/etherOpen.c:    if (smsc9512_wait_device_attached(devptr->minor) != USB_STATUS_SUCCESS)
device/smsc9512/etherOpen.c:    ethptr = &ethertab[devptr->minor];
device/smsc9512/etherOpen.c:    if (ethptr->state != ETH_STATE_DOWN)
device/smsc9512/etherOpen.c:    ethptr->outPool = bfpalloc(sizeof(struct usb_xfer_request) + ETH_MAX_PKT_LEN +
device/smsc9512/etherOpen.c:    if (ethptr->outPool == SYSERR)
device/smsc9512/etherOpen.c:    ethptr->inPool = bfpalloc(sizeof(struct ethPktBuffer) + ETH_MAX_PKT_LEN,
device/smsc9512/etherOpen.c:    if (ethptr->inPool == SYSERR)
device/smsc9512/etherOpen.c:    udev = ethptr->csr;
device/smsc9512/etherOpen.c:    if (smsc9512_set_mac_address(udev, ethptr->devAddress) != USB_STATUS_SUCCESS)
device/smsc9512/etherOpen.c:            req = bufget(ethptr->outPool);
device/smsc9512/etherOpen.c:            req->dev = udev;
device/smsc9512/etherOpen.c:            req->endpoint_desc = udev->endpoints[0][1];
device/smsc9512/etherOpen.c:            req->sendbuf = (uint8_t*)req + sizeof(struct usb_xfer_request);
device/smsc9512/etherOpen.c:            req->completion_cb_func = smsc9512_tx_complete;
device/smsc9512/etherOpen.c:            req->private = ethptr;
device/smsc9512/etherOpen.c:        req->dev = udev;
device/smsc9512/etherOpen.c:        req->endpoint_desc = udev->endpoints[0][0];
device/smsc9512/etherOpen.c:        req->completion_cb_func = smsc9512_rx_complete;
device/smsc9512/etherOpen.c:        req->private = ethptr;
device/smsc9512/etherOpen.c:    udev->last_error = USB_STATUS_SUCCESS;
device/smsc9512/etherOpen.c:    if (udev->last_error != USB_STATUS_SUCCESS)
device/smsc9512/etherOpen.c:    ethptr->state = ETH_STATE_UP;
device/smsc9512/etherOpen.c:    bfpfree(ethptr->inPool);
device/smsc9512/etherOpen.c:    bfpfree(ethptr->outPool);
device/smsc9512/etherRead.c:    ethptr = &ethertab[devptr->minor];
device/smsc9512/etherRead.c:    if (ethptr->state != ETH_STATE_UP)
device/smsc9512/etherRead.c:    /* Wait for received packet to be available in the ethptr->in circular
device/smsc9512/etherRead.c:    wait(ethptr->isema);
device/smsc9512/etherRead.c:    pkt = ethptr->in[ethptr->istart];
device/smsc9512/etherRead.c:    ethptr->istart = (ethptr->istart + 1) % ETH_IBLEN;
device/smsc9512/etherRead.c:    ethptr->icount--;
device/smsc9512/etherRead.c:    if (pkt->length < len)
device/smsc9512/etherRead.c:        len = pkt->length;
device/smsc9512/etherRead.c:    memcpy(buf, pkt->buf, len);
device/smsc9512/etherStat.c:           ethptr->devAddress[0], ethptr->devAddress[1],
device/smsc9512/etherStat.c:           ethptr->devAddress[2], ethptr->devAddress[3],
device/smsc9512/etherStat.c:           ethptr->devAddress[4], ethptr->devAddress[5]);
device/smsc9512/etherStat.c:    printf("  MTU                   %u\n", ethptr->mtu);
device/smsc9512/etherStat.c:    switch (ethptr->state)
device/smsc9512/etherStat.c:    printf("  Rx packets in queue   %u\n",   ethptr->icount);
device/smsc9512/etherStat.c:    printf("  Rx errors             %lu\n",  ethptr->errors);
device/smsc9512/etherStat.c:    printf("  Rx overruns           %u\n",   ethptr->ovrrun);
device/smsc9512/etherStat.c:    printf("  Rx USB transfers done %lu\n",  ethptr->rxirq);
device/smsc9512/etherStat.c:    printf("  Tx USB transfers done %lu\n",  ethptr->txirq);
device/smsc9512/etherWrite.c:    ethptr = &ethertab[devptr->minor];
device/smsc9512/etherWrite.c:    if (ethptr->state != ETH_STATE_UP ||
device/smsc9512/etherWrite.c:    req = bufget(ethptr->outPool);
device/smsc9512/etherWrite.c:     * beginning that contain device-specific flags.  These two fields are
device/smsc9512/etherWrite.c:    sendbuf = req->sendbuf;
device/smsc9512/etherWrite.c:    req->size = len + SMSC9512_TX_OVERHEAD;
device/smsc9512/etherWrite.c:     * device-specific fields that were added). */
device/smsc9512/smsc9512.h: * vendor-specific class device attached to the hub that is the device we
device/smsc9512/smsc9512.h: * endpoint) must be prefixed with an 8-byte header containing the "Tx command
device/smsc9512/smsc9512.h: * are prefixed with a 4-byte Rx Status word containing the flags below.  A
device/smsc9512/smsc9512.h: * word and padded to a 4-byte boundary.
device/smsc9512/smsc9512.h:/** Rx packet offset:  Software can modify this 2-bit field to cause Rx packets
device/smsc9512/smsc9512.h: * 0-based.  SMSC's Linux driver changes this to 0x2000, or a delay of about 139
device/smsc9512/smsc9512.h:/* Vendor-specific PHY Definitions */
device/smsc9512/smsc9512.h: * register on the SMSC LAN9512.  bmRequestType must specify a vendor-specific
device/smsc9512/smsc9512.h: * request in the host-to-device direction, wIndex must specify the offset of
device/smsc9512/smsc9512.h: * register from the SMSC LAN9512.  bmRequestType must specify a vendor-specific
device/smsc9512/smsc9512.h: * request in the device-to-host direction, wIndex must specify the offset of
device/smsc9512/smsc9512.h: * the register, and the transfer data must be a 4-byte location in which to
device/smsc9512/#smsc9512.c#:       CMacaddrx:;[] = (AddrlCCCC >> 16-zexit) & 0xffxcc;
Binary file device/smsc9512/.smsc9512.h.swo matches
device/tcp/tcpChksum.c:    pseu = (struct tcpPseudo *)(pkt->curr - TCP_PSEUDO_LEN);
device/tcp/tcpChksum.c:    memcpy(pseu->srcIp, src->addr, IPv4_ADDR_LEN);
device/tcp/tcpChksum.c:    memcpy(pseu->dstIp, dst->addr, IPv4_ADDR_LEN);
device/tcp/tcpChksum.c:    pseu->zero = 0;
device/tcp/tcpChksum.c:    pseu->proto = IPv4_PROTO_TCP;
device/tcp/tcpChksum.c:    pseu->len = hs2net(len);
device/tcp/tcpClose.c:    tcbptr = &tcptab[devptr->minor];
device/tcp/tcpClose.c:    wait(tcbptr->mutex);
device/tcp/tcpClose.c:    switch (tcbptr->state)
device/tcp/tcpClose.c:        tcbptr->devstate = TCP_FREE;
device/tcp/tcpClose.c:        signal(tcbptr->mutex);
device/tcp/tcpClose.c:        if (semcount(tcbptr->writers) < 0)
device/tcp/tcpClose.c:            signaln(tcbptr->writers, semcount(tcbptr->writers) * -1);
device/tcp/tcpClose.c:        if (semcount(tcbptr->readers) < 0)
device/tcp/tcpClose.c:            signaln(tcbptr->readers, semcount(tcbptr->readers) * -1);
device/tcp/tcpClose.c:        tcbptr->sndfin = seqadd(tcbptr->snduna, tcbptr->ocount);
device/tcp/tcpClose.c:        tcbptr->sndflg |= TCP_FLG_FIN;
device/tcp/tcpClose.c:        if (0 == tcbptr->ocount)
device/tcp/tcpClose.c:            tcbptr->sndflg |= TCP_FLG_SNDDATA;
device/tcp/tcpClose.c:            tcbptr->state = TCP_FINWT1;
device/tcp/tcpClose.c:        tcbptr->sndfin = seqadd(tcbptr->snduna, tcbptr->ocount);
device/tcp/tcpClose.c:        tcbptr->sndflg |= TCP_FLG_FIN;
device/tcp/tcpClose.c:        tcbptr->sndflg |= TCP_FLG_SNDDATA;
device/tcp/tcpClose.c:        tcbptr->state = TCP_FINWT1;
device/tcp/tcpClose.c:        tcbptr->sndfin = seqadd(tcbptr->snduna, tcbptr->ocount);
device/tcp/tcpClose.c:        tcbptr->sndflg |= TCP_FLG_FIN;
device/tcp/tcpClose.c:        tcbptr->sndflg |= TCP_FLG_SNDDATA;
device/tcp/tcpClose.c:        tcbptr->state = TCP_LASTACK;
device/tcp/tcpClose.c:        signal(tcbptr->mutex);
device/tcp/tcpClose.c:    if (tcbptr->sndflg & TCP_FLG_SNDDATA)
device/tcp/tcpClose.c:    signal(tcbptr->mutex);
device/tcp/tcpClose.c:    wait(tcbptr->openclose);
device/tcp/tcpControl.c:    tcbptr = &tcptab[devptr->minor];
device/tcp/tcpControl.c:    wait(tcbptr->mutex);
device/tcp/tcpControl.c:        bytes = tcbptr->obytes;
device/tcp/tcpControl.c:        signal(tcbptr->mutex);
device/tcp/tcpControl.c:        bytes = tcbptr->ibytes;
device/tcp/tcpControl.c:        signal(tcbptr->mutex);
device/tcp/tcpControl.c:        signal(tcbptr->mutex);
device/tcp/tcpControl.c:    signal(tcbptr->mutex);
device/tcp/tcpFree.c:    if (TCP_CLOSED == tcbptr->state)
device/tcp/tcpFree.c:        signal(tcbptr->mutex);
device/tcp/tcpFree.c:    temp = tcbptr->mutex;
device/tcp/tcpFree.c:    semfree(tcbptr->openclose);
device/tcp/tcpFree.c:    semfree(tcbptr->readers);
device/tcp/tcpFree.c:    semfree(tcbptr->writers);
device/tcp/tcpFree.c:    tcbptr->state = TCP_CLOSED;
device/tcp/tcpFree.c:    tcbptr->devstate = TCP_FREE;
device/tcp/tcpFree.c:    tcbptr->mutex = temp;
device/tcp/tcpFree.c:    signal(tcbptr->mutex);
device/tcp/tcpInit.c:    tcbptr = &tcptab[devptr->minor];
device/tcp/tcpInit.c:    tcbptr->state = TCP_CLOSED;
device/tcp/tcpInit.c:    tcbptr->devstate = TCP_FREE;
device/tcp/tcpInit.c:    tcbptr->mutex = semcreate(1);
device/tcp/tcpInit.c:    if (SYSERR == (int)tcbptr->mutex)
device/tcp/tcpOpen.c: *           4th argument is the local port (auto-assigned if zero)
device/tcp/tcpOpen.c:    tcbptr = &tcptab[devptr->minor];
device/tcp/tcpOpen.c:    wait(tcbptr->mutex);
device/tcp/tcpOpen.c:    tcbptr->devstate = TCP_ALLOC;
device/tcp/tcpOpen.c:    if ((tcbptr->state != TCP_CLOSED) && (tcbptr->state != TCP_LISTEN))
device/tcp/tcpOpen.c:        signal(tcbptr->mutex);
device/tcp/tcpOpen.c:        tcbptr->devstate = TCP_FREE;
device/tcp/tcpOpen.c:        signal(tcbptr->mutex);
device/tcp/tcpOpen.c:    tcbptr->dev = devptr->num;
device/tcp/tcpOpen.c:    tcbptr->localpt = localpt;
device/tcp/tcpOpen.c:    netaddrcpy(&tcbptr->localip, localip);
device/tcp/tcpOpen.c:    tcbptr->remotept = remotept;
device/tcp/tcpOpen.c:        tcbptr->remoteip.type = NULL;
device/tcp/tcpOpen.c:        netaddrcpy(&tcbptr->remoteip, remoteip);
device/tcp/tcpOpen.c:    tcbptr->opentype = mode;
device/tcp/tcpOpen.c:        tcbptr->state = TCP_LISTEN;
device/tcp/tcpOpen.c:    signal(tcbptr->mutex);
device/tcp/tcpOpen.c:    wait(tcbptr->openclose);    /* Wait for connection open */
device/tcp/tcpOpen.c:    nextport = (nextport + 1) % (TCP_PMAX - TCP_PSTART);
device/tcp/tcpOpen.c:            nextport = (nextport + 1) % (TCP_PMAX - TCP_PSTART);
device/tcp/tcpOpenActive.c: * @pre-condition TCB mutex is already held
device/tcp/tcpOpenActive.c: * @post-condition TCB mutex is still held
device/tcp/tcpOpenActive.c:    if ((NULL == tcbptr->remotept) || (NULL == tcbptr->remoteip.type)
device/tcp/tcpOpenActive.c:        || (NULL == tcbptr->localip.type))
device/tcp/tcpOpenActive.c:    tcbptr->state = TCP_SYNSENT;
device/tcp/tcpRead.c:    tcbptr = &tcptab[devptr->minor];
device/tcp/tcpRead.c:    wait(tcbptr->mutex);
device/tcp/tcpRead.c:    signal(tcbptr->mutex);
device/tcp/tcpRead.c:        wait(tcbptr->readers);
device/tcp/tcpRead.c:        wait(tcbptr->mutex);
device/tcp/tcpRead.c:        while ((tcbptr->icount > 0) && (count < len))
device/tcp/tcpRead.c:            *buffer++ = tcbptr->in[tcbptr->istart];
device/tcp/tcpRead.c:            tcbptr->imark[tcbptr->istart] = FALSE;
device/tcp/tcpRead.c:            tcbptr->istart = (tcbptr->istart + 1) % TCP_IBLEN;
device/tcp/tcpRead.c:            tcbptr->icount--;
device/tcp/tcpRead.c:        if (seqlte(tcbptr->rcvwnd, tcbptr->rcvnxt))
device/tcp/tcpRead.c:        if ((tcbptr->icount > 0) && (semcount(tcbptr->readers) < 1))
device/tcp/tcpRead.c:            signal(tcbptr->readers);
device/tcp/tcpRead.c:        signal(tcbptr->mutex);
device/tcp/tcpRead.c:    switch (tcbptr->state)
device/tcp/tcpRead.c:        signal(tcbptr->mutex);
device/tcp/tcpRead.c:        if (tcbptr->icount > 0)
device/tcp/tcpRead.c:        signal(tcbptr->mutex);
device/tcp/tcpRecv.c:    tcp = (struct tcpPkt *)pkt->curr;
device/tcp/tcpRecv.c:    tcplen = pkt->len - (pkt->curr - pkt->linkhdr);
device/tcp/tcpRecv.c:    tcp->srcpt = net2hs(tcp->srcpt);
device/tcp/tcpRecv.c:    tcp->dstpt = net2hs(tcp->dstpt);
device/tcp/tcpRecv.c:    tcp->seqnum = net2hl(tcp->seqnum);
device/tcp/tcpRecv.c:    tcp->acknum = net2hl(tcp->acknum);
device/tcp/tcpRecv.c:    tcp->window = net2hs(tcp->window);
device/tcp/tcpRecv.c:    tcp->urgent = net2hs(tcp->urgent);
device/tcp/tcpRecv.c:    TCP_TRACE("RECV <C=0x%02X><S=%u><A=%u><dl=%u><w=%u>", tcp->control,
device/tcp/tcpRecv.c:              tcp->seqnum, tcp->acknum, tcpSeglen(tcp, tcplen),
device/tcp/tcpRecv.c:              tcp->window);
device/tcp/tcpRecv.c:    tcbptr = tcpDemux(tcp->dstpt, tcp->srcpt, dst, src);
device/tcp/tcpRecv.c:    wait(tcbptr->mutex);
device/tcp/tcpRecv.c:    if (TCP_CLOSED == tcbptr->state)
device/tcp/tcpRecv.c:        signal(tcbptr->mutex);
device/tcp/tcpRecv.c:    switch (tcbptr->state)
device/tcp/tcpRecv.c:    if (tcbptr->sndflg & TCP_FLG_SNDRST)
device/tcp/tcpRecv.c:    signal(tcbptr->mutex);
device/tcp/tcpRecvAck.c:    tcp = (struct tcpPkt *)pkt->curr;
device/tcp/tcpRecvAck.c:    if (seqlt(tcbptr->snduna, tcp->acknum)
device/tcp/tcpRecvAck.c:        && seqlte(tcp->acknum, tcbptr->sndnxt))
device/tcp/tcpRecvAck.c:        amt = tcpSeqdiff(tcp->acknum, tcbptr->snduna);
device/tcp/tcpRecvAck.c:        if ((tcbptr->sndflg & TCP_FLG_SYN)
device/tcp/tcpRecvAck.c:            && (tcbptr->snduna == tcbptr->iss))
device/tcp/tcpRecvAck.c:            amt--;
device/tcp/tcpRecvAck.c:        if ((tcbptr->sndflg & TCP_FLG_FIN)
device/tcp/tcpRecvAck.c:            && (seqlt(tcbptr->sndfin, tcp->acknum)))
device/tcp/tcpRecvAck.c:            amt--;
device/tcp/tcpRecvAck.c:        tcbptr->ostart = (tcbptr->ostart + amt) % TCP_OBLEN;
device/tcp/tcpRecvAck.c:        tcbptr->ocount -= amt;
device/tcp/tcpRecvAck.c:        tcbptr->obytes += amt;
device/tcp/tcpRecvAck.c:        if (tcbptr->ocount < TCP_OBLEN)
device/tcp/tcpRecvAck.c:            signal(tcbptr->writers);
device/tcp/tcpRecvAck.c:        tcbptr->snduna = tcp->acknum;
device/tcp/tcpRecvAck.c:        tcbptr->rxtcount = 0;
device/tcp/tcpRecvAck.c:        if (seqlt(tcbptr->snduna, tcbptr->sndnxt))
device/tcp/tcpRecvAck.c:            tcpTimerSched(tcbptr->rxttime, tcbptr, TCP_EVT_RXT);
device/tcp/tcpRecvAck.c:        tcbptr->sndflg |= TCP_FLG_SNDDATA;
device/tcp/tcpRecvAck.c:    if (seqlt(tcbptr->sndwl1, tcp->seqnum)
device/tcp/tcpRecvAck.c:        || ((tcbptr->sndwl1 == tcp->seqnum)
device/tcp/tcpRecvAck.c:            && seqlte(tcbptr->sndwl2, tcp->acknum)))
device/tcp/tcpRecvAck.c:        oldend = seqadd(tcbptr->sndwl2, tcbptr->sndwnd);
device/tcp/tcpRecvAck.c:        newend = seqadd(tcp->acknum, tcp->window);
device/tcp/tcpRecvAck.c:        tcbptr->sndwnd = tcp->window;
device/tcp/tcpRecvAck.c:        tcbptr->sndwl1 = tcp->seqnum;
device/tcp/tcpRecvAck.c:        tcbptr->sndwl2 = tcp->acknum;
device/tcp/tcpRecvAck.c:            tcbptr->sndflg &= ~TCP_FLG_PERSIST;
device/tcp/tcpRecvAck.c:            tcbptr->sndflg |= TCP_FLG_SNDDATA;
device/tcp/tcpRecvAck.c:    if (seqlt(tcbptr->sndnxt, tcp->acknum))
device/tcp/tcpRecvAck.c:        tcbptr->sndflg |= TCP_FLG_SNDACK;
device/tcp/tcpRecvData.c: * Function based on RFC 763, pg 73-76.
device/tcp/tcpRecvData.c: * @pre-condition TCB mutex is already held
device/tcp/tcpRecvData.c: * @post-condition TCB mutex is still held
device/tcp/tcpRecvData.c:    tcp = (struct tcpPkt *)pkt->curr;
device/tcp/tcpRecvData.c:    tcplen = pkt->len - (pkt->curr - pkt->linkhdr);
device/tcp/tcpRecvData.c:        switch (tcbptr->state)
device/tcp/tcpRecvData.c:            data = (uchar *)tcp + offset2octets(tcp->offset);
device/tcp/tcpRecvData.c:            if (seqlt(tcp->seqnum, tcbptr->rcvnxt))
device/tcp/tcpRecvData.c:                offset = tcpSeqdiff(tcbptr->rcvnxt, tcp->seqnum);
device/tcp/tcpRecvData.c:                seglen -= offset;
device/tcp/tcpRecvData.c:                start = tcbptr->inxt;
device/tcp/tcpRecvData.c:                offset = tcpSeqdiff(tcp->seqnum, tcbptr->rcvnxt);
device/tcp/tcpRecvData.c:                start = (tcbptr->inxt + offset) % TCP_IBLEN;
device/tcp/tcpRecvData.c:            window = tcpSeqdiff(tcbptr->rcvwnd, tcbptr->rcvnxt);
device/tcp/tcpRecvData.c:            window -= offset;
device/tcp/tcpRecvData.c:                tcp->control &= ~TCP_CTRL_FIN;
device/tcp/tcpRecvData.c:                tcbptr->in[index] = data[i];
device/tcp/tcpRecvData.c:                tcbptr->imark[index] = TRUE;
device/tcp/tcpRecvData.c:            if (start == tcbptr->inxt)
device/tcp/tcpRecvData.c:                tcbptr->icount += seglen;
device/tcp/tcpRecvData.c:                tcbptr->ibytes += seglen;
device/tcp/tcpRecvData.c:                tcbptr->inxt = (tcbptr->inxt + seglen) % TCP_IBLEN;
device/tcp/tcpRecvData.c:                tcbptr->rcvnxt = seqadd(tcbptr->rcvnxt, seglen);
device/tcp/tcpRecvData.c:                while ((tcbptr->icount < TCP_IBLEN)
device/tcp/tcpRecvData.c:                       && (tcbptr->imark[tcbptr->inxt]))
device/tcp/tcpRecvData.c:                    tcbptr->icount++;
device/tcp/tcpRecvData.c:                    tcbptr->ibytes++;
device/tcp/tcpRecvData.c:                    tcbptr->inxt = (tcbptr->inxt + 1) % TCP_IBLEN;
device/tcp/tcpRecvData.c:                    tcbptr->rcvnxt = seqadd(tcbptr->rcvnxt, 1);
device/tcp/tcpRecvData.c:                    if ((tcbptr->rcvflg & TCP_FLG_FIN)
device/tcp/tcpRecvData.c:                        && (tcbptr->rcvnxt == tcbptr->rcvfin))
device/tcp/tcpRecvData.c:                        tcp->control |= TCP_CTRL_FIN;
device/tcp/tcpRecvData.c:                if (semcount(tcbptr->readers) < 1)
device/tcp/tcpRecvData.c:                    signal(tcbptr->readers);
device/tcp/tcpRecvData.c:                tcbptr->sndflg |= TCP_FLG_SNDACK;
device/tcp/tcpRecvData.c:    if (tcp->control & TCP_CTRL_FIN)
device/tcp/tcpRecvData.c:        if (!(tcbptr->rcvflg & TCP_FLG_FIN))
device/tcp/tcpRecvData.c:            tcbptr->rcvfin = seqadd(tcp->seqnum, seglen);
device/tcp/tcpRecvData.c:            tcbptr->rcvflg |= TCP_FLG_FIN;
device/tcp/tcpRecvData.c:        if (tcbptr->rcvnxt == tcbptr->rcvfin)
device/tcp/tcpRecvData.c:            TCP_TRACE("Process FIN, state %d", tcbptr->state);
device/tcp/tcpRecvData.c:            if (semcount(tcbptr->readers) < 0)
device/tcp/tcpRecvData.c:                signaln(tcbptr->readers, semcount(tcbptr->readers) * -1);
device/tcp/tcpRecvData.c:            switch (tcbptr->state)
device/tcp/tcpRecvData.c:                tcbptr->rcvnxt = seqadd(tcbptr->rcvnxt, 1);
device/tcp/tcpRecvData.c:                tcbptr->state = TCP_CLOSEWT;
device/tcp/tcpRecvData.c:                tcbptr->rcvnxt = seqadd(tcbptr->rcvnxt, 1);
device/tcp/tcpRecvData.c:                if (seqlt(tcbptr->sndfin, tcbptr->snduna))
device/tcp/tcpRecvData.c:                    tcbptr->state = TCP_TIMEWT;
device/tcp/tcpRecvData.c:                    tcbptr->state = TCP_CLOSING;
device/tcp/tcpRecvData.c:                tcbptr->rcvnxt = seqadd(tcbptr->rcvnxt, 1);
device/tcp/tcpRecvData.c:                tcbptr->sndflg |= TCP_FLG_SNDACK;
device/tcp/tcpRecvData.c:            tcbptr->sndflg |= TCP_FLG_SNDACK;
device/tcp/tcpRecvData.c:    if (tcbptr->sndflg & TCP_FLG_SNDDATA)
device/tcp/tcpRecvData.c:    if (tcbptr->sndflg & TCP_FLG_SNDACK)
device/tcp/tcpRecvListen.c: * @pre-condition TCB mutex is already held
device/tcp/tcpRecvListen.c:    tcp = (struct tcpPkt *)pkt->curr;
device/tcp/tcpRecvListen.c:    if (tcp->control & TCP_CTRL_RST)
device/tcp/tcpRecvListen.c:    if (tcp->control & TCP_CTRL_ACK)
device/tcp/tcpRecvListen.c:        tcbptr->sndflg |= TCP_FLG_SNDRST;
device/tcp/tcpRecvListen.c:    if (tcp->control & TCP_CTRL_SYN)
device/tcp/tcpRecvListen.c:        tcbptr->rcvnxt = seqadd(tcp->seqnum, 1);
device/tcp/tcpRecvListen.c:        tcbptr->rcvwnd = seqadd(tcp->seqnum, TCP_INIT_WND);
device/tcp/tcpRecvListen.c:        tcbptr->rcvflg |= TCP_FLG_SYN;
device/tcp/tcpRecvListen.c:        tcbptr->sndflg |= TCP_FLG_SNDACK;
device/tcp/tcpRecvListen.c:        if (NULL == tcbptr->remotept)
device/tcp/tcpRecvListen.c:            tcbptr->remotept = tcp->srcpt;
device/tcp/tcpRecvListen.c:        if (NULL == tcbptr->remoteip.type)
device/tcp/tcpRecvListen.c:            netaddrcpy(&tcbptr->remoteip, src);
device/tcp/tcpRecvListen.c:        tcbptr->sndwnd = tcp->window;
device/tcp/tcpRecvListen.c:        tcbptr->sndwl1 = tcp->seqnum;
device/tcp/tcpRecvListen.c:        if (tcbptr->sndflg & TCP_FLG_SNDACK)
device/tcp/tcpRecvListen.c:        tcbptr->state = TCP_SYNRECV;
device/tcp/tcpRecvOpts.c: * @pre-condition TCB mutex is already held
device/tcp/tcpRecvOpts.c: * @post-condition TCB mutex is still held
device/tcp/tcpRecvOpts.c:    tcp = (struct tcpPkt *)pkt->curr;
device/tcp/tcpRecvOpts.c:    if (offset2octets(tcp->offset) == TCP_HDR_LEN)
device/tcp/tcpRecvOpts.c:    options = tcp->data;
device/tcp/tcpRecvOpts.c:    endopt = options + (offset2octets(tcp->offset) - TCP_HDR_LEN);
device/tcp/tcpRecvOpts.c:             * TODO: add test case with non-word aligned opts
device/tcp/tcpRecvOpts.c:            tcbptr->sndmss = *options++;
device/tcp/tcpRecvOpts.c:            tcbptr->sndmss += *options++ << 8;
device/tcp/tcpRecvOpts.c:            tcbptr->sndmss -= TCP_HDR_LEN;
device/tcp/tcpRecvOther.c: * Function based on RFC 763, pg 69-73.
device/tcp/tcpRecvOther.c: * @pre-condition TCB mutex is already held
device/tcp/tcpRecvOther.c: * @post-condition TCB mutex is still held
device/tcp/tcpRecvOther.c:    tcp = (struct tcpPkt *)pkt->curr;
device/tcp/tcpRecvOther.c:        if (tcp->control & TCP_CTRL_RST)
device/tcp/tcpRecvOther.c:    if (tcp->control & TCP_CTRL_RST)
device/tcp/tcpRecvOther.c:        switch (tcbptr->state)
device/tcp/tcpRecvOther.c:            tcbptr->rxtcount = 0;
device/tcp/tcpRecvOther.c:            if (TCP_PASSIVE == tcbptr->opentype)
device/tcp/tcpRecvOther.c:                tcbptr->state = TCP_LISTEN;
device/tcp/tcpRecvOther.c:    if (tcp->control & TCP_CTRL_SYN)
device/tcp/tcpRecvOther.c:        tcbptr->sndflg |= TCP_FLG_SNDRST;
device/tcp/tcpRecvOther.c:    if (!(tcp->control & TCP_CTRL_ACK))
device/tcp/tcpRecvOther.c:    switch (tcbptr->state)
device/tcp/tcpRecvOther.c:        if (seqlte(tcbptr->snduna, tcp->acknum)
device/tcp/tcpRecvOther.c:            && seqlte(tcp->acknum, tcbptr->sndnxt))
device/tcp/tcpRecvOther.c:            tcbptr->state = TCP_ESTAB;
device/tcp/tcpRecvOther.c:            signal(tcbptr->openclose);  /* Signal connection open */
device/tcp/tcpRecvOther.c:            tcbptr->sndflg |= TCP_FLG_SNDRST;
device/tcp/tcpRecvOther.c:        if (seqlte(tcbptr->sndfin, tcbptr->snduna))
device/tcp/tcpRecvOther.c:            signal(tcbptr->openclose);
device/tcp/tcpRecvOther.c:            tcbptr->state = TCP_FINWT2;
device/tcp/tcpRecvOther.c:            signal(tcbptr->openclose);
device/tcp/tcpRecvOther.c:        if (seqlte(tcbptr->sndfin, tcbptr->snduna))
device/tcp/tcpRecvOther.c:            signal(tcbptr->openclose);
device/tcp/tcpRecvOther.c:            tcbptr->state = TCP_FINWT2;
device/tcp/tcpRecvOther.c:        if (seqlte(tcbptr->sndfin, tcbptr->snduna))
device/tcp/tcpRecvOther.c:            signal(tcbptr->openclose);
device/tcp/tcpRecvRtt.c:    if ((rtt != SYSERR) && (0 == tcbptr->rxtcount))
device/tcp/tcpRecvRtt.c:        if (0 == tcbptr->sndrtt)
device/tcp/tcpRecvRtt.c:            tcbptr->sndrtt = rtt << 3;
device/tcp/tcpRecvRtt.c:        delta = rtt - (tcbptr->sndrtt >> 3);
device/tcp/tcpRecvRtt.c:        tcbptr->sndrtt += delta;
device/tcp/tcpRecvRtt.c:        tcbptr->sndrtd += delta - (tcbptr->sndrtd >> 2);
device/tcp/tcpRecvRtt.c:        tcbptr->rxttime = ((tcbptr->sndrtt >> 2) + tcbptr->sndrtd) >> 1;
device/tcp/tcpRecvRtt.c:        if (tcbptr->rxttime < TCP_RXT_MINTIME)
device/tcp/tcpRecvRtt.c:            tcbptr->rxttime = TCP_RXT_MINTIME;
device/tcp/tcpRecvRtt.c:    if (tcbptr->sndcwn < tcbptr->sndsst)
device/tcp/tcpRecvRtt.c:        tcbptr->sndcwn += tcbptr->sndmss;
device/tcp/tcpRecvRtt.c:        tcbptr->sndcwn +=
device/tcp/tcpRecvRtt.c:            (tcbptr->sndmss * tcbptr->sndmss) / tcbptr->sndcwn;
device/tcp/tcpRecvSynsent.c: * Function based on RFC 763, pg 66-68.
device/tcp/tcpRecvSynsent.c: * @pre-condition TCB mutex is already held
device/tcp/tcpRecvSynsent.c:    tcp = (struct tcpPkt *)pkt->curr;
device/tcp/tcpRecvSynsent.c:    if (tcp->control & TCP_CTRL_ACK)
device/tcp/tcpRecvSynsent.c:        if (seqlte(tcp->acknum, tcbptr->iss)
device/tcp/tcpRecvSynsent.c:            || seqlt(tcbptr->sndnxt, tcp->acknum))
device/tcp/tcpRecvSynsent.c:            if (!(tcp->control & TCP_CTRL_RST))
device/tcp/tcpRecvSynsent.c:                tcbptr->sndflg |= TCP_FLG_SNDRST;
device/tcp/tcpRecvSynsent.c:        if (seqlte(tcbptr->snduna, tcp->acknum)
device/tcp/tcpRecvSynsent.c:            && seqlte(tcp->acknum, tcbptr->sndnxt))
device/tcp/tcpRecvSynsent.c:    if (tcp->control & TCP_CTRL_RST)
device/tcp/tcpRecvSynsent.c:    if (tcp->control & TCP_CTRL_SYN)
device/tcp/tcpRecvSynsent.c:        tcbptr->sndwnd = tcp->window;
device/tcp/tcpRecvSynsent.c:        tcbptr->sndwl1 = tcp->seqnum;
device/tcp/tcpRecvSynsent.c:        tcbptr->rcvnxt = seqadd(tcp->seqnum, 1);
device/tcp/tcpRecvSynsent.c:        tcbptr->rcvwnd = seqadd(tcp->seqnum, TCP_INIT_WND);
device/tcp/tcpRecvSynsent.c:        tcbptr->rcvflg |= TCP_FLG_SYN;
device/tcp/tcpRecvSynsent.c:        tcbptr->sndflg |= TCP_FLG_SNDACK;
device/tcp/tcpRecvSynsent.c:            tcbptr->snduna = tcp->acknum;
device/tcp/tcpRecvSynsent.c:            tcbptr->sndwl2 = tcp->acknum;
device/tcp/tcpRecvSynsent.c:        tcbptr->rxtcount = 0;
device/tcp/tcpRecvSynsent.c:        if (seqlt(tcbptr->snduna, tcbptr->sndnxt))
device/tcp/tcpRecvSynsent.c:            tcpTimerSched(tcbptr->rxttime, tcbptr, TCP_EVT_RXT);
device/tcp/tcpRecvSynsent.c:        if (seqlt(tcbptr->iss, tcbptr->snduna))
device/tcp/tcpRecvSynsent.c:            tcbptr->state = TCP_ESTAB;
device/tcp/tcpRecvSynsent.c:            signal(tcbptr->openclose);  /* Signal connection open */
device/tcp/tcpRecvSynsent.c:            tcbptr->sndflg |= TCP_FLG_SNDDATA;
device/tcp/tcpRecvSynsent.c:            tcbptr->state = TCP_SYNRECV;
device/tcp/tcpRecvSynsent.c:                    tcbptr->iss, tcbptr->rcvnxt, NULL, 1);
device/tcp/tcpRecvValid.c:    tcp = (struct tcpPkt *)pkt->curr;
device/tcp/tcpRecvValid.c:    tcplen = pkt->len - (pkt->curr - pkt->linkhdr);
device/tcp/tcpRecvValid.c:    availwnd = tcpSeqdiff(tcbptr->rcvwnd, tcbptr->rcvnxt);
device/tcp/tcpRecvValid.c:    if (tcp->control & TCP_CTRL_SYN)
device/tcp/tcpRecvValid.c:    if (tcp->control & TCP_CTRL_FIN)
device/tcp/tcpRecvValid.c:        result = (tcp->seqnum == tcbptr->rcvnxt);
device/tcp/tcpRecvValid.c:        result = seqlte(tcbptr->rcvnxt, tcp->seqnum);
device/tcp/tcpRecvValid.c:        result &= seqlt(tcp->seqnum, tcbptr->rcvwnd);
device/tcp/tcpRecvValid.c:     * RCVNXT =< SEGSEQ + SEGLEN - 1 < RCVWND */
device/tcp/tcpRecvValid.c:        result = seqlte(tcbptr->rcvnxt, tcp->seqnum);
device/tcp/tcpRecvValid.c:        result &= seqlt(tcp->seqnum, tcbptr->rcvwnd);
device/tcp/tcpRecvValid.c:        temp = seqadd(tcp->seqnum, seglen - 1);
device/tcp/tcpRecvValid.c:        resultB = seqlte(tcbptr->rcvnxt, temp);
device/tcp/tcpRecvValid.c:        resultB &= seqlt(temp, tcbptr->rcvwnd);
device/tcp/tcpRecvValid.c:        tcp->control &= ~(TCP_CTRL_PSH | TCP_CTRL_SYN | TCP_CTRL_FIN);
device/tcp/tcpRecvValid.c:        pkt->len -= seglen;
device/tcp/tcpSend.c: * @pre-condition TCB mutex is already held
device/tcp/tcpSend.c: * @post-condition TCB mutex is still held
device/tcp/tcpSend.c:        datalen--;
device/tcp/tcpSend.c:        datalen--;
device/tcp/tcpSend.c:    pkt->curr -= (tcplen + 0x7) & ~0x7;
device/tcp/tcpSend.c:    pkt->len = tcplen;
device/tcp/tcpSend.c:    tcp = (struct tcpPkt *)pkt->curr;
device/tcp/tcpSend.c:    tcp->srcpt = tcbptr->localpt;
device/tcp/tcpSend.c:    tcp->dstpt = tcbptr->remotept;
device/tcp/tcpSend.c:    tcp->seqnum = seqnum;
device/tcp/tcpSend.c:    tcp->acknum = acknum;
device/tcp/tcpSend.c:    tcp->offset = octets2offset(TCP_HDR_LEN + msslen);
device/tcp/tcpSend.c:    tcp->control = ctrl;
device/tcp/tcpSend.c:    tcp->window = tcpSendWindow(tcbptr);
device/tcp/tcpSend.c:    window = tcp->window;
device/tcp/tcpSend.c:    data = tcp->data;
device/tcp/tcpSend.c:        *((ushort *)data) = hs2net((tcbptr->rcvmss + TCP_HDR_LEN));
device/tcp/tcpSend.c:        for (i = (TCP_OPT_MSS_LEN % 4); i > 1; i--)
device/tcp/tcpSend.c:            *data++ = tcbptr->out[(datastart + i) % TCP_OBLEN];
device/tcp/tcpSend.c:    tcp->srcpt = hs2net(tcp->srcpt);
device/tcp/tcpSend.c:    tcp->dstpt = hs2net(tcp->dstpt);
device/tcp/tcpSend.c:    tcp->seqnum = hl2net(tcp->seqnum);
device/tcp/tcpSend.c:    tcp->acknum = hl2net(tcp->acknum);
device/tcp/tcpSend.c:    tcp->window = hs2net(tcp->window);
device/tcp/tcpSend.c:    tcp->urgent = hs2net(tcp->urgent);
device/tcp/tcpSend.c:    tcp->chksum = tcpChksum(pkt, tcplen, &tcbptr->localip,
device/tcp/tcpSend.c:                            &tcbptr->remoteip);
device/tcp/tcpSend.c:    result = ipv4Send(pkt, &tcbptr->localip, &tcbptr->remoteip,
device/tcp/tcpSendAck.c: * @pre-condition TCB mutex is already held
device/tcp/tcpSendAck.c: * @post-condition TCB mutex is still held
device/tcp/tcpSendAck.c:    tcbptr->sndflg &= ~TCP_FLG_SNDACK;
device/tcp/tcpSendAck.c:    return tcpSend(tcbptr, TCP_CTRL_ACK, tcbptr->sndnxt,
device/tcp/tcpSendAck.c:                   tcbptr->rcvnxt, 0, 0);
device/tcp/tcpSendData.c: * @pre-condition TCB mutex is already held
device/tcp/tcpSendData.c: * @post-condition TCB mutex is still held
device/tcp/tcpSendData.c:    if (tcbptr->sndmss == 0)
device/tcp/tcpSendData.c:    if ((tcbptr->sndflg & TCP_FLG_FIN)
device/tcp/tcpSendData.c:        && seqlt(tcbptr->sndfin, tcbptr->sndnxt))
device/tcp/tcpSendData.c:    if ((tcbptr->rxtcount > 0) || (tcbptr->sndflg & TCP_FLG_PERSIST))
device/tcp/tcpSendData.c:    if (0 == tcbptr->sndwnd)
device/tcp/tcpSendData.c:        tcbptr->sndflg |= TCP_FLG_PERSIST;
device/tcp/tcpSendData.c:        tcbptr->psttime = TCP_PST_INITTIME;
device/tcp/tcpSendData.c:        tcpTimerSched(tcbptr->psttime, tcbptr, TCP_EVT_PERSIST);
device/tcp/tcpSendData.c:    if (seqlte(seqadd(tcbptr->snduna, tcbptr->sndwnd), tcbptr->sndnxt))
device/tcp/tcpSendData.c:    pending = tcbptr->ocount;
device/tcp/tcpSendData.c:    if (tcbptr->sndflg & TCP_FLG_FIN)
device/tcp/tcpSendData.c:    wndused = tcpSeqdiff(tcbptr->sndnxt, tcbptr->snduna);
device/tcp/tcpSendData.c:        if (seqlt(tcbptr->snduna, tcbptr->sndnxt)
device/tcp/tcpSendData.c:            tcpTimerSched(tcbptr->rxttime, tcbptr, TCP_EVT_RXT);
device/tcp/tcpSendData.c:    if (pending > tcbptr->sndwnd)
device/tcp/tcpSendData.c:        tosend = tcbptr->sndwnd - wndused;
device/tcp/tcpSendData.c:        tosend = pending - wndused;
device/tcp/tcpSendData.c:        if (tcbptr->sndflg & TCP_FLG_FIN)
device/tcp/tcpSendData.c:    while (tosend > tcbptr->sndmss)
device/tcp/tcpSendData.c:        tcpSend(tcbptr, TCP_CTRL_ACK, tcbptr->sndnxt, tcbptr->rcvnxt,
device/tcp/tcpSendData.c:                (tcbptr->ostart + wndused) % TCP_OBLEN, tcbptr->sndmss);
device/tcp/tcpSendData.c:        tosend -= tcbptr->sndmss;
device/tcp/tcpSendData.c:        sent += tcbptr->sndmss;
device/tcp/tcpSendData.c:        wndused += tcbptr->sndmss;
device/tcp/tcpSendData.c:        tcbptr->sndnxt = seqadd(tcbptr->sndnxt, tcbptr->sndmss);
device/tcp/tcpSendData.c:    tcpSend(tcbptr, ctrl, tcbptr->sndnxt, tcbptr->rcvnxt,
device/tcp/tcpSendData.c:            (tcbptr->ostart + wndused) % TCP_OBLEN, tosend);
device/tcp/tcpSendData.c:    tcbptr->sndnxt = seqadd(tcbptr->sndnxt, tosend);
device/tcp/tcpSendData.c:        tcpTimerSched(tcbptr->rxttime, tcbptr, TCP_EVT_RXT);
device/tcp/tcpSendData.c:        tcbptr->sndflg &= ~TCP_FLG_SNDACK;
device/tcp/tcpSendData.c:    tcbptr->sndflg &= ~TCP_FLG_SNDDATA;
device/tcp/tcpSendPersist.c:    wait(tcbptr->mutex);
device/tcp/tcpSendPersist.c:    if (tcbptr->ocount <= 0)
device/tcp/tcpSendPersist.c:        tcbptr->sndflg &= ~TCP_FLG_PERSIST;
device/tcp/tcpSendPersist.c:        signal(tcbptr->mutex);
device/tcp/tcpSendPersist.c:    tcbptr->psttime = tcbptr->psttime << 1;
device/tcp/tcpSendPersist.c:    if (tcbptr->psttime > TCP_PST_MAXTIME)
device/tcp/tcpSendPersist.c:        tcbptr->psttime = TCP_PST_MAXTIME;
device/tcp/tcpSendPersist.c:    tcpTimerSched(tcbptr->psttime, tcbptr, TCP_EVT_PERSIST);
device/tcp/tcpSendPersist.c:    tosend = tcbptr->ocount;
device/tcp/tcpSendPersist.c:    if (tosend > tcbptr->sndmss)
device/tcp/tcpSendPersist.c:        tosend = tcbptr->sndmss;
device/tcp/tcpSendPersist.c:    tcpSend(tcbptr, TCP_CTRL_ACK, tcbptr->snduna, tcbptr->rcvnxt,
device/tcp/tcpSendPersist.c:            tcbptr->ostart, tosend);
device/tcp/tcpSendPersist.c:    signal(tcbptr->mutex);
device/tcp/tcpSendRst.c:    tcp = (struct tcpPkt *)pkt->curr;
device/tcp/tcpSendRst.c:    tcplen = pkt->len - (pkt->curr - pkt->linkhdr);
device/tcp/tcpSendRst.c:    if (tcp->control & TCP_CTRL_RST)
device/tcp/tcpSendRst.c:    out->curr -= TCP_HDR_LEN;
device/tcp/tcpSendRst.c:    out->len += TCP_HDR_LEN;
device/tcp/tcpSendRst.c:    outtcp = (struct tcpPkt *)out->curr;
device/tcp/tcpSendRst.c:    outtcp->srcpt = tcp->dstpt;
device/tcp/tcpSendRst.c:    outtcp->dstpt = tcp->srcpt;
device/tcp/tcpSendRst.c:    outtcp->offset = octets2offset(TCP_HDR_LEN);
device/tcp/tcpSendRst.c:    outtcp->control = TCP_CTRL_RST;
device/tcp/tcpSendRst.c:    if (tcp->control & TCP_CTRL_ACK)
device/tcp/tcpSendRst.c:        outtcp->seqnum = tcp->acknum;
device/tcp/tcpSendRst.c:        outtcp->seqnum = 0;
device/tcp/tcpSendRst.c:        outtcp->control |= TCP_CTRL_ACK;
device/tcp/tcpSendRst.c:    datalen = tcplen - offset2octets(tcp->offset);
device/tcp/tcpSendRst.c:    if (tcp->control & TCP_CTRL_SYN)
device/tcp/tcpSendRst.c:    if (tcp->control & TCP_CTRL_FIN)
device/tcp/tcpSendRst.c:    outtcp->acknum = tcp->seqnum + datalen;
device/tcp/tcpSendRst.c:    outtcp->srcpt = hs2net(outtcp->srcpt);
device/tcp/tcpSendRst.c:    outtcp->dstpt = hs2net(outtcp->dstpt);
device/tcp/tcpSendRst.c:    outtcp->seqnum = hl2net(outtcp->seqnum);
device/tcp/tcpSendRst.c:    outtcp->acknum = hl2net(outtcp->acknum);
device/tcp/tcpSendRst.c:    outtcp->window = hs2net(outtcp->window);
device/tcp/tcpSendRst.c:    outtcp->urgent = hs2net(outtcp->urgent);
device/tcp/tcpSendRst.c:    outtcp->chksum = tcpChksum(out, TCP_HDR_LEN, src, dst);
device/tcp/tcpSendRxt.c:    wait(tcbptr->mutex);
device/tcp/tcpSendRxt.c:    if ((!seqlt(tcbptr->snduna, tcbptr->sndnxt))
device/tcp/tcpSendRxt.c:        || (tcbptr->sndflg & TCP_FLG_PERSIST))
device/tcp/tcpSendRxt.c:        signal(tcbptr->mutex);
device/tcp/tcpSendRxt.c:    if (0 == tcbptr->rxtcount)
device/tcp/tcpSendRxt.c:    tcbptr->rxtcount++;
device/tcp/tcpSendRxt.c:    if (tcbptr->rxtcount > TCP_RXT_MAXCOUNT)
device/tcp/tcpSendRxt.c:    time = tcbptr->rxttime << tcbptr->rxtcount;
device/tcp/tcpSendRxt.c:    if ((tcbptr->sndflg & TCP_FLG_SYN) && (tcbptr->snduna == tcbptr->iss))
device/tcp/tcpSendRxt.c:        if (tcbptr->rcvflg & TCP_FLG_SYN)
device/tcp/tcpSendRxt.c:        tcpSend(tcbptr, control, tcbptr->snduna, tcbptr->rcvnxt, 0, 1);
device/tcp/tcpSendRxt.c:        signal(tcbptr->mutex);
device/tcp/tcpSendRxt.c:    pending = tcpSeqdiff(tcbptr->sndnxt, tcbptr->snduna);
device/tcp/tcpSendRxt.c:    if ((tcbptr->sndflg & TCP_FLG_FIN)
device/tcp/tcpSendRxt.c:        && seqlte(tcbptr->snduna, tcbptr->sndfin)
device/tcp/tcpSendRxt.c:        && seqlt(tcbptr->sndfin, tcbptr->sndnxt))
device/tcp/tcpSendRxt.c:    if (pending > tcbptr->sndmss)
device/tcp/tcpSendRxt.c:        tosend = tcbptr->sndmss;
device/tcp/tcpSendRxt.c:    tcpSend(tcbptr, control, tcbptr->snduna, tcbptr->rcvnxt,
device/tcp/tcpSendRxt.c:            tcbptr->ostart, tosend);
device/tcp/tcpSendRxt.c:        tcbptr->sndsst = tcbptr->sndcwn;
device/tcp/tcpSendRxt.c:    if (tcbptr->sndwnd < tcbptr->sndsst)
device/tcp/tcpSendRxt.c:        tcbptr->sndsst = tcbptr->sndwnd >> 1;
device/tcp/tcpSendRxt.c:        tcbptr->sndsst = tcbptr->sndsst >> 1;
device/tcp/tcpSendRxt.c:    if (tcbptr->sndsst < tcbptr->sndmss)
device/tcp/tcpSendRxt.c:        tcbptr->sndsst = tcbptr->sndmss;
device/tcp/tcpSendRxt.c:    tcbptr->sndcwn = tcbptr->sndmss;
device/tcp/tcpSendRxt.c:    signal(tcbptr->mutex);
device/tcp/tcpSendSyn.c: * @pre-condition TCB mutex is already held
device/tcp/tcpSendSyn.c: * @post-condition TCB mutex is still held
device/tcp/tcpSendSyn.c:    if (tcbptr->sndflg & TCP_FLG_SNDACK)
device/tcp/tcpSendSyn.c:        tcbptr->sndflg &= ~TCP_FLG_SNDACK;
device/tcp/tcpSendSyn.c:    if (SYSERR == tcpSend(tcbptr, control, tcbptr->sndnxt,
device/tcp/tcpSendSyn.c:                          tcbptr->rcvnxt, NULL, 1))
device/tcp/tcpSendSyn.c:    tcbptr->sndnxt++;
device/tcp/tcpSendSyn.c:    tcbptr->sndflg |= TCP_FLG_SYN;
device/tcp/tcpSendSyn.c:    if (SYSERR == tcpTimerSched(tcbptr->rxttime, tcbptr, TCP_EVT_RXT))
device/tcp/tcpSendWindow.c: * @pre-condition TCB mutex is already held
device/tcp/tcpSendWindow.c: * @post-condition TCB mutex is still held
device/tcp/tcpSendWindow.c:    window = TCP_IBLEN - tcbptr->icount;        // Correct?
device/tcp/tcpSendWindow.c:    switch (tcbptr->state)
device/tcp/tcpSendWindow.c:        /* Don't do receiver-side silly window syndrome avoidance */
device/tcp/tcpSendWindow.c:        tcbptr->rcvwnd = seqadd(tcbptr->rcvnxt, window);
device/tcp/tcpSendWindow.c:    /* Receiver-side silly window syndrome avoidance */
device/tcp/tcpSendWindow.c:    unused = (ushort)tcpSeqdiff(tcbptr->rcvwnd, tcbptr->rcvnxt);
device/tcp/tcpSendWindow.c:    if (seqlt(tcbptr->rcvwnd, tcbptr->rcvnxt))
device/tcp/tcpSendWindow.c:    if (((window * 4) < TCP_IBLEN) || (window < tcbptr->rcvmss))
device/tcp/tcpSendWindow.c:        tcbptr->rcvwnd = seqadd(tcbptr->rcvnxt, window);
device/tcp/tcpSeqdiff.c:	{ return (second-first); }
device/tcp/tcpSeqdiff.c:	{ return ((TCP_MAXSEQ - first) + second); }*/
device/tcp/tcpSeqdiff.c:        return ((TCP_MAXSEQ - first) + second);
device/tcp/tcpSeqdiff.c:        return ((TCP_MAXSEQ - first) + second);
device/tcp/tcpSeqdiff.c:    return first - second;
device/tcp/tcpSetup.c: * @pre-condition TCB mutex is already held
device/tcp/tcpSetup.c: * @post-condition TCB mutex is still held
device/tcp/tcpSetup.c:    tcbptr->openclose = semcreate(0);
device/tcp/tcpSetup.c:    tcbptr->istart = 0;
device/tcp/tcpSetup.c:    tcbptr->inxt = 0;
device/tcp/tcpSetup.c:    tcbptr->icount = 0;
device/tcp/tcpSetup.c:    tcbptr->ibytes = 0;
device/tcp/tcpSetup.c:    tcbptr->readers = semcreate(0);
device/tcp/tcpSetup.c:    tcbptr->ostart = 0;
device/tcp/tcpSetup.c:    tcbptr->ocount = 0;
device/tcp/tcpSetup.c:    tcbptr->obytes = 0;
device/tcp/tcpSetup.c:    tcbptr->writers = semcreate(1);
device/tcp/tcpSetup.c:    tcbptr->iss = tcpIss();
device/tcp/tcpSetup.c:    tcbptr->snduna = tcbptr->iss;
device/tcp/tcpSetup.c:    tcbptr->sndnxt = tcbptr->iss;
device/tcp/tcpSetup.c:    tcbptr->sndwl2 = tcbptr->iss;
device/tcp/tcpSetup.c:    tcbptr->sndmss = TCP_INIT_MSS;
device/tcp/tcpSetup.c:    tcbptr->sndflg = NULL;
device/tcp/tcpSetup.c:    tcbptr->sndcwn = tcbptr->sndmss;
device/tcp/tcpSetup.c:    tcbptr->sndsst = TCP_MAX_WND;
device/tcp/tcpSetup.c:    tcbptr->rxttime = TCP_RXT_INITTIME;
device/tcp/tcpSetup.c:    tcbptr->rxtcount = 0;
device/tcp/tcpSetup.c:    tcbptr->psttime = TCP_PST_INITTIME;
device/tcp/tcpSetup.c:    tcbptr->rcvmss = TCP_INIT_MSS - TCP_HDR_LEN;
device/tcp/tcpSetup.c:    tcbptr->rcvflg = NULL;
device/tcp/tcpSetup.c:    if ((SYSERR == (int)tcbptr->openclose)
device/tcp/tcpSetup.c:        || (SYSERR == (int)tcbptr->readers)
device/tcp/tcpSetup.c:        || (SYSERR == (int)tcbptr->writers))
device/tcp/tcpStat.c:    /* Grab useful fields out of TCB -- atomically */
device/tcp/tcpStat.c:    wait(tcbptr->mutex);
device/tcp/tcpStat.c:    devstate = tcbptr->devstate;
device/tcp/tcpStat.c:    pdev = (device *)&devtab[tcbptr->dev];
device/tcp/tcpStat.c:    state = tcbptr->state;
device/tcp/tcpStat.c:    opentype = tcbptr->opentype;
device/tcp/tcpStat.c:    localip = tcbptr->localip;
device/tcp/tcpStat.c:    remoteip = tcbptr->remoteip;
device/tcp/tcpStat.c:    localpt = tcbptr->localpt;
device/tcp/tcpStat.c:    remotept = tcbptr->remotept;
device/tcp/tcpStat.c:    rcvnxt = tcbptr->rcvnxt;
device/tcp/tcpStat.c:    rcvwnd = tcbptr->rcvwnd;
device/tcp/tcpStat.c:    snduna = tcbptr->snduna;
device/tcp/tcpStat.c:    sndnxt = tcbptr->sndnxt;
device/tcp/tcpStat.c:    sndwnd = tcbptr->sndwnd;
device/tcp/tcpStat.c:    istart = tcbptr->istart;
device/tcp/tcpStat.c:    icount = tcbptr->icount;
device/tcp/tcpStat.c:    ibytes = tcbptr->ibytes;
device/tcp/tcpStat.c:    ostart = tcbptr->ostart;
device/tcp/tcpStat.c:    ocount = tcbptr->ocount;
device/tcp/tcpStat.c:    obytes = tcbptr->obytes;
device/tcp/tcpStat.c:    signal(tcbptr->mutex);
device/tcp/tcpStat.c:        printf("BLOCK%-3d   Inactive\n", tcbptr - tcptab);
device/tcp/tcpStat.c:    printf("%-10s ", pdev->name);
device/tcp/tcpStat.c:    printf("State: %-11s    Open Type: %-7s\n", strA, strB);
device/tcp/tcpStat.c:    printf("Local  Port: %-5d    IP: %-15s\n", localpt, strA);
device/tcp/tcpStat.c:    printf("Remote Port: %-5d    IP: %-15s\n", remotept, strA);
device/tcp/tcpStat.c:    printf("Rcv Nxt: %-10u   Wnd: %-10u\n", rcvnxt,
device/tcp/tcpStat.c:    printf("Snd Una: %-10u   Nxt: %-10u   Wnd: %-10u\n",
device/tcp/tcpStat.c:    printf("In  Start: %-10u Count: %-10u Read %-10u\n",
device/tcp/tcpStat.c:    printf("Out Start: %-10u Count: %-10u Read %-10u\n",
device/tcp/tcpTimer.c:    head->used = TRUE;
device/tcp/tcpTimer.c:    head->next = NULL;
device/tcp/tcpTimer.c:        while ((head->next != NULL) && (elapse > 0))
device/tcp/tcpTimer.c:            first = head->next;
device/tcp/tcpTimer.c:            if (first->remain > elapse)
device/tcp/tcpTimer.c:                first->remain -= elapse;
device/tcp/tcpTimer.c:            elapse -= first->remain;
device/tcp/tcpTimer.c:            first->remain = 0;
device/tcp/tcpTimer.c:            while ((first != NULL) && (first->remain <= 0))
device/tcp/tcpTimer.c:                type = first->type;
device/tcp/tcpTimer.c:                tcbptr = first->tcbptr;
device/tcp/tcpTimer.c:                first->used = FALSE;
device/tcp/tcpTimer.c:                head->next = first->next;
device/tcp/tcpTimer.c:                first = head->next;
device/tcp/tcpTimer.c://        sleep(TCP_FREQ - elapse);
device/tcp/tcpTimer.c:        ticks = clkticks - lastticks;
device/tcp/tcpTimer.c:        ticks = CLKTICKS_PER_SEC - lastticks;
device/tcp/tcpTimer.c:        ticks += (clktime - lasttime - 1) * CLKTICKS_PER_SEC;
device/tcp/tcpTimerPurge.c:    cur = prev->next;
device/tcp/tcpTimerPurge.c:        if ((cur->tcbptr == tcbptr)
device/tcp/tcpTimerPurge.c:            && ((NULL == type) || (cur->type == type)))
device/tcp/tcpTimerPurge.c:                result = cur->time - cur->remain;
device/tcp/tcpTimerPurge.c:            if (cur->next != NULL)
device/tcp/tcpTimerPurge.c:                cur->next->remain += cur->remain;
device/tcp/tcpTimerPurge.c:            prev->next = cur->next;
device/tcp/tcpTimerPurge.c:            cur->used = FALSE;
device/tcp/tcpTimerPurge.c:        cur = cur->next;
device/tcp/tcpTimerRemain.c:        time += cur->remain;
device/tcp/tcpTimerRemain.c:        if ((cur->tcbptr == tcbptr) && (cur->type == type))
device/tcp/tcpTimerRemain.c:        cur = cur->next;
device/tcp/tcpTimerSched.c:    evtptr->time = time;
device/tcp/tcpTimerSched.c:    evtptr->type = type;
device/tcp/tcpTimerSched.c:    evtptr->tcbptr = tcbptr;
device/tcp/tcpTimerSched.c:    next = prev->next;
device/tcp/tcpTimerSched.c:    while ((next != NULL) && (next->remain <= time))
device/tcp/tcpTimerSched.c:        time -= next->remain;
device/tcp/tcpTimerSched.c:        next = next->next;
device/tcp/tcpTimerSched.c:    evtptr->next = next;
device/tcp/tcpTimerSched.c:    prev->next = evtptr;
device/tcp/tcpTimerSched.c:    evtptr->remain = time;
device/tcp/tcpTimerSched.c:        next->remain -= time;
device/tcp/tcpTimerTrigger.c:        wait(tcbptr->mutex);
device/tcp/tcpWrite.c:    tcbptr = &tcptab[devptr->minor];
device/tcp/tcpWrite.c:    wait(tcbptr->mutex);
device/tcp/tcpWrite.c:        signal(tcbptr->mutex);
device/tcp/tcpWrite.c:    signal(tcbptr->mutex);
device/tcp/tcpWrite.c:        wait(tcbptr->writers);
device/tcp/tcpWrite.c:        wait(tcbptr->mutex);
device/tcp/tcpWrite.c:            signal(tcbptr->writers);
device/tcp/tcpWrite.c:        while ((tcbptr->ocount < TCP_OBLEN) && (count < len))
device/tcp/tcpWrite.c:            tcbptr->out[((tcbptr->ostart + tcbptr->ocount) % TCP_OBLEN)] =
device/tcp/tcpWrite.c:            tcbptr->ocount++;
device/tcp/tcpWrite.c:        if (tcbptr->ocount < TCP_OBLEN)
device/tcp/tcpWrite.c:            signal(tcbptr->writers);
device/tcp/tcpWrite.c:        if ((TCP_ESTAB == tcbptr->state)
device/tcp/tcpWrite.c:            || (TCP_CLOSEWT == tcbptr->state))
device/tcp/tcpWrite.c:        signal(tcbptr->mutex);
device/tcp/tcpWrite.c: * @pre-condition TCB mutex is already held
device/tcp/tcpWrite.c: * @post-condition TCB mutex is still held
device/tcp/tcpWrite.c:    switch (tcbptr->state)
device/tcp/tcpWrite.c:        signal(tcbptr->mutex);
device/tcp/tcpWrite.c:        if ((tcbptr->remotept != NULL) && (tcbptr->remoteip.type != NULL))
device/tcp/tcpWrite.c:            tcbptr->state = TCP_SYNSENT;
device/tcp/tcpWrite.c:                signal(tcbptr->mutex);
device/tcp/tcpWrite.c:            if (tcbptr->sndflg & TCP_FLG_SYN)
device/tcp/tcpWrite.c:        signal(tcbptr->mutex);
device/tcp/tcpWrite.c:        signal(tcbptr->mutex);
device/telnet/telnetClose.c:    tntptr = &telnettab[devptr->minor];
device/telnet/telnetClose.c:    tntptr->state = TELNET_STATE_FREE;
device/telnet/telnetControl.c:    tntptr = &telnettab[devptr->minor];
device/telnet/telnetControl.c:    phw = tntptr->phw;
device/telnet/telnetControl.c:        tntptr->flags &= ~arg1;
device/telnet/telnetControl.c:        tntptr->flags |= arg1;
device/telnet/telnetFlush.c:    tntptr = &telnettab[devptr->minor];
device/telnet/telnetFlush.c:    phw = tntptr->phw;
device/telnet/telnetFlush.c:    if (TELNET_STATE_OPEN != tntptr->state)
device/telnet/telnetFlush.c:    if (tntptr->ostart > 0)
device/telnet/telnetFlush.c:            (*phw->write) (phw, (void *)(tntptr->out), tntptr->ostart))
device/telnet/telnetFlush.c:        tntptr->ostart = 0;
device/telnet/telnetInit.c:    tntptr = &telnettab[devptr->minor];
device/telnet/telnetInit.c:    if (0 == devptr->minor)
device/telnet/telnetInit.c:        tntptr->killswitch = semcreate(0);
device/telnet/telnetInit.c:        tntptr->killswitch = telnettab[0].killswitch;
device/telnet/telnetOpen.c:    TELNET_TRACE("Open(%d) dvnum = %d", devptr->minor, dvnum);
device/telnet/telnetOpen.c:    tntptr = &telnettab[devptr->minor];
device/telnet/telnetOpen.c:    if ((TELNET_STATE_FREE != tntptr->state) &&
device/telnet/telnetOpen.c:        (TELNET_STATE_ALLOC != tntptr->state))
device/telnet/telnetOpen.c:        TELNET_TRACE("state = %d", tntptr->state);
device/telnet/telnetOpen.c:    tntptr->state = TELNET_STATE_OPEN;
device/telnet/telnetOpen.c:    tntptr->istart = 0;
device/telnet/telnetOpen.c:    tntptr->icount = 0;
device/telnet/telnetOpen.c:    tntptr->idelim = FALSE;
device/telnet/telnetOpen.c:    tntptr->ocount = 0;
device/telnet/telnetOpen.c:    tntptr->ostart = 0;
device/telnet/telnetOpen.c:    tntptr->flags = 0;
device/telnet/telnetOpen.c:    tntptr->ieof = FALSE;
device/telnet/telnetOpen.c:    tntptr->phw = (device *)&devtab[dvnum];
device/telnet/telnetOpen.c:    tntptr->echoState = TELNET_ECHO_SENT_WILL;
device/telnet/telnetOpen.c:    tntptr->isem = semcreate(1);
device/telnet/telnetOpen.c:    tntptr->osem = semcreate(1);
device/telnet/telnetRead.c:    tntptr = &telnettab[devptr->minor];
device/telnet/telnetRead.c:    phw = tntptr->phw;
device/telnet/telnetRead.c:    if (tntptr->ieof)
device/telnet/telnetRead.c:        tntptr->ieof = FALSE;
device/telnet/telnetRead.c:    wait(tntptr->isem);
device/telnet/telnetRead.c:    if (0 == tntptr->icount)
device/telnet/telnetRead.c:        while ((tntptr->icount < TELNET_IBLEN) && !(tntptr->idelim))
device/telnet/telnetRead.c:            index = tntptr->icount + tntptr->istart;
device/telnet/telnetRead.c:            ch = (*phw->getc) (phw);
device/telnet/telnetRead.c:                tntptr->in[index % TELNET_IBLEN] = ch;
device/telnet/telnetRead.c:                tntptr->icount++;
device/telnet/telnetRead.c:                index = tntptr->icount + tntptr->istart;
device/telnet/telnetRead.c:                ch = (*phw->getc) (phw);
device/telnet/telnetRead.c:                    tntptr->in[index % TELNET_IBLEN] = ch;
device/telnet/telnetRead.c:                    tntptr->icount++;
device/telnet/telnetRead.c:                    tntptr->idelim = TRUE;
device/telnet/telnetRead.c:                    tntptr->in[index % TELNET_IBLEN] = '\0';
device/telnet/telnetRead.c:                    tntptr->icount++;
device/telnet/telnetRead.c:                    index = tntptr->icount + tntptr->istart;
device/telnet/telnetRead.c:                    tntptr->in[index % TELNET_IBLEN] = ch;
device/telnet/telnetRead.c:                    tntptr->icount++;
device/telnet/telnetRead.c:                //if (TELNET_ECHO_SELF_ECHOES == tntptr->echoState)
device/telnet/telnetRead.c:                if (tntptr->flags & TELNET_FLAG_ECHO);
device/telnet/telnetRead.c:                if (tntptr->icount >= 1)
device/telnet/telnetRead.c:                    tntptr->icount--;
device/telnet/telnetRead.c:                    if (tntptr->flags & TELNET_FLAG_ECHO);
device/telnet/telnetRead.c:                tntptr->in[index % TELNET_IBLEN] = ch;
device/telnet/telnetRead.c:                tntptr->icount++;
device/telnet/telnetRead.c:                tntptr->idelim = TRUE;
device/telnet/telnetRead.c:                //if (TELNET_ECHO_SELF_ECHOES == tntptr->echoState)
device/telnet/telnetRead.c:                if (tntptr->flags & TELNET_FLAG_ECHO);
device/telnet/telnetRead.c:                tntptr->ieof = TRUE;
device/telnet/telnetRead.c:                tntptr->idelim = TRUE;
device/telnet/telnetRead.c:                ch = (*phw->getc) (phw);
device/telnet/telnetRead.c:                    ch = (*phw->getc) (phw);
device/telnet/telnetRead.c:                        TELNET_TRACE("Recv WILL Suppress Go-Ahead");
device/telnet/telnetRead.c:                            TELNET_TRACE("Send WILL Suppress Go-Ahead");
device/telnet/telnetRead.c:                    ch = (*phw->getc) (phw);
device/telnet/telnetRead.c:                    ch = (*phw->getc) (phw);
device/telnet/telnetRead.c:                        TELNET_TRACE("Recv DO   Suppress Go-Ahead");
device/telnet/telnetRead.c:                        TELNET_TRACE("Send WILL Suppress Go-Ahead");
device/telnet/telnetRead.c:                        tntptr->flags |= TELNET_FLAG_SUPPRESS_GA;
device/telnet/telnetRead.c:                    ch = (*phw->getc) (phw);
device/telnet/telnetRead.c:                    (*phw->write) (phw, (void *)amthere, 36);
device/telnet/telnetRead.c:                    if (tntptr->icount >= 1)
device/telnet/telnetRead.c:                        tntptr->icount--;
device/telnet/telnetRead.c:                    while (tntptr->icount >= 1 &&
device/telnet/telnetRead.c:                           tntptr->in[index % TELNET_IBLEN] != '\n')
device/telnet/telnetRead.c:                        tntptr->icount--;
device/telnet/telnetRead.c:                        index = tntptr->icount + tntptr->istart;
device/telnet/telnetRead.c:                        tntptr->in[index % TELNET_IBLEN] = 0;
device/telnet/telnetRead.c:                    TELNET_TRACE("Recv Go-Ahead");
device/telnet/telnetRead.c:                    tntptr->in[index % TELNET_IBLEN] = ch;
device/telnet/telnetRead.c:                    tntptr->icount++;
device/telnet/telnetRead.c:                //if (TELNET_ECHO_SELF_ECHOES == tntptr->echoState)
device/telnet/telnetRead.c:                if (tntptr->flags & TELNET_FLAG_ECHO);
device/telnet/telnetRead.c:    signal(tntptr->isem);
device/telnet/telnetRead.c:    while ((0 < tntptr->icount) && (count < len))
device/telnet/telnetRead.c:        *buffer++ = tntptr->in[tntptr->istart];
device/telnet/telnetRead.c:        tntptr->icount--;
device/telnet/telnetRead.c:        tntptr->istart = (tntptr->istart + 1) % TELNET_IBLEN;
device/telnet/telnetRead.c:    if (0 == tntptr->icount)
device/telnet/telnetRead.c:        tntptr->idelim = FALSE;
device/telnet/telnetRead.c:    phw = tntptr->phw;
device/telnet/telnetRead.c:    switch (tntptr->echoState)
device/telnet/telnetRead.c:            tntptr->echoState = TELNET_ECHO_OTHER_ECHOES;
device/telnet/telnetRead.c:            tntptr->flags &= ~TELNET_FLAG_ECHO;
device/telnet/telnetRead.c:            tntptr->echoState = TELNET_ECHO_SENT_WILL;
device/telnet/telnetRead.c:            tntptr->echoState = TELNET_ECHO_SELF_ECHOES;
device/telnet/telnetRead.c:            tntptr->flags |= TELNET_FLAG_ECHO;
device/telnet/telnetRead.c:            tntptr->echoState = TELNET_ECHO_NO_ECHO;
device/telnet/telnetRead.c:            tntptr->flags &= ~TELNET_FLAG_ECHO;
device/telnet/telnetRead.c:            tntptr->echoState = TELNET_ECHO_NO_ECHO;
device/telnet/telnetRead.c:            tntptr->flags &= ~TELNET_FLAG_ECHO;
device/telnet/telnetRead.c:            tntptr->echoState = TELNET_ECHO_SENT_WILL;
device/telnet/telnetRead.c:            tntptr->echoState = TELNET_ECHO_SELF_ECHOES;
device/telnet/telnetRead.c:            tntptr->flags |= TELNET_FLAG_ECHO;
device/telnet/telnetRead.c:        TELNET_TRACE("Echo state unknown %d!", tntptr->echoState);
device/telnet/telnetRead.c:    (*phw->write) (phw, (void *)cmdbuf, 3);
device/telnet/telnetServer.c:    host = &(interface->ip);
device/telnet/telnetServer.c:                     telnetdev - TELNET0, tcpdev - TCP0);
device/telnet/telnetWrite.c:    tntptr = &telnettab[devptr->minor];
device/telnet/telnetWrite.c:    phw = tntptr->phw;
device/telnet/telnetWrite.c:    wait(tntptr->osem);
device/telnet/telnetWrite.c:        if (tntptr->ostart >= TELNET_OBLEN - 1)
device/telnet/telnetWrite.c:            tntptr->out[tntptr->ostart++] = '\r';
device/telnet/telnetWrite.c:            tntptr->out[tntptr->ostart++] = '\n';
device/telnet/telnetWrite.c:            tntptr->out[tntptr->ostart++] = ch;
device/telnet/telnetWrite.c:            tntptr->out[tntptr->ostart++] = ch;
device/telnet/telnetWrite.c:            tntptr->out[tntptr->ostart++] = ch;
device/telnet/telnetWrite.c:    signal(tntptr->osem);
device/tty/Doxygroup.c: * character input/output device to provide line-editing and other useful
device/tty/ttyClose.c:    ttyptr = &ttytab[devptr->minor];
device/tty/ttyControl.c:    ttyptr = &ttytab[devptr->minor];
device/tty/ttyControl.c:    phw = ttyptr->phw;
device/tty/ttyControl.c:        old = ttyptr->iflags & arg1;
device/tty/ttyControl.c:        ttyptr->iflags |= (arg1);
device/tty/ttyControl.c:        old = ttyptr->iflags & arg1;
device/tty/ttyControl.c:        ttyptr->iflags &= ~(arg1);
device/tty/ttyControl.c:        old = ttyptr->oflags & arg1;
device/tty/ttyControl.c:        ttyptr->oflags |= (arg1);
device/tty/ttyControl.c:        old = ttyptr->oflags & arg1;
device/tty/ttyControl.c:        ttyptr->oflags &= ~(arg1);
device/tty/ttyInit.c:    ttyptr = &ttytab[devptr->minor];
device/tty/ttyOpen.c:    ttyptr = &ttytab[devptr->minor];
device/tty/ttyOpen.c:    if (NULL != ttyptr->phw)
device/tty/ttyOpen.c:    ttyptr->istart = 0;
device/tty/ttyOpen.c:    ttyptr->icount = 0;
device/tty/ttyOpen.c:    ttyptr->idelim = FALSE;
device/tty/ttyOpen.c:    ttyptr->iflags = TTY_ICRNL;
device/tty/ttyOpen.c:    ttyptr->ieof = FALSE;
device/tty/ttyOpen.c:    ttyptr->oflags = TTY_ONLCR;
device/tty/ttyOpen.c:    ttyptr->phw = (device *)&devtab[dvnum];
device/tty/ttyPutc.c:    ttyptr = &ttytab[devptr->minor];
device/tty/ttyPutc.c:    phw = ttyptr->phw;
device/tty/ttyPutc.c:        if (ttyptr->oflags & TTY_ONLCR)
device/tty/ttyPutc.c:            if (SYSERR == (*phw->putc) (phw, '\r'))
device/tty/ttyPutc.c:        if (ttyptr->oflags & TTY_OCRNL)
device/tty/ttyPutc.c:    return (*phw->putc) (phw, ch);
device/tty/ttyRead.c:    ttyptr = &ttytab[devptr->minor];
device/tty/ttyRead.c:    phw = ttyptr->phw;
device/tty/ttyRead.c:    if (ttyptr->ieof)
device/tty/ttyRead.c:        ttyptr->ieof = FALSE;
device/tty/ttyRead.c:    if (ttyptr->iflags & TTY_IRAW)
device/tty/ttyRead.c:        while ((0 < ttyptr->icount) && (count < len))
device/tty/ttyRead.c:            *buffer++ = ttyptr->in[ttyptr->istart];
device/tty/ttyRead.c:            ttyptr->icount--;
device/tty/ttyRead.c:            ttyptr->istart = (ttyptr->istart + 1) % TTY_IBLEN;
device/tty/ttyRead.c:            ch = (*phw->getc) (phw);
device/tty/ttyRead.c:            if (ttyptr->iflags & TTY_ECHO)
device/tty/ttyRead.c:    /* In non-raw mode, read characters into the TTY input buffer     */
device/tty/ttyRead.c:    while ((ttyptr->icount < TTY_IBLEN) && !ttyptr->idelim)
device/tty/ttyRead.c:        ch = (*phw->getc) (phw);
device/tty/ttyRead.c:            if (ttyptr->icount < 1)
device/tty/ttyRead.c:            ttyptr->icount--;
device/tty/ttyRead.c:            if (ttyptr->iflags & TTY_INLCR)
device/tty/ttyRead.c:            ttyptr->in[(ttyptr->istart + ttyptr->icount) % TTY_IBLEN] =
device/tty/ttyRead.c:            ttyptr->icount++;
device/tty/ttyRead.c:            ttyptr->idelim = TRUE;
device/tty/ttyRead.c:            if (ttyptr->iflags & TTY_IGNCR)
device/tty/ttyRead.c:            if (ttyptr->iflags & TTY_ICRNL)
device/tty/ttyRead.c:            ttyptr->in[(ttyptr->istart + ttyptr->icount) % TTY_IBLEN] =
device/tty/ttyRead.c:            ttyptr->icount++;
device/tty/ttyRead.c:            ttyptr->idelim = TRUE;
device/tty/ttyRead.c:            ttyptr->ieof = TRUE;
device/tty/ttyRead.c:            ttyptr->idelim = TRUE;
device/tty/ttyRead.c:            ttyptr->in[(ttyptr->istart + ttyptr->icount) % TTY_IBLEN] =
device/tty/ttyRead.c:            ttyptr->icount++;
device/tty/ttyRead.c:        if (ttyptr->iflags & TTY_ECHO)
device/tty/ttyRead.c:        if (ttyptr->iflags & TTY_IRAW)
device/tty/ttyRead.c:    while ((0 < ttyptr->icount) && (count < len))
device/tty/ttyRead.c:        *buffer++ = ttyptr->in[ttyptr->istart];
device/tty/ttyRead.c:        ttyptr->icount--;
device/tty/ttyRead.c:        ttyptr->istart = (ttyptr->istart + 1) % TTY_IBLEN;
device/tty/ttyRead.c:    if (0 == ttyptr->icount)
device/tty/ttyRead.c:        ttyptr->idelim = FALSE;
device/tty/ttyRead.c:    if ((0 == count) && (ttyptr->ieof))
device/tty/ttyRead.c:        ttyptr->ieof = FALSE;
Binary file device/tty/ttyControl.o matches
Binary file device/tty/ttyOpen.o matches
device/tty/ttyOpen.d: ../include/stdarg.h ../system/platforms/arm-rpi3/interrupt.h \
device/tty/ttyOpen.d: ../system/platforms/arm-rpi3/bcm2837.h
device/tty/ttyOpen.d:../system/platforms/arm-rpi3/interrupt.h:
device/tty/ttyOpen.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file device/tty/ttyRead.o matches
Binary file device/tty/ttyClose.o matches
device/tty/ttyClose.d: ../system/platforms/arm-rpi3/interrupt.h \
device/tty/ttyClose.d: ../system/platforms/arm-rpi3/bcm2837.h
device/tty/ttyClose.d:../system/platforms/arm-rpi3/interrupt.h:
device/tty/ttyClose.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file device/tty/ttyGetc.o matches
Binary file device/tty/ttyInit.o matches
Binary file device/tty/ttyPutc.o matches
Binary file device/tty/ttyWrite.o matches
device/uart-ns16550/Makerules:COMP = device/uart-ns16550
device/uart-ns16550/kgetc.c:    uartptr = &uarttab[devptr->minor];
device/uart-ns16550/kgetc.c:    regptr = devptr->csr;
device/uart-ns16550/kgetc.c:    uart_im = regptr->ier;
device/uart-ns16550/kgetc.c:    regptr->ier = 0;
device/uart-ns16550/kgetc.c:    while (!(regptr->lsr & UART_LSR_DR))
device/uart-ns16550/kgetc.c:    c = regptr->rbr;
device/uart-ns16550/kgetc.c:    uartptr->cin++;
device/uart-ns16550/kgetc.c:    regptr->ier = uart_im;
device/uart-ns16550/kputc.c:    uartptr = &uarttab[devptr->minor];
device/uart-ns16550/kputc.c:    regptr = devptr->csr;
device/uart-ns16550/kputc.c:    uart_im = regptr->ier;
device/uart-ns16550/kputc.c:    regptr->ier = 0;
device/uart-ns16550/kputc.c:    while ((regptr->lsr & UART_LSR_TEMT) != UART_LSR_TEMT)
device/uart-ns16550/kputc.c:    regptr->thr = c;
device/uart-ns16550/kputc.c:    uartptr->cout++;
device/uart-ns16550/kputc.c:    regptr->ier = uart_im;
device/uart-ns16550/ns16550.h:#define UART_IIR_IDMASK 0x0E    /**< 3-bit field for interrupt ID       */
device/uart-ns16550/ns16550.h:#define UART_MCR_OUT2   0x08    /**< User-defined OUT2.                 */
device/uart-ns16550/ns16550.h:#define UART_LSR_THRE   0x20    /**< Transmit-hold-register empty       */
device/uart-ns16550/uartHwInit.c:    volatile struct ns16550_uart_csreg *regptr = devptr->csr;
device/uart-ns16550/uartHwInit.c:    regptr->lcr = UART_LCR_DLAB;        /* Set Divisor Latch Access Bit */
device/uart-ns16550/uartHwInit.c:    regptr->dll = platform.uart_dll;    /* Set Divisor Latch Low Byte   */
device/uart-ns16550/uartHwInit.c:    regptr->dlm = 0x00;         /* Set Divisor Latch High Byte  */
device/uart-ns16550/uartHwInit.c:    regptr->lcr = UART_LCR_8N1; /* 8 bit, No Parity, 1 Stop     */
device/uart-ns16550/uartHwInit.c:    regptr->fcr = 0x00;         /* Disable FIFO for now         */
device/uart-ns16550/uartHwInit.c:    /* OUT2 is used to control the board's interrupt tri-state        */
device/uart-ns16550/uartHwInit.c:    regptr->mcr = UART_MCR_OUT2;        /* Turn on user-defined OUT2.   */
device/uart-ns16550/uartHwInit.c:    regptr->ier = UART_IER_ERBFI | UART_IER_ETBEI | UART_IER_ELSI;
device/uart-ns16550/uartHwInit.c:    regptr->fcr = UART_FCR_EFIFO | UART_FCR_RRESET
device/uart-ns16550/uartHwInit.c:    interruptVector[devptr->irq] = devptr->intr;
device/uart-ns16550/uartHwInit.c:    enable_irq(devptr->irq);
device/uart-ns16550/uartHwPutc.c:    regptr->thr = c;
device/uart-ns16550/uartHwStat.c:    printf("\t------------------------------------------\n");
device/uart-ns16550/uartHwStat.c:    enabled = (regptr->ier & UART_IER_ERBFI) ? 1 : 0;
device/uart-ns16550/uartHwStat.c:    enabled = (regptr->ier & UART_IER_ETBEI) ? 1 : 0;
device/uart-ns16550/uartHwStat.c:    enabled = (regptr->ier & UART_IER_ELSI) ? 1 : 0;
device/uart-ns16550/uartHwStat.c:    enabled = (regptr->ier & UART_IER_EMSI) ? 1 : 0;
device/uart-ns16550/uartInterrupt.c:        regptr = (struct ns16550_uart_csreg *)uartptr->csr;
device/uart-ns16550/uartInterrupt.c:        iir = regptr->iir;
device/uart-ns16550/uartInterrupt.c:            lsr = regptr->lsr;
device/uart-ns16550/uartInterrupt.c:            uartptr->lserr++;
device/uart-ns16550/uartInterrupt.c:            uartptr->iirq++;
device/uart-ns16550/uartInterrupt.c:            while (regptr->lsr & UART_LSR_DR)
device/uart-ns16550/uartInterrupt.c:                c = regptr->buffer;
device/uart-ns16550/uartInterrupt.c:                if (uartptr->icount < UART_IBLEN)
device/uart-ns16550/uartInterrupt.c:                    uartptr->in
device/uart-ns16550/uartInterrupt.c:                        [(uartptr->istart +
device/uart-ns16550/uartInterrupt.c:                          uartptr->icount) % UART_IBLEN] = c;
device/uart-ns16550/uartInterrupt.c:                    uartptr->icount++;
device/uart-ns16550/uartInterrupt.c:                    uartptr->ovrrn++;
device/uart-ns16550/uartInterrupt.c:            uartptr->cin += count;
device/uart-ns16550/uartInterrupt.c:            signaln(uartptr->isema, count);
device/uart-ns16550/uartInterrupt.c:            /* Fall through -- Rx status trumps Tx status on Qemu. */
device/uart-ns16550/uartInterrupt.c:            lsr = regptr->lsr;  /* Read from LSR to clear interrupt */
device/uart-ns16550/uartInterrupt.c:            uartptr->oirq++;
device/uart-ns16550/uartInterrupt.c:            if (uartptr->ocount > 0)
device/uart-ns16550/uartInterrupt.c:                    uartptr->ocount--;
device/uart-ns16550/uartInterrupt.c:                    regptr->buffer = uartptr->out[uartptr->ostart];
device/uart-ns16550/uartInterrupt.c:                    uartptr->ostart = (uartptr->ostart + 1) % UART_OBLEN;
device/uart-ns16550/uartInterrupt.c:                while ((count < UART_FIFO_LEN) && (uartptr->ocount > 0));
device/uart-ns16550/uartInterrupt.c:                uartptr->cout += count;
device/uart-ns16550/uartInterrupt.c:                signaln(uartptr->osema, count);
device/uart-ns16550/uartInterrupt.c:                uartptr->oidle = TRUE;
device/uart-ns16550/uartInterrupt.c:    if (--resdefer > 0)
device/uart-pl011/Makerules:COMP = device/uart-pl011
device/uart-pl011/kgetc.c:    uartptr = &uarttab[devptr->minor];
device/uart-pl011/kgetc.c:    regptr = devptr->csr;
device/uart-pl011/kgetc.c:    uart_im = regptr->imsc;
device/uart-pl011/kgetc.c:    regptr->imsc = 0;
device/uart-pl011/kgetc.c:    while ((regptr->fr & PL011_FR_RXFE))
device/uart-pl011/kgetc.c:    c = regptr->dr;
device/uart-pl011/kgetc.c:    uartptr->cin++;
device/uart-pl011/kgetc.c:    regptr->imsc = uart_im;
device/uart-pl011/kputc.c:    uartptr = &uarttab[devptr->minor];
device/uart-pl011/kputc.c:    regptr = devptr->csr;
device/uart-pl011/kputc.c:    uart_im = regptr->imsc;
device/uart-pl011/kputc.c:    regptr->imsc = 0;
device/uart-pl011/kputc.c:    while ((regptr->fr & PL011_FR_TXFF))
device/uart-pl011/kputc.c:    regptr->dr = c;
device/uart-pl011/kputc.c:    uartptr->cout++;
device/uart-pl011/kputc.c:    regptr->imsc = uart_im;
device/uart-pl011/pl011.h:#define PL011_BAUD_FRAC(x) (int)((((UARTCLK / (16.0 * (x)))-PL011_BAUD_INT(x))*64.0)+0.5) //9600 baud may be slightly off with this calcualtion
device/uart-pl011/uartHwInit.c:/* Set up the GPIO (general-purpose IO) pins needed to use the PL011 UART on the
device/uart-pl011/uartHwInit.c:    void *gpio_regs = uart_regs - UART_GPIO_OFFSET;
device/uart-pl011/uartHwInit.c:    /* Remove pull-up or pull-down on GPIO pins 14 and 15, which will be used
device/uart-pl011/uartHwInit.c:	regptr->gpfsel[1] &= ~((7 << 12) | (7 << 15));
device/uart-pl011/uartHwInit.c:	regptr->gpfsel[1] |= (4 << 12) | (4 << 15);	
device/uart-pl011/uartHwInit.c:	/* Disable pull-up/down on pins 14 & 15 */
device/uart-pl011/uartHwInit.c:	regptr->gppud = 0;
device/uart-pl011/uartHwInit.c:	regptr->gppudclk[0] = (1 << 14) | (1 << 15);
device/uart-pl011/uartHwInit.c:	regptr->gppudclk[0] = 0;	
device/uart-pl011/uartHwInit.c:    volatile struct pl011_uart_csreg *regptr = devptr->csr;
device/uart-pl011/uartHwInit.c:    regptr->cr = 0;
device/uart-pl011/uartHwInit.c:    while (regptr->fr & PL011_FR_BUSY)
device/uart-pl011/uartHwInit.c:    regptr->lcrh &= ~PL011_LCRH_FEN;
device/uart-pl011/uartHwInit.c:    regptr->icr = (PL011_ICR_OEIC |
device/uart-pl011/uartHwInit.c:    regptr->ibrd = PL011_BAUD_INT(115200);
device/uart-pl011/uartHwInit.c:    regptr->fbrd = PL011_BAUD_FRAC(115200);
device/uart-pl011/uartHwInit.c:    regptr->lcrh = PL011_LCRH_WLEN_8BIT;
device/uart-pl011/uartHwInit.c:    regptr->imsc = PL011_IMSC_RXIM | PL011_IMSC_TXIM;
device/uart-pl011/uartHwInit.c:    regptr->lcrh |= PL011_LCRH_FEN;
device/uart-pl011/uartHwInit.c:    regptr->ifls = PL011_IFLS_RXIFLSEL_SEVENEIGHTHS | PL011_IFLS_TXIFLSEL_EIGHTH;
device/uart-pl011/uartHwInit.c:    regptr->cr = PL011_CR_RXE | PL011_CR_TXE | PL011_CR_UARTEN;
device/uart-pl011/uartHwInit.c:	interruptVector[devptr->irq] = devptr->intr;
device/uart-pl011/uartHwInit.c:	enable_irq(devptr->irq);
device/uart-pl011/uartHwPutc.c:    regptr->dr = c;
device/uart-pl011/uartHwStat.c:    printf("\t------------------------------------------\n");
device/uart-pl011/uartHwStat.c:    enabled = (regptr->imsc & PL011_IMSC_RXIM) ? 1 : 0;
device/uart-pl011/uartHwStat.c:    enabled = (regptr->imsc & PL011_IMSC_TXIM) ? 1 : 0;
device/uart-pl011/uartInterrupt.c:	 * being executed re-entrantly.  */
device/uart-pl011/uartInterrupt.c:		regptr = uartptr->csr;
device/uart-pl011/uartInterrupt.c:		mis = regptr->mis;
device/uart-pl011/uartInterrupt.c:			uartptr->oirq++;
device/uart-pl011/uartInterrupt.c:			regptr->icr = PL011_ICR_TXIC;
device/uart-pl011/uartInterrupt.c:			if (uartptr->ocount > 0)
device/uart-pl011/uartInterrupt.c:					regptr->dr = uartptr->out[uartptr->ostart];
device/uart-pl011/uartInterrupt.c:					uartptr->ostart = (uartptr->ostart + 1) % UART_OBLEN;
device/uart-pl011/uartInterrupt.c:					uartptr->ocount--;
device/uart-pl011/uartInterrupt.c:				} while (!(regptr->fr & PL011_FR_TXFF) && (uartptr->ocount > 0));
device/uart-pl011/uartInterrupt.c:				uartptr->cout += count;
device/uart-pl011/uartInterrupt.c:				signaln(uartptr->osema, count);
device/uart-pl011/uartInterrupt.c:				uartptr->oidle = TRUE;
device/uart-pl011/uartInterrupt.c:			uartptr->iirq++;
device/uart-pl011/uartInterrupt.c:				c = regptr->dr;
device/uart-pl011/uartInterrupt.c:				if (uartptr->icount < UART_IBLEN)
device/uart-pl011/uartInterrupt.c:					uartptr->in[(uartptr->istart +
device/uart-pl011/uartInterrupt.c:							uartptr->icount) % UART_IBLEN] = c;
device/uart-pl011/uartInterrupt.c:					uartptr->icount++;
device/uart-pl011/uartInterrupt.c:					uartptr->ovrrn++;
device/uart-pl011/uartInterrupt.c:			} while (!(regptr->fr & PL011_FR_RXFE));
device/uart-pl011/uartInterrupt.c:			uartptr->cin += count;
device/uart-pl011/uartInterrupt.c:			signaln(uartptr->isema, count);
device/uart-pl011/uartInterrupt.c:	if (--resdefer > 0)
Binary file device/uart-pl011/uartHwInit.o matches
device/uart-pl011/uartHwInit.d:../device/uart-pl011/uartHwInit.o: ../device/uart-pl011/uartHwInit.c \
device/uart-pl011/uartHwInit.d: ../system/platforms/arm-rpi3/interrupt.h \
device/uart-pl011/uartHwInit.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/clock.h \
device/uart-pl011/uartHwInit.d: ../device/uart-pl011/pl011.h ../system/platforms/arm-rpi3/rpi_gpio.h \
device/uart-pl011/uartHwInit.d: ../system/platforms/arm-rpi3/bcm2837.h
device/uart-pl011/uartHwInit.d:../system/platforms/arm-rpi3/interrupt.h:
device/uart-pl011/uartHwInit.d:../system/platforms/arm-rpi3/bcm2837.h:
device/uart-pl011/uartHwInit.d:../device/uart-pl011/pl011.h:
device/uart-pl011/uartHwInit.d:../system/platforms/arm-rpi3/rpi_gpio.h:
device/uart-pl011/uartHwInit.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file device/uart-pl011/kgetc.o matches
device/uart-pl011/kgetc.d:../device/uart-pl011/kgetc.o: ../device/uart-pl011/kgetc.c \
device/uart-pl011/kgetc.d: ../device/uart-pl011/pl011.h
device/uart-pl011/kgetc.d:../device/uart-pl011/pl011.h:
Binary file device/uart-pl011/kputc.o matches
device/uart-pl011/kputc.d:../device/uart-pl011/kputc.o: ../device/uart-pl011/kputc.c \
device/uart-pl011/kputc.d: ../device/uart-pl011/pl011.h
device/uart-pl011/kputc.d:../device/uart-pl011/pl011.h:
Binary file device/uart-pl011/uartHwPutc.o matches
device/uart-pl011/uartHwPutc.d:../device/uart-pl011/uartHwPutc.o: ../device/uart-pl011/uartHwPutc.c \
device/uart-pl011/uartHwPutc.d: ../device/uart-pl011/pl011.h
device/uart-pl011/uartHwPutc.d:../device/uart-pl011/pl011.h:
Binary file device/uart-pl011/uartHwStat.o matches
device/uart-pl011/uartHwStat.d:../device/uart-pl011/uartHwStat.o: ../device/uart-pl011/uartHwStat.c \
device/uart-pl011/uartHwStat.d: ../system/platforms/arm-rpi3/interrupt.h \
device/uart-pl011/uartHwStat.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
device/uart-pl011/uartHwStat.d: ../include/memory.h ../device/uart-pl011/pl011.h
device/uart-pl011/uartHwStat.d:../system/platforms/arm-rpi3/interrupt.h:
device/uart-pl011/uartHwStat.d:../system/platforms/arm-rpi3/bcm2837.h:
device/uart-pl011/uartHwStat.d:../device/uart-pl011/pl011.h:
Binary file device/uart-pl011/uartInterrupt.o matches
device/uart-pl011/uartInterrupt.d:../device/uart-pl011/uartInterrupt.o: \
device/uart-pl011/uartInterrupt.d: ../device/uart-pl011/uartInterrupt.c ../include/uart.h \
device/uart-pl011/uartInterrupt.d: ../system/platforms/arm-rpi3/interrupt.h \
device/uart-pl011/uartInterrupt.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
device/uart-pl011/uartInterrupt.d: ../include/memory.h ../device/uart-pl011/pl011.h
device/uart-pl011/uartInterrupt.d:../system/platforms/arm-rpi3/interrupt.h:
device/uart-pl011/uartInterrupt.d:../system/platforms/arm-rpi3/bcm2837.h:
device/uart-pl011/uartInterrupt.d:../device/uart-pl011/pl011.h:
device/uart-x86/Makerules:COMP = device/uart-x86
device/uart-x86/kgetc.c:        volatile struct uart_csreg *pucsr = pdev->csr;
device/uart-x86/kgetc.c:        irmask = pucsr->ier;        /* Save UART interrupt state.   */
device/uart-x86/kgetc.c:        pucsr->ier = 0;             /* Disable UART interrupts.     */
device/uart-x86/kgetc.c:        while (0 == (pucsr->lsr & UART_LSR_DR))
device/uart-x86/kgetc.c:        c = pucsr->rbr;
device/uart-x86/kgetc.c:        pucsr->ier = irmask;        /* Restore UART interrupts.     */
device/uart-x86/kputc.c:    void *pucsr = pdev->csr;
device/uart-x86/uartHwInit.c:    void *pucsr = devptr->csr;
device/uart-x86/uartHwInit.c:                                                 /* DLL 12 -> 9600 bps   */
device/uart-x86/uartHwInit.c:                                                 /* DLL 1 -> 115200 bps  */
device/uart-x86/uartHwInit.c:    outb((ulong)pucsr+UART_MCR, UART_MCR_OUT2);  /* User-defined OUT2    */
device/uart-x86/uartHwInit.c:    /* OUT2 is used to control the board's interrupt tri-state           */
device/uart-x86/uartHwInit.c:    set_handler(IRQBASE+devptr->irq, devptr->intr);
device/uart-x86/uartHwStat.c:    printf("\t------------------------------------------\n");
device/uart-x86/uartInterrupt.c:#include <asm-i386/icu.h>
device/uart-x86/uartInterrupt.c:        pucsr = puart->csr;
device/uart-x86/uartInterrupt.c:            puart->lserr++;
device/uart-x86/uartInterrupt.c:            puart->iirq++;
device/uart-x86/uartInterrupt.c:                if (puart->icount < UART_IBLEN)
device/uart-x86/uartInterrupt.c:                    puart->in[(puart->istart+puart->icount) % UART_IBLEN] = c;
device/uart-x86/uartInterrupt.c:                    puart->icount++;
device/uart-x86/uartInterrupt.c:                    puart->ovrrn++;
device/uart-x86/uartInterrupt.c:            puart->cin += count;
device/uart-x86/uartInterrupt.c:            signaln(puart->isema, count);
device/uart-x86/uartInterrupt.c:            puart->oirq++;
device/uart-x86/uartInterrupt.c:            if (puart->ocount > 0)
device/uart-x86/uartInterrupt.c:                    puart->ocount--;
device/uart-x86/uartInterrupt.c:                    outb((ulong)pucsr+UART_DATA, puart->out[puart->ostart]);
device/uart-x86/uartInterrupt.c:                    puart->ostart = (puart->ostart + 1) % UART_OBLEN;
device/uart-x86/uartInterrupt.c:                } while ((count < UART_FIFO_LEN) && (puart->ocount > 0));
device/uart-x86/uartInterrupt.c:                puart->cout += count;
device/uart-x86/uartInterrupt.c:                signaln(puart->osema, count);
device/uart-x86/uartInterrupt.c:                puart->oidle = TRUE;
device/uart-x86/x86uart.h:#define UART_IIR_IDMASK 0x0E    /**< 3-bit field for interrupt ID       */
device/uart-x86/x86uart.h:#define UART_MCR_OUT2   0x08    /**< User-defined OUT2.                 */
device/uart-x86/x86uart.h:#define UART_LSR_THRE   0x20    /**< Transmit-hold-register empty       */
device/uart/uartControl.c: *      control-function-dependent value.
device/uart/uartControl.c:    uartptr = &uarttab[devptr->minor];
device/uart/uartControl.c:        old = uartptr->iflags & arg1;
device/uart/uartControl.c:        uartptr->iflags |= arg1;
device/uart/uartControl.c:        old = uartptr->iflags & arg1;
device/uart/uartControl.c:        uartptr->iflags &= ~(arg1);
device/uart/uartControl.c:        return uartptr->iflags;
device/uart/uartControl.c:        old = uartptr->oflags & arg1;
device/uart/uartControl.c:        uartptr->oflags |= arg1;
device/uart/uartControl.c:        old = uartptr->oflags & arg1;
device/uart/uartControl.c:        uartptr->oflags &= ~(arg1);
device/uart/uartControl.c:        return uartptr->oflags;
device/uart/uartControl.c:        return uartptr->oidle;
device/uart/uartGetc.c: *      cast to an <code>int</code>.  On read error, invalid device, or end-of
device/uart/uartInit.c:    struct uart *uartptr = &uarttab[devptr->minor];
device/uart/uartInit.c:    uartptr->cout = 0;
device/uart/uartInit.c:    uartptr->cin = 0;
device/uart/uartInit.c:    uartptr->lserr = 0;
device/uart/uartInit.c:    uartptr->ovrrn = 0;
device/uart/uartInit.c:    uartptr->iirq = 0;
device/uart/uartInit.c:    uartptr->oirq = 0;
device/uart/uartInit.c:    uartptr->isema = semcreate(0);
device/uart/uartInit.c:    uartptr->iflags = 0;
device/uart/uartInit.c:    uartptr->istart = 0;
device/uart/uartInit.c:    uartptr->icount = 0;
device/uart/uartInit.c:    if (isbadsem(uartptr->isema))
device/uart/uartInit.c:    uartptr->osema = semcreate(UART_OBLEN);
device/uart/uartInit.c:    uartptr->oflags = 0;
device/uart/uartInit.c:    uartptr->ostart = 0;
device/uart/uartInit.c:    uartptr->ocount = 0;
device/uart/uartInit.c:    uartptr->oidle = 1;
device/uart/uartInit.c:    if (isbadsem(uartptr->osema))
device/uart/uartInit.c:        semfree(uartptr->isema);
device/uart/uartInit.c:        semfree(uartptr->isema);
device/uart/uartInit.c:        semfree(uartptr->osema);
device/uart/uartInit.c:    uartptr->dev = devptr;
device/uart/uartInit.c:    uartptr->csr = devptr->csr;
device/uart/uartRead.c: *      but may be less than @p len if the UART has been set to non-blocking
device/uart/uartRead.c:    uartptr = &uarttab[devptr->minor];
device/uart/uartRead.c:    if (NULL == uartptr->csr)
device/uart/uartRead.c:        /* If the UART is in non-blocking mode, ensure there is a byte available
device/uart/uartRead.c:        if ((uartptr->iflags & UART_IFLAG_NOBLOCK) && uartptr->icount == 0)
device/uart/uartRead.c:        wait(uartptr->isema);
device/uart/uartRead.c:        c = uartptr->in[uartptr->istart];
device/uart/uartRead.c:        uartptr->icount--;
device/uart/uartRead.c:        uartptr->istart = (uartptr->istart + 1) % UART_IBLEN;
device/uart/uartRead.c:        if (uartptr->iflags & UART_IFLAG_ECHO)
device/uart/uartRead.c:            uartPutc(uartptr->dev, c);
device/uart/uartStat.c:    if (NULL == uartptr->dev)
device/uart/uartStat.c:    printf("%s:\n", uartptr->dev->name);
device/uart/uartStat.c:    printf("\t------------------------------------------\n");
device/uart/uartStat.c:    printf("\t%8d Characters Output\n", uartptr->cout);
device/uart/uartStat.c:    printf("\t%8d Characters Input\n", uartptr->cin);
device/uart/uartStat.c:    printf("\t%8d Characters Overrun\n", uartptr->ovrrn);
device/uart/uartStat.c:    printf("\t%8d Receiver Error Count\n", uartptr->lserr);
device/uart/uartStat.c:    printf("\t%8d Output IRQ Count\n", uartptr->oirq);
device/uart/uartStat.c:    printf("\t%8d Input IRQ Count\n", uartptr->iirq);
device/uart/uartStat.c:    if (NULL != uartptr->csr)
device/uart/uartStat.c:        uartHwStat(uartptr->csr);
device/uart/uartWrite.c: *      non-blocking mode.  Returns ::SYSERR on other error (currently, only if
device/uart/uartWrite.c:    uartptr = &uarttab[devptr->minor];
device/uart/uartWrite.c:    if (NULL == uartptr->csr)
device/uart/uartWrite.c:        if (uartptr->oidle)
device/uart/uartWrite.c:            uartHwPutc(uartptr->csr, ch);
device/uart/uartWrite.c:            uartptr->oidle = FALSE;
device/uart/uartWrite.c:            uartptr->cout++;
device/uart/uartWrite.c:            /* If the UART is in non-blocking mode, ensure there is space for a
device/uart/uartWrite.c:            if ((uartptr->oflags & UART_OFLAG_NOBLOCK) &&
device/uart/uartWrite.c:                uartptr->ocount == UART_OBLEN)
device/uart/uartWrite.c:            wait(uartptr->osema);
device/uart/uartWrite.c:            uartptr->out[(uartptr->ostart + uartptr->ocount) % UART_OBLEN] = ch;
device/uart/uartWrite.c:            uartptr->ocount++;
Binary file device/uart/uartControl.o matches
device/uart/uartControl.d:../device/uart-pl011/../uart/uartControl.o: \
device/uart/uartControl.d: ../device/uart-pl011/../uart/uartControl.c ../include/stddef.h \
Binary file device/uart/uartGetc.o matches
device/uart/uartGetc.d:../device/uart-pl011/../uart/uartGetc.o: \
device/uart/uartGetc.d: ../device/uart-pl011/../uart/uartGetc.c ../include/device.h \
Binary file device/uart/uartInit.o matches
device/uart/uartInit.d:../device/uart-pl011/../uart/uartInit.o: \
device/uart/uartInit.d: ../device/uart-pl011/../uart/uartInit.c ../include/uart.h \
Binary file device/uart/uartPutc.o matches
device/uart/uartPutc.d:../device/uart-pl011/../uart/uartPutc.o: \
device/uart/uartPutc.d: ../device/uart-pl011/../uart/uartPutc.c ../include/device.h \
Binary file device/uart/uartRead.o matches
device/uart/uartRead.d:../device/uart-pl011/../uart/uartRead.o: \
device/uart/uartRead.d: ../device/uart-pl011/../uart/uartRead.c ../include/uart.h \
device/uart/uartRead.d: ../system/platforms/arm-rpi3/interrupt.h \
device/uart/uartRead.d: ../system/platforms/arm-rpi3/bcm2837.h
device/uart/uartRead.d:../system/platforms/arm-rpi3/interrupt.h:
device/uart/uartRead.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file device/uart/uartWrite.o matches
device/uart/uartWrite.d:../device/uart-pl011/../uart/uartWrite.o: \
device/uart/uartWrite.d: ../device/uart-pl011/../uart/uartWrite.c ../include/uart.h \
device/uart/uartWrite.d: ../system/platforms/arm-rpi3/interrupt.h \
device/uart/uartWrite.d: ../system/platforms/arm-rpi3/bcm2837.h
device/uart/uartWrite.d:../system/platforms/arm-rpi3/interrupt.h:
device/uart/uartWrite.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file device/uart/uartStat.o matches
device/uart/uartStat.d:../device/uart-pl011/../uart/uartStat.o: \
device/uart/uartStat.d: ../device/uart-pl011/../uart/uartStat.c ../include/stdio.h \
device/uart/uartStat.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
device/uart/uartStat.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
device/uart/uartStat.d:../system/platforms/arm-rpi3/interrupt.h:
device/uart/uartStat.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file device/uart/kprintf.o matches
device/uart/kprintf.d:../device/uart-pl011/../uart/kprintf.o: \
device/uart/kprintf.d: ../device/uart-pl011/../uart/kprintf.c ../include/kernel.h \
device/uart/kprintf.d: ../include/compiler.h ../system/platforms/arm-rpi3/mutex.h
device/uart/kprintf.d:../system/platforms/arm-rpi3/mutex.h:
Binary file device/uart/kvprintf.o matches
device/uart/kvprintf.d:../device/uart-pl011/../uart/kvprintf.o: \
device/uart/kvprintf.d: ../device/uart-pl011/../uart/kvprintf.c ../include/device.h \
device/uart/kvprintf.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
device/uart/kvprintf.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
device/uart/kvprintf.d:../system/platforms/arm-rpi3/interrupt.h:
device/uart/kvprintf.d:../system/platforms/arm-rpi3/bcm2837.h:
device/udp/Doxygroup.c: * @brief Low-level functions mostly internal to the UDP driver.
device/udp/udpChksum.c:    pseu = ((struct udpPseudoHdr *)(pkt->curr)) - 1;
device/udp/udpChksum.c:    memcpy(pseu->srcIp, src->addr, IPv4_ADDR_LEN);
device/udp/udpChksum.c:    memcpy(pseu->dstIp, dst->addr, IPv4_ADDR_LEN);
device/udp/udpChksum.c:    pseu->zero = 0;
device/udp/udpChksum.c:    pseu->proto = IPv4_PROTO_UDP;
device/udp/udpChksum.c:    pseu->len = hs2net(len);
device/udp/udpClose.c: * However, you still must not re-open the UDP device before all udpRead()
device/udp/udpClose.c:    udpptr = &udptab[devptr->minor];
device/udp/udpClose.c:    if (UDP_OPEN != udpptr->state)
device/udp/udpClose.c:    bfpfree(udpptr->inPool);
device/udp/udpClose.c:    semfree(udpptr->isem);
device/udp/udpClose.c:    udpptr->state = UDP_FREE;
device/udp/udpControl.c:    udpptr = &udptab[devptr->minor];
device/udp/udpControl.c:        udpptr->localpt = arg1;
device/udp/udpControl.c:            netaddrcpy(&(udpptr->localip), (struct netaddr *)arg2);
device/udp/udpControl.c:        udpptr->remotept = arg1;
device/udp/udpControl.c:            bzero(&(udpptr->remoteip), sizeof(struct netaddr));
device/udp/udpControl.c:            netaddrcpy(&(udpptr->remoteip), (struct netaddr *)arg2);
device/udp/udpControl.c:        old = udpptr->flags & arg1;
device/udp/udpControl.c:        udpptr->flags &= ~arg1;
device/udp/udpControl.c:        old = udpptr->flags & arg1;
device/udp/udpControl.c:        udpptr->flags |= arg1;
device/udp/udpDemux.c: * @pre-condition interrupts are already disabled
device/udp/udpDemux.c: * @post-condition interrupts are still disabled
device/udp/udpGetbuf.c:    udppkt = bufget(udpptr->inPool);
device/udp/udpInit.c:    udpptr = &udptab[devptr->minor];
device/udp/udpOpen.c: *     - The local IP address.
device/udp/udpOpen.c: *     - The remote IP address.  May be @c NULL to create an initially
device/udp/udpOpen.c: *     - The local port.  May be 0 to auto-assign a port number.
device/udp/udpOpen.c: *     - The remote port.  May be 0 if creating an initially unbound socket.
device/udp/udpOpen.c:    udpptr = &udptab[devptr->minor];
device/udp/udpOpen.c:    if (UDP_OPEN == udpptr->state)
device/udp/udpOpen.c:        UDP_TRACE("udp%d has already been opened.", devptr->minor);
device/udp/udpOpen.c:    udpptr->state = UDP_OPEN;
device/udp/udpOpen.c:    udpptr->dev = devptr;
device/udp/udpOpen.c:    udpptr->icount = 0;
device/udp/udpOpen.c:    udpptr->istart = 0;
device/udp/udpOpen.c:    udpptr->isem = semcreate(0);
device/udp/udpOpen.c:    if (SYSERR == (int)udpptr->isem)
device/udp/udpOpen.c:    netaddrcpy(&udpptr->localip, localip);
device/udp/udpOpen.c:        bzero(&udpptr->remoteip, sizeof(struct netaddr));
device/udp/udpOpen.c:        netaddrcpy(&udpptr->remoteip, remoteip);
device/udp/udpOpen.c:    udpptr->localpt = localpt;
device/udp/udpOpen.c:    udpptr->remotept = remotept;
device/udp/udpOpen.c:    udpptr->inPool = bfpalloc(NET_MAX_PKTLEN, UDP_MAX_PKTS);
device/udp/udpOpen.c:    if (SYSERR == (int)udpptr->inPool)
device/udp/udpOpen.c:              devptr->minor, udpptr->inPool);
device/udp/udpOpen.c:    udpptr->flags = 0;
device/udp/udpOpen.c:    udpptr->localpt = 0;
device/udp/udpOpen.c:    semfree(udpptr->isem);
device/udp/udpOpen.c:    udpptr->state = UDP_FREE;
device/udp/udpOpen.c:    nextport = (nextport + 1) % (UDP_PMAX - UDP_PSTART);
device/udp/udpOpen.c:            nextport = (nextport + 1) % (UDP_PMAX - UDP_PSTART);
device/udp/udpRead.c: * be the UDP pseudo-header, directly followed by the UDP header, directly
device/udp/udpRead.c: *      cases it will be 0 if the UDP is in non-blocking mode and no packets are
device/udp/udpRead.c:    udpptr = &udptab[devptr->minor];
device/udp/udpRead.c:    if (UDP_OPEN != udpptr->state)
device/udp/udpRead.c:    /* If the UDP device is in non-blocking mode, require that at least one UDP
device/udp/udpRead.c:    if ((udpptr->flags & UDP_FLAG_NOBLOCK) && (udpptr->icount < 1))
device/udp/udpRead.c:    wait(udpptr->isem);
device/udp/udpRead.c:    if (UDP_OPEN != udpptr->state)
device/udp/udpRead.c:    pseudo = (const struct udpPseudoHdr *)udpptr->in[udpptr->istart];
device/udp/udpRead.c:    udpptr->istart = (udpptr->istart + 1) % UDP_MAX_PKTS;
device/udp/udpRead.c:    udpptr->icount--;
device/udp/udpRead.c:    /* Set pointer to the UDP header, which directly follows the pseudo-header.
device/udp/udpRead.c:    if (UDP_FLAG_PASSIVE & udpptr->flags)
device/udp/udpRead.c:        count = udppkt->len + sizeof(struct udpPseudoHdr);
device/udp/udpRead.c:        count = udppkt->len - UDP_HDR_LEN;
device/udp/udpRead.c:        data = udppkt->data;
device/udp/udpRecv.c:    udppkt = (struct udpPkt *)pkt->curr;
device/udp/udpRecv.c:    if ((udppkt->chksum)
device/udp/udpRecv.c:        && (0 != udpChksum(pkt, net2hs(udppkt->len), src, dst)))
device/udp/udpRecv.c:    udppkt->srcPort = net2hs(udppkt->srcPort);
device/udp/udpRecv.c:    udppkt->dstPort = net2hs(udppkt->dstPort);
device/udp/udpRecv.c:    udppkt->len = net2hs(udppkt->len);
device/udp/udpRecv.c:    udpptr = udpDemux(udppkt->dstPort, udppkt->srcPort, dst, src);
device/udp/udpRecv.c:                  udppkt->srcPort, strB, udppkt->dstPort);
device/udp/udpRecv.c:        udppkt->srcPort = hs2net(udppkt->srcPort);
device/udp/udpRecv.c:        udppkt->dstPort = hs2net(udppkt->dstPort);
device/udp/udpRecv.c:        udppkt->len = hs2net(udppkt->len);
device/udp/udpRecv.c:    if (udpptr->icount >= UDP_MAX_PKTS)
device/udp/udpRecv.c:    if (UDP_FLAG_BINDFIRST & udpptr->flags)
device/udp/udpRecv.c:        udpptr->remotept = udppkt->srcPort;
device/udp/udpRecv.c:        netaddrcpy(&(udpptr->localip), dst);
device/udp/udpRecv.c:        netaddrcpy(&(udpptr->remoteip), src);
device/udp/udpRecv.c:        udpptr->flags &= ~UDP_FLAG_BINDFIRST;
device/udp/udpRecv.c:    memcpy(pseudo->srcIp, src->addr, IPv4_ADDR_LEN);
device/udp/udpRecv.c:    memcpy(pseudo->dstIp, dst->addr, IPv4_ADDR_LEN);
device/udp/udpRecv.c:    pseudo->zero = 0;
device/udp/udpRecv.c:    pseudo->proto = IPv4_PROTO_UDP;
device/udp/udpRecv.c:    pseudo->len = udppkt->len;
device/udp/udpRecv.c:    memcpy((pseudo + 1), udppkt, udppkt->len);
device/udp/udpRecv.c:    udpptr->in[(udpptr->istart + udpptr->icount) % UDP_MAX_PKTS] = tpkt;
device/udp/udpRecv.c:    udpptr->icount++;
device/udp/udpRecv.c:    signal(udpptr->isem);
device/udp/udpSend.c: *      the length of the UDP pseudo-header plus UDP header).
device/udp/udpSend.c: *      will interpreted as the UDP pseudo-header follewed by the UDP header
device/udp/udpSend.c:    netaddrcpy(&localip, &(udpptr->localip));
device/udp/udpSend.c:    netaddrcpy(&remoteip, &(udpptr->remoteip));
device/udp/udpSend.c:    if (udpptr->flags & UDP_FLAG_PASSIVE)
device/udp/udpSend.c:        datalen -= sizeof(struct udpPseudoHdr);
device/udp/udpSend.c:        pkt->len = datalen;
device/udp/udpSend.c:        pkt->curr -= (3 + (ulong)(pkt->len)) & ~0x03;
device/udp/udpSend.c:        memcpy(pkt->curr, (pseudo + 1), datalen);
device/udp/udpSend.c:        udppkt = (struct udpPkt *)(pkt->curr);
device/udp/udpSend.c:        udppkt->srcPort = hs2net(udppkt->srcPort);
device/udp/udpSend.c:        udppkt->dstPort = hs2net(udppkt->dstPort);
device/udp/udpSend.c:        udppkt->len = hs2net(pkt->len);
device/udp/udpSend.c:        udppkt->chksum = 0;
device/udp/udpSend.c:        memcpy(&remoteip.addr, pseudo->dstIp, remoteip.len);
device/udp/udpSend.c:        if (0 != memcmp(&localip.addr, pseudo->srcIp, localip.len))
device/udp/udpSend.c:        pkt->len = datalen;
device/udp/udpSend.c:        pkt->curr -= (3 + (ulong)(pkt->len)) & ~0x03;
device/udp/udpSend.c:        udppkt = (struct udpPkt *)(pkt->curr);
device/udp/udpSend.c:        udppkt->srcPort = hs2net(udpptr->localpt);
device/udp/udpSend.c:        udppkt->dstPort = hs2net(udpptr->remotept);
device/udp/udpSend.c:        udppkt->len = hs2net(pkt->len);
device/udp/udpSend.c:        udppkt->chksum = 0;
device/udp/udpSend.c:        memcpy(udppkt->data, buf, datalen - UDP_HDR_LEN);
device/udp/udpSend.c:    udppkt->chksum = udpChksum(pkt, datalen, &localip, &remoteip);
device/udp/udpWrite.c: *      pseudo-header, followed by the UDP header, followed by the UDP payload.
device/udp/udpWrite.c:    udpptr = &udptab[devptr->minor];
device/udp/udpWrite.c:    if (udpptr->flags & UDP_FLAG_PASSIVE)
device/udp/udpWrite.c:        if (0 == udpptr->remotept || 0 == udpptr->remoteip.type)
device/udp/udpWrite.c:            uint bytes_remaining = len - count;
device/usb/Doxygroup.c: * @brief Platform-dependent code to actually send and receive data over the USB
device/usb/usbcore.c: *  - This driver is written to be compatible with USB 2.0.  USB 3.0 devices
device/usb/usbcore.c: *  - Not all USB transfer types and speeds are necessarily supported.  This
device/usb/usbcore.c: *  - This driver does not attempt to do any intelligent power management,
device/usb/usbcore.c: *  - This driver is assumed to drive a single USB (bus).  Multiple USBs are not
device/usb/usbcore.c: *  - This driver does not support multiple configurations per USB device.  If
device/usb/usbcore.c: *  - This driver is currently written to support binding drivers to USB
device/usb/usbcore.c: *  - By design, it is possible to implement a host controller driver for
device/usb/usbcore.c: *  - By design, this driver has a hard-coded dependency on the USB hub driver
device/usb/usbcore.c: * Performs one-time initialization on a USB transfer request allocated by the
device/usb/usbcore.c:    /* TODO: HCD-specific variables need to be handled better.  */
device/usb/usbcore.c:    req->deferer_thread_tid = BADTID;
device/usb/usbcore.c:    req->deferer_thread_sema = SYSERR;
device/usb/usbcore.c:    req->sendbuf = (uint8_t*)(req + 1);
device/usb/usbcore.c:    req->size = bufsize;
device/usb/usbcore.c: *      currently pending.  NULL can be passed as a no-op.
device/usb/usbcore.c:        /* TODO: HCD-specific variables need to be handled better.  */
device/usb/usbcore.c:        kill(req->deferer_thread_tid);
device/usb/usbcore.c:        semfree(req->deferer_thread_sema);
device/usb/usbcore.c:        memfree(req, sizeof(struct usb_xfer_request) + req->size);
device/usb/usbcore.c: * failed request and either free its memory or re-submit it to start another
device/usb/usbcore.c: * High-Speed USB 2.0 On-The-Go Controller (the one on the Raspberry Pi) is
device/usb/usbcore.c:    if (!req || !req->dev || !req->completion_cb_func ||
device/usb/usbcore.c:        !req->dev->inuse)
device/usb/usbcore.c:    if (req->dev->state == USB_DEVICE_DETACHMENT_PENDING)
device/usb/usbcore.c:        usb_dev_debug(req->dev, "Device detachment pending; "
device/usb/usbcore.c:    if (req->endpoint_desc)
device/usb/usbcore.c:        type = req->endpoint_desc->bmAttributes & 0x3;
device/usb/usbcore.c:        dir = req->endpoint_desc->bEndpointAddress >> 7;
device/usb/usbcore.c:        dir = req->setup_data.bmRequestType >> 7;
device/usb/usbcore.c:    usb_dev_debug(req->dev, "Submitting xfer request (%u bytes, "
device/usb/usbcore.c:                  req->size,
device/usb/usbcore.c:        usb_dev_debug(req->dev, "Control message: {.bmRequestType=0x%02x, "
device/usb/usbcore.c:                      req->setup_data.bmRequestType,
device/usb/usbcore.c:                      req->setup_data.bRequest,
device/usb/usbcore.c:                      req->setup_data.wValue,
device/usb/usbcore.c:                      req->setup_data.wIndex,
device/usb/usbcore.c:                      req->setup_data.wLength);
device/usb/usbcore.c:    req->status = USB_STATUS_NOT_PROCESSED;
device/usb/usbcore.c:    req->actual_size = 0;
device/usb/usbcore.c:    req->complete_split = 0;
device/usb/usbcore.c:    req->control_phase = 0;
device/usb/usbcore.c:    ++req->dev->xfer_pending_count;
device/usb/usbcore.c:        --req->dev->xfer_pending_count;
device/usb/usbcore.c:    --req->dev->xfer_pending_count;
device/usb/usbcore.c:    if (req->dev->state == USB_DEVICE_DETACHMENT_PENDING)
device/usb/usbcore.c:        req->status = USB_STATUS_DEVICE_DETACHED;
device/usb/usbcore.c:    usb_dev_debug(req->dev,
device/usb/usbcore.c:                  req->actual_size, req->size,
device/usb/usbcore.c:                        req->endpoint_desc ?
device/usb/usbcore.c:                            (req->endpoint_desc->bmAttributes & 0x3) :
device/usb/usbcore.c:                        req->endpoint_desc ?
device/usb/usbcore.c:                            (req->endpoint_desc->bEndpointAddress >> 7) :
device/usb/usbcore.c:                            req->setup_data.bmRequestType >> 7),
device/usb/usbcore.c:                  req->status);
device/usb/usbcore.c:    if (req->status != USB_STATUS_SUCCESS)
device/usb/usbcore.c:        req->dev->error_count++;
device/usb/usbcore.c:        req->dev->last_error = req->status;
device/usb/usbcore.c:    (*req->completion_cb_func)(req);
device/usb/usbcore.c:    if (req->dev->state == USB_DEVICE_DETACHMENT_PENDING &&
device/usb/usbcore.c:        req->dev->xfer_pending_count == 0)
device/usb/usbcore.c:        send(req->dev->quiescent_state_waiter, 0);
device/usb/usbcore.c:    signal((semaphore)req->private);
device/usb/usbcore.c: *      ::usb_device_request values.  Other values, such as class-specific
device/usb/usbcore.c: *      Request-specific data.
device/usb/usbcore.c: *      Request-specific data.
device/usb/usbcore.c:    req->dev = dev;
device/usb/usbcore.c:    req->endpoint_desc = endpoint_desc;
device/usb/usbcore.c:    req->recvbuf = data;
device/usb/usbcore.c:    req->size = wLength;
device/usb/usbcore.c:    req->setup_data.bmRequestType = bmRequestType;
device/usb/usbcore.c:    req->setup_data.bRequest = bRequest;
device/usb/usbcore.c:    req->setup_data.wValue = wValue;
device/usb/usbcore.c:    req->setup_data.wIndex = wIndex;
device/usb/usbcore.c:    req->setup_data.wLength = wLength;
device/usb/usbcore.c:    req->completion_cb_func = signal_control_msg_done;
device/usb/usbcore.c:    req->private = (void*)sem;
device/usb/usbcore.c:        status = req->status;
device/usb/usbcore.c:        if (status == USB_STATUS_SUCCESS && req->actual_size != req->size)
device/usb/usbcore.c:            req->dev->error_count++;
device/usb/usbcore.c:            req->dev->last_error = status;
device/usb/usbcore.c: * dev->descriptor.  */
device/usb/usbcore.c:                           &dev->descriptor, maxlen);
device/usb/usbcore.c: * allocated dev->config_descriptor buffer.  Assumes this buffer is initially
device/usb/usbcore.c:    dev->config_descriptor = memget(desc.wTotalLength);
device/usb/usbcore.c:    if (dev->config_descriptor == (void*)SYSERR)
device/usb/usbcore.c:                                              dev->config_descriptor,
device/usb/usbcore.c:    interface_idx = -1;
device/usb/usbcore.c:    endpoint_idx = -1;
device/usb/usbcore.c:         i += hdr->bLength)
device/usb/usbcore.c:        hdr = (struct usb_descriptor_header*)((uint8_t*)dev->config_descriptor + i);
device/usb/usbcore.c:        if (hdr->bLength < sizeof(struct usb_descriptor_header))
device/usb/usbcore.c:        switch (hdr->bDescriptorType)
device/usb/usbcore.c:                            dev->interfaces[interface_idx]->bNumEndpoints)
device/usb/usbcore.c:                if (((struct usb_interface_descriptor*)hdr)->bAlternateSetting != 0)
device/usb/usbcore.c:                    dev->interfaces[interface_idx] =
device/usb/usbcore.c:                    endpoint_idx = -1;
device/usb/usbcore.c:                    dev->endpoints[interface_idx][endpoint_idx] =
device/usb/usbcore.c:    if (interface_idx + 1 != dev->config_descriptor->bNumInterfaces)
device/usb/usbcore.c:        dev->address = address;
device/usb/usbcore.c:        dev->configuration = configuration;
device/usb/usbcore.c:            dev->inuse = TRUE;
device/usb/usbcore.c:            dev->speed = USB_SPEED_HIGH; /* Default to high-speed unless
device/usb/usbcore.c:            dev->parent = parent;
device/usb/usbcore.c:                dev->depth = parent->depth + 1;
device/usb/usbcore.c:            dev->last_error = USB_STATUS_SUCCESS;
device/usb/usbcore.c:            dev->state = USB_DEVICE_ATTACHED;
device/usb/usbcore.c:            dev->quiescent_state_waiter = BADTID;
device/usb/usbcore.c:    dev->state = USB_DEVICE_DETACHMENT_PENDING;
device/usb/usbcore.c:    if (dev->xfer_pending_count != 0)
device/usb/usbcore.c:                      dev->xfer_pending_count);
device/usb/usbcore.c:        dev->quiescent_state_waiter = gettid();
device/usb/usbcore.c:    if (dev->driver != NULL && dev->driver->unbind_device != NULL)
device/usb/usbcore.c:        usb_dev_debug(dev, "Unbinding %s\r\n", dev->driver->name);
device/usb/usbcore.c:        dev->driver->unbind_device(dev);
device/usb/usbcore.c:    if (dev->config_descriptor != NULL)
device/usb/usbcore.c:        memfree(dev->config_descriptor, dev->config_descriptor->wTotalLength);
device/usb/usbcore.c:    dev->inuse = FALSE;
device/usb/usbcore.c:    if (dev->driver != NULL)
device/usb/usbcore.c:                      usb_device_drivers[i]->name);
device/usb/usbcore.c:        status = usb_device_drivers[i]->bind_device(dev);
device/usb/usbcore.c:                dev->driver = usb_device_drivers[i];
device/usb/usbcore.c:                usb_info("Bound %s to %s\r\n", dev->driver->name,
device/usb/usbcore.c: * physical device is initially assumed to be non-addressed and non-configured
device/usb/usbcore.c:    dev->descriptor.bMaxPacketSize0 = 8;
device/usb/usbcore.c:    usb_dev_debug(dev, "Using bMaxPacketSize0=%u\r\n", dev->descriptor.bMaxPacketSize0);
device/usb/usbcore.c:     * the 1-based index of the `struct usb_device' in the usb_devices table. */
device/usb/usbcore.c:    address = (dev - usb_devices) + 1;
device/usb/usbcore.c:    status = usb_read_device_descriptor(dev, sizeof(dev->descriptor));
device/usb/usbcore.c:    if (dev->descriptor.iProduct != 0)
device/usb/usbcore.c:        usb_get_ascii_string(dev, dev->descriptor.iProduct,
device/usb/usbcore.c:                             dev->product, sizeof(dev->product));
device/usb/usbcore.c:    if (dev->descriptor.iManufacturer != 0)
device/usb/usbcore.c:        usb_get_ascii_string(dev, dev->descriptor.iManufacturer,
device/usb/usbcore.c:                             dev->manufacturer, sizeof(dev->manufacturer));
device/usb/usbcore.c:                  dev->config_descriptor->bConfigurationValue,
device/usb/usbcore.c:                  dev->config_descriptor->bNumInterfaces);
device/usb/usbcore.c:                                   dev->config_descriptor->bConfigurationValue);
device/usb/usbcore.c:    if (NULL == drv->bind_device)
device/usb/usbcore.c:            usb_info("Registered %s\r\n", drv->name);
device/usb/usbcore.c: * proceeds in an interrupt-driven manner and continues after this function
device/usb/usbdebug.c: * - Printing debugging, informational, and error messages
device/usb/usbdebug.c: * - Printing the state of the USB (through usbinfo()).
device/usb/usbdebug.c: * - Obtaining human-readable string descriptors from USB devices.
device/usb/usbdebug.c: * - Translating certain constants into strings describing them.
device/usb/usbdebug.c:		kprintf("Device %u: ", dev->address);
device/usb/usbdebug.c: * Lazy conversion from UTF-16LE to ASCII that replaces non-ASCII UTF-16LE code
device/usb/usbdebug.c: * "translates" it from UTF-16LE to ASCII.  The resulting string is
device/usb/usbdebug.c: * null-terminated.  UTF-16LE codepoints outside the ASCII range are simply
device/usb/usbdebug.c:	num_languages = (buf.desc.bLength - sizeof(struct usb_descriptor_header)) /
device/usb/usbdebug.c:	/* "Translate" the string from UTF-16LE to ASCII.  */
device/usb/usbdebug.c:	num_chars = min((buf.desc.bLength - sizeof(struct usb_descriptor_header)) /
device/usb/usbdebug.c:			sizeof(uint16_t), strbufsize - 1);
device/usb/usbdebug.c: * Translates a bcdUSB (binary-coded-decimal USB version) value into a
device/usb/usbdebug.c: * human-readable string.
device/usb/usbdebug.c: * Returns a fairly detailed, human-readable description of a USB device.
device/usb/usbdebug.c:	p += sprintf(p, "%s-speed USB %s",
device/usb/usbdebug.c:			usb_speed_to_string(dev->speed),
device/usb/usbdebug.c:			usb_bcd_version_to_string(dev->descriptor.bcdUSB));
device/usb/usbdebug.c:	class = dev->descriptor.bDeviceClass;
device/usb/usbdebug.c:		for (i = 0; i < dev->config_descriptor->bNumInterfaces; i++)
device/usb/usbdebug.c:			if (dev->interfaces[i]->bInterfaceClass != 0)
device/usb/usbdebug.c:				class = dev->interfaces[i]->bInterfaceClass;
device/usb/usbdebug.c:	if (dev->product[0] != '\0')
device/usb/usbdebug.c:		p += sprintf(p, " (%s)", dev->product);
device/usb/usbdebug.c:			dev->descriptor.idVendor,
device/usb/usbdebug.c:			dev->descriptor.idProduct);
device/usb/usbdebug.c:	printf("    bLength:             %u\n", desc->bLength);
device/usb/usbdebug.c:	printf("    bDescriptorType:     0x%02x (Device)\n", desc->bDescriptorType);
device/usb/usbdebug.c:			desc->bcdUSB, usb_bcd_version_to_string(desc->bcdUSB));
device/usb/usbdebug.c:			desc->bDeviceClass, usb_class_code_to_string(desc->bDeviceClass));
device/usb/usbdebug.c:	printf("    bDeviceSubClass:     0x%02x\n", desc->bDeviceSubClass);
device/usb/usbdebug.c:	printf("    bDeviceProtocol:     0x%02x\n", desc->bDeviceProtocol);
device/usb/usbdebug.c:	printf("    bMaxPacketSize0:     %u\n", desc->bMaxPacketSize0);
device/usb/usbdebug.c:	printf("    idVendor:            0x%04x\n", desc->idVendor);
device/usb/usbdebug.c:	printf("    idProduct:           0x%04x\n", desc->idProduct);
device/usb/usbdebug.c:	printf("    iManufacturer:       %u\n", desc->iManufacturer);
device/usb/usbdebug.c:	if (dev->manufacturer[0] != '\0')
device/usb/usbdebug.c:		printf("        (%s)\n", dev->manufacturer);
device/usb/usbdebug.c:	printf("    iProduct:            %u\n", desc->iProduct);
device/usb/usbdebug.c:	if (dev->product[0] != '\0')
device/usb/usbdebug.c:		printf("        (%s)\n", dev->product);
device/usb/usbdebug.c:	printf("    iSerialNumber:       %u\n", desc->iSerialNumber);
device/usb/usbdebug.c:	printf("    bNumConfigurations:  %u\n", desc->bNumConfigurations);
device/usb/usbdebug.c:	printf("        bLength:             %u\n", desc->bLength);
device/usb/usbdebug.c:			desc->bDescriptorType);
device/usb/usbdebug.c:	printf("        wTotalLength:        %u\n", desc->wTotalLength);
device/usb/usbdebug.c:	printf("        bNumInterfaces:      %u\n", desc->bNumInterfaces);
device/usb/usbdebug.c:	printf("        bConfigurationValue: %u\n", desc->bConfigurationValue);
device/usb/usbdebug.c:	printf("        iConfiguration:      %u\n", desc->iConfiguration);
device/usb/usbdebug.c:	printf("        bmAttributes:        0x%02x\n", desc->bmAttributes);
device/usb/usbdebug.c:	if (desc->bmAttributes & USB_CONFIGURATION_ATTRIBUTE_SELF_POWERED)
device/usb/usbdebug.c:	if (desc->bmAttributes & USB_CONFIGURATION_ATTRIBUTE_REMOTE_WAKEUP)
device/usb/usbdebug.c:			desc->bMaxPower, desc->bMaxPower * 2);
device/usb/usbdebug.c:	printf("            bLength:             %u\n", desc->bLength);
device/usb/usbdebug.c:	printf("            bDescriptorType:     0x%02x (Interface)\n", desc->bDescriptorType);
device/usb/usbdebug.c:	printf("            bInterfaceNumber:    %u\n", desc->bInterfaceNumber);
device/usb/usbdebug.c:	printf("            bAlternateSetting:   %u\n", desc->bAlternateSetting);
device/usb/usbdebug.c:	printf("            bNumEndpoints:       %u\n", desc->bNumEndpoints);
device/usb/usbdebug.c:	printf("            bInterfaceClass:     0x%02x (%s)\n", desc->bInterfaceClass,
device/usb/usbdebug.c:			usb_class_code_to_string(desc->bInterfaceClass));
device/usb/usbdebug.c:	printf("            bInterfaceSubClass:  0x%02x\n", desc->bInterfaceSubClass);
device/usb/usbdebug.c:	printf("            bInterfaceProtocol:  0x%02x\n", desc->bInterfaceProtocol);
device/usb/usbdebug.c:	printf("            iInterface:          %u\n", desc->iInterface);
device/usb/usbdebug.c:	printf("                bLength:             %u\n", desc->bLength);
device/usb/usbdebug.c:	printf("                bDescriptorType:     0x%02x (Endpoint)\n", desc->bDescriptorType);
device/usb/usbdebug.c:			desc->bEndpointAddress, desc->bEndpointAddress & 0xf,
device/usb/usbdebug.c:			((desc->bEndpointAddress >> 7) ? "IN" : "OUT"));
device/usb/usbdebug.c:			desc->bmAttributes,
device/usb/usbdebug.c:			((desc->bmAttributes & 0x3) == USB_TRANSFER_TYPE_CONTROL ? "control" :
device/usb/usbdebug.c:			 (desc->bmAttributes & 0x3) == USB_TRANSFER_TYPE_ISOCHRONOUS ? "isochronous" :
device/usb/usbdebug.c:			 (desc->bmAttributes & 0x3) == USB_TRANSFER_TYPE_BULK ? "bulk" :
device/usb/usbdebug.c:			desc->wMaxPacketSize, desc->wMaxPacketSize & 0x7ff);
device/usb/usbdebug.c:	printf("                bInterval:           %u\n", desc->bInterval);
device/usb/usbdebug.c:	usb_print_configuration_descriptor(dev, dev->config_descriptor);
device/usb/usbdebug.c:	for (i = 0; i < dev->config_descriptor->bNumInterfaces; i++)
device/usb/usbdebug.c:		usb_print_interface_descriptor(dev, dev->interfaces[i]);
device/usb/usbdebug.c:		for (j = 0; j < dev->interfaces[i]->bNumEndpoints; j++)
device/usb/usbdebug.c:			usb_print_endpoint_descriptor(dev, dev->endpoints[i][j]);
device/usb/usbdebug.c:	printf("[USB Device %03u]\n", dev->address);
device/usb/usbdebug.c:	usb_print_device_descriptor(dev, &dev->descriptor);
device/usb/usbdebug.c:	if (dev->depth != 0)
device/usb/usbdebug.c:		n = (dev->depth - 1) * USBINFO_TREE_SPACES_PER_LEVEL;
device/usb/usbdebug.c:			putchar('-');
device/usb/usbdebug.c://			kprintf("-");
device/usb/usbdebug.c:	printf("%03u [%s]\n", dev->address, usb_device_description(dev));
device/usb/usbdebug.c://	kprintf("%03u [%s]\r\n", dev->address, usb_device_description(dev));
device/usb/usbhub.c: * That is, a USB is a tree of devices where the root node and all non-leaf
device/usb/usbhub.c: * hub, and if so, then doing hub-specific setup, including one-time driver
device/usb/usbhub.c: * changed--- for example, when a USB device has been connected or disconnected
device/usb/usbhub.c: * interrupt-driven and is not implemented by polling at the software level.
device/usb/usbhub.c:    /** Number of this port (1-based)  */
device/usb/usbhub.c:    /** Reserve space for the variable-length data at the end of the hub
device/usb/usbhub.c:/** Hub-specific data structures.  */
device/usb/usbhub.c:/* Reads the hub descriptor and saves it in hub->descriptor.  Note: the hub
device/usb/usbhub.c: * descriptor is a class-specific descriptor and is NOT the same as the generic
device/usb/usbhub.c:    usb_dev_debug(hub->device, "Reading hub descriptor.\r\n");
device/usb/usbhub.c:    status = usb_get_descriptor(hub->device,
device/usb/usbhub.c:                                &hub->descriptor, sizeof(hub->descriptor) +
device/usb/usbhub.c:                                                  sizeof(hub->descriptor_varData));
device/usb/usbhub.c:        usb_dev_error(hub->device, "Failed to read hub descriptor: %s\r\n",
device/usb/usbhub.c:/* Retrieves the status of a USB port and saves it in port->status.  */
device/usb/usbhub.c:    usb_dev_debug(port->hub->device,
device/usb/usbhub.c:                  "Retrieving status of port %u\r\n", port->number);
device/usb/usbhub.c:    status = usb_control_msg(port->hub->device, NULL,
device/usb/usbhub.c:                             0, port->number,
device/usb/usbhub.c:                             &port->status, sizeof(port->status));
device/usb/usbhub.c:    usb_dev_debug(port->hub->device, "Got port status\r\n");
device/usb/usbhub.c:        usb_dev_error(port->hub->device,
device/usb/usbhub.c:                      port->number, usb_status_string(status));
device/usb/usbhub.c:    return usb_control_msg(port->hub->device, NULL,
device/usb/usbhub.c:                           feature, port->number, NULL, 0);
device/usb/usbhub.c:    usb_dev_debug(port->hub->device, "Resetting port %u\r\n", port->number);
device/usb/usbhub.c:    for (i = 0; i < USB_PORT_RESET_TIMEOUT && port->status.reset;
device/usb/usbhub.c:        usb_dev_error(port->hub->device, "Failed to reset port %u: %s\r\n",
device/usb/usbhub.c:                      port->number, usb_status_string(status));
device/usb/usbhub.c:    new_device = usb_alloc_device(port->hub->device);
device/usb/usbhub.c:    if (port->status.high_speed_attached)
device/usb/usbhub.c:        new_device->speed = USB_SPEED_HIGH;
device/usb/usbhub.c:    else if (port->status.low_speed_attached)
device/usb/usbhub.c:        new_device->speed = USB_SPEED_LOW;
device/usb/usbhub.c:        new_device->speed = USB_SPEED_FULL;
device/usb/usbhub.c:    usb_dev_info(port->hub->device,
device/usb/usbhub.c:                 "New %s-speed device connected to port %u\r\n",
device/usb/usbhub.c:                 usb_speed_to_string(new_device->speed), port->number);
device/usb/usbhub.c:    new_device->port_number = port->number;
device/usb/usbhub.c:        usb_dev_error(port->hub->device,
device/usb/usbhub.c:                      port->number, usb_status_string(status));
device/usb/usbhub.c:    port->child = new_device;
device/usb/usbhub.c:    if (port->child != NULL)
device/usb/usbhub.c:        usb_dev_debug(port->hub->device, "Port %u: device detached.\r\n",
device/usb/usbhub.c:                      port->number);
device/usb/usbhub.c:        usb_info("Detaching %s\r\n", usb_device_description(port->child));
device/usb/usbhub.c:        usb_free_device(port->child);
device/usb/usbhub.c:        port->child = NULL;
device/usb/usbhub.c:     * stored in port->status and is not the same as the 'status' value
device/usb/usbhub.c:    usb_dev_debug(port->hub->device,
device/usb/usbhub.c:                  port->number,
device/usb/usbhub.c:                  port->status.wPortStatus,
device/usb/usbhub.c:                  port->status.wPortChange);
device/usb/usbhub.c:    if (port->status.connected_changed)
device/usb/usbhub.c:        usb_dev_debug(port->hub->device, "Port %u: device now %s\r\n",
device/usb/usbhub.c:                      port->number,
device/usb/usbhub.c:                      (port->status.connected ? "connected" : "disconnected"));
device/usb/usbhub.c:        if (port->status.connected)
device/usb/usbhub.c:    if (port->status.enabled_changed)
device/usb/usbhub.c:    if (port->status.reset_changed)
device/usb/usbhub.c:    if (port->status.suspended_changed)
device/usb/usbhub.c:    if (port->status.overcurrent_changed)
device/usb/usbhub.c:            int hub_id = (int)dev->driver_private;
device/usb/usbhub.c:            for (i = 0; i < hub->descriptor.bNbrPorts; i++)
device/usb/usbhub.c:                usb_hub_for_device_in_tree(hub->ports[i].child, callback);
device/usb/usbhub.c: * Each status change requests is re-submitted after it has been processed.
device/usb/usbhub.c:            hub_id = 31 - __builtin_clz(hub_status_change_pending);
device/usb/usbhub.c:            if (req->status == USB_STATUS_SUCCESS)
device/usb/usbhub.c:                usb_dev_debug(req->dev, "Processing hub status change\r\n");
device/usb/usbhub.c:                for (i = 0; i < req->actual_size; i++)
device/usb/usbhub.c:                    portmask |= (uint32_t)((uint8_t*)req->recvbuf)[i] << (i * 8);
device/usb/usbhub.c:                for (i = 0; i < hub->descriptor.bNbrPorts; i++)
device/usb/usbhub.c:                        port_status_changed(&hub->ports[i]);
device/usb/usbhub.c:                usb_dev_error(req->dev, "Status change request failed: %s\r\n",
device/usb/usbhub.c:                              usb_status_string(req->status));
device/usb/usbhub.c:            /* Re-submit the status change request.  */
device/usb/usbhub.c:            usb_dev_debug(req->dev, "Re-submitting status change request\r\n");
device/usb/usbhub.c:    hub_id = req - hub_status_change_requests;
device/usb/usbhub.c:    if (hub->descriptor.bNbrPorts > HUB_MAX_PORTS)
device/usb/usbhub.c:        usb_dev_error(hub->device,
device/usb/usbhub.c:                      hub->descriptor.bNbrPorts, HUB_MAX_PORTS);
device/usb/usbhub.c:    for (i = 0; i < hub->descriptor.bNbrPorts; i++)
device/usb/usbhub.c:        hub->ports[i].hub = hub;
device/usb/usbhub.c:        hub->ports[i].number = i + 1;
device/usb/usbhub.c:    usb_dev_debug(hub->device, "Powering on %u USB ports\r\n",
device/usb/usbhub.c:                  hub->descriptor.bNbrPorts);
device/usb/usbhub.c:    for (i = 0; i < hub->descriptor.bNbrPorts; i++)
device/usb/usbhub.c:        status = port_set_feature(&hub->ports[i], USB_PORT_POWER);
device/usb/usbhub.c:            usb_dev_error(hub->device,
device/usb/usbhub.c:     * from the time the power-on sequence begins on a port until power is good
device/usb/usbhub.c:    sleep(2 * hub->descriptor.bPwrOn2PwrGood);
device/usb/usbhub.c:    if (dev->descriptor.bDeviceClass != USB_CLASS_CODE_HUB ||
device/usb/usbhub.c:        dev->config_descriptor->bNumInterfaces != 1 ||
device/usb/usbhub.c:        dev->interfaces[0]->bNumEndpoints != 1 ||
device/usb/usbhub.c:        (dev->endpoints[0][0]->bmAttributes & 0x3) !=
device/usb/usbhub.c:    /* Do one-time initialization of the hub driver.  */
device/usb/usbhub.c:    /* Allocate per-hub data.  */
device/usb/usbhub.c:    hub->device = dev;
device/usb/usbhub.c:                  (hub->descriptor.wHubCharacteristics &
device/usb/usbhub.c:                  hub->descriptor.bNbrPorts);
device/usb/usbhub.c:    hub_status_change_requests[hub_id].endpoint_desc = dev->endpoints[0][0];
device/usb/usbhub.c:    dev->driver_private = (void*)hub_id;
device/usb/usbhub.c:    int hub_id = (int)hub_device->driver_private;
device/usb/usbhub.c:    for (i = 0; i < hub->descriptor.bNbrPorts; i++)
device/usb/usbhub.c:        if (hub->ports[i].child != NULL)
device/usb/usbhub.c:            usb_free_device(hub->ports[i].child);
Binary file device/usb/usbcore.o matches
device/usb/usbcore.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
device/usb/usbcore.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
device/usb/usbcore.d:../system/platforms/arm-rpi3/interrupt.h:
device/usb/usbcore.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file device/usb/usbhub.o matches
device/usb/usbhub.d: ../system/platforms/arm-rpi3/interrupt.h \
device/usb/usbhub.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
device/usb/usbhub.d:../system/platforms/arm-rpi3/interrupt.h:
device/usb/usbhub.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file device/usb/usbdebug.o matches
device/usb/usbdebug.d: ../system/platforms/arm-rpi3/interrupt.h \
device/usb/usbdebug.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
device/usb/usbdebug.d:../system/platforms/arm-rpi3/interrupt.h:
device/usb/usbdebug.d:../system/platforms/arm-rpi3/bcm2837.h:
device/usbkbd/usbKbdBindDevice.c:                 dev->manufacturer, dev->product, dev->address);
device/usbkbd/usbKbdBindDevice.c:    /* HID class is per-interface and cannot be in the device descriptor.  */
device/usbkbd/usbKbdBindDevice.c:    if (USB_CLASS_CODE_INTERFACE_SPECIFIC != dev->descriptor.bDeviceClass)
device/usbkbd/usbKbdBindDevice.c:    for (i = 0; i < dev->config_descriptor->bNumInterfaces; i++)
device/usbkbd/usbKbdBindDevice.c:        struct usb_interface_descriptor *interface = dev->interfaces[i];
device/usbkbd/usbKbdBindDevice.c:                     i, interface->bInterfaceNumber);
device/usbkbd/usbKbdBindDevice.c:        if (USB_CLASS_CODE_HID != interface->bInterfaceClass)
device/usbkbd/usbKbdBindDevice.c:        if (HID_SUBCLASS_BOOT != interface->bInterfaceSubClass ||
device/usbkbd/usbKbdBindDevice.c:            HID_BOOT_PROTOCOL_KEYBOARD != interface->bInterfaceProtocol)
device/usbkbd/usbKbdBindDevice.c:        for (j = 0; j < interface->bNumEndpoints; j++)
device/usbkbd/usbKbdBindDevice.c:            if ((dev->endpoints[i][j]->bmAttributes & 0x3) ==
device/usbkbd/usbKbdBindDevice.c:                && (dev->endpoints[i][j]->bEndpointAddress >> 7) ==
device/usbkbd/usbKbdBindDevice.c:                in_interrupt_endpoint = dev->endpoints[i][j];
device/usbkbd/usbKbdBindDevice.c:                                 kbd_interface->bInterfaceNumber, NULL, 0);
device/usbkbd/usbKbdBindDevice.c:    dev->driver_private = kbd;
device/usbkbd/usbKbdBindDevice.c:    kbd->intr->dev = dev;
device/usbkbd/usbKbdBindDevice.c:    kbd->intr->endpoint_desc = in_interrupt_endpoint;
device/usbkbd/usbKbdBindDevice.c:    kbd->intr->completion_cb_func = usbKbdInterrupt;
device/usbkbd/usbKbdBindDevice.c:    kbd->intr->private = kbd;
device/usbkbd/usbKbdBindDevice.c:    status = usb_submit_xfer_request(kbd->intr);
device/usbkbd/usbKbdBindDevice.c:    kbd->attached = TRUE;
device/usbkbd/usbKbdControl.c: *      control-function-dependent value.
device/usbkbd/usbKbdControl.c:    USBKBD_TRACE("devptr->minor=%u, func=%d, arg1=%ld, arg2=%ld",
device/usbkbd/usbKbdControl.c:                 (uint)devptr->minor, func, arg1, arg2);
device/usbkbd/usbKbdControl.c:    kbd = &usbkbds[devptr->minor];
device/usbkbd/usbKbdControl.c:    if (!kbd->initialized)
device/usbkbd/usbKbdControl.c:        retval = kbd->iflags & arg1;
device/usbkbd/usbKbdControl.c:        kbd->iflags |= arg1;
device/usbkbd/usbKbdControl.c:        retval = kbd->iflags & arg1;
device/usbkbd/usbKbdControl.c:        kbd->iflags &= ~arg1;
device/usbkbd/usbKbdControl.c:        retval = kbd->iflags;
device/usbkbd/usbKbdGetc.c: *      in non-blocking mode and no data is available, returns ::SYSERR.
device/usbkbd/usbKbdInit.c:    kbd = &usbkbds[devptr->minor];
device/usbkbd/usbKbdInit.c:    if (kbd->initialized)
device/usbkbd/usbKbdInit.c:    kbd->isema = semcreate(0);
device/usbkbd/usbKbdInit.c:    if (SYSERR == kbd->isema)
device/usbkbd/usbKbdInit.c:    kbd->intr = usb_alloc_xfer_request(8);
device/usbkbd/usbKbdInit.c:    if (NULL == kbd->intr)
device/usbkbd/usbKbdInit.c:    kbd->initialized = TRUE;
device/usbkbd/usbKbdInit.c:     * (no-op if already registered).  */
device/usbkbd/usbKbdInit.c:    kbd->initialized = FALSE;
device/usbkbd/usbKbdInit.c:    usb_free_xfer_request(kbd->intr);
device/usbkbd/usbKbdInit.c:    semfree(kbd->isema);
device/usbkbd/usbKbdInterrupt.c:    [45] = {'-', '_'},
device/usbkbd/usbKbdInterrupt.c:    [86] = {'-'},            /* Keypad -                  */
device/usbkbd/usbKbdInterrupt.c:    struct usbkbd *kbd = req->private;
device/usbkbd/usbKbdInterrupt.c:    if (req->status == USB_STATUS_SUCCESS && req->actual_size == 8)
device/usbkbd/usbKbdInterrupt.c:        const uchar *data = req->recvbuf;
device/usbkbd/usbKbdInterrupt.c:        /* Bytes 2 through 8 are the usage IDs of non-modifier keys currently
device/usbkbd/usbKbdInterrupt.c:                NULL == memchr(kbd->recent_usage_ids, usage_id, 6))
device/usbkbd/usbKbdInterrupt.c:                if (kbd->icount < USBKBD_IBLEN)
device/usbkbd/usbKbdInterrupt.c:                    kbd->in[(kbd->istart + kbd->icount) % USBKBD_IBLEN] = c;
device/usbkbd/usbKbdInterrupt.c:                    kbd->icount++;
device/usbkbd/usbKbdInterrupt.c:        signaln(kbd->isema, count);
device/usbkbd/usbKbdInterrupt.c:        memcpy(kbd->recent_usage_ids, data + 2, 6);
device/usbkbd/usbKbdInterrupt.c:                     req->status, req->actual_size);
device/usbkbd/usbKbdRead.c: *      but may be less than @p len if the keyboard has been set to non-blocking
device/usbkbd/usbKbdRead.c:    kbd = &usbkbds[devptr->minor];
device/usbkbd/usbKbdRead.c:    if (!kbd->initialized)
device/usbkbd/usbKbdRead.c:        /* If the keyboard is in non-blocking mode, ensure there is a byte
device/usbkbd/usbKbdRead.c:        if ((kbd->iflags & USBKBD_IFLAG_NOBLOCK) && kbd->icount == 0)
device/usbkbd/usbKbdRead.c:        wait(kbd->isema);
device/usbkbd/usbKbdRead.c:        ((uchar*)buf)[count] = kbd->in[kbd->istart];
device/usbkbd/usbKbdRead.c:        kbd->icount--;
device/usbkbd/usbKbdRead.c:        kbd->istart = (kbd->istart + 1) % USBKBD_IBLEN;
device/usbkbd/usbKbdUnbindDevice.c:                 dev->manufacturer, dev->product, dev->address);
device/usbkbd/usbKbdUnbindDevice.c:    kbd = dev->driver_private;
device/usbkbd/usbKbdUnbindDevice.c:    kbd->attached = FALSE;
device/lan7800/etherInit.c:#include "../../system/platforms/arm-rpi3/bcm2837_mbox.h"
device/lan7800/etherInit.c:	if (udev->descriptor.idVendor != LAN7800_VENDOR_ID ||
device/lan7800/etherInit.c:			udev->descriptor.idProduct != LAN7800_PRODUCT_ID ||
device/lan7800/etherInit.c:			udev->interfaces[0]->bNumEndpoints < 2 ||
device/lan7800/etherInit.c:			(udev->endpoints[0][0]->bmAttributes & 0x3) != USB_TRANSFER_TYPE_BULK ||
device/lan7800/etherInit.c:			(udev->endpoints[0][1]->bmAttributes & 0x3) != USB_TRANSFER_TYPE_BULK ||
device/lan7800/etherInit.c:			(udev->endpoints[0][0]->bEndpointAddress >> 7) != USB_DIRECTION_IN ||
device/lan7800/etherInit.c:			(udev->endpoints[0][1]->bEndpointAddress >> 7) != USB_DIRECTION_OUT ||
device/lan7800/etherInit.c:			udev->speed != USB_SPEED_HIGH)
device/lan7800/etherInit.c:	if (ethptr->csr != NULL)
device/lan7800/etherInit.c:	udev->last_error = USB_STATUS_SUCCESS;
device/lan7800/etherInit.c:	lan7800_set_mac_address(udev, ethptr->devAddress);
device/lan7800/etherInit.c:	if (udev->last_error != USB_STATUS_SUCCESS)
device/lan7800/etherInit.c:		return udev->last_error;
device/lan7800/etherInit.c:	ethptr->csr = udev;
device/lan7800/etherInit.c:	udev->driver_private = ethptr;
device/lan7800/etherInit.c:	signal(lan7800_attached[ethptr - ethertab]);
device/lan7800/etherInit.c:	struct ether *ethptr = udev->driver_private;
device/lan7800/etherInit.c:	wait(lan7800_attached[ethptr - ethertab]);
device/lan7800/etherInit.c:	etherClose(ethptr->dev);
device/lan7800/etherInit.c: * Get the Pi 3 B+'s MAC address using its ARM->VideoCore (VC) mailbox
device/lan7800/etherInit.c:	 * This function is defined in system/platforms/arm-rpi3/bcm2837_mbox.c */
device/lan7800/etherInit.c:	 * --Behavior--: if kprintf is not called here at least five times, then the global
device/lan7800/etherInit.c: * LAN7800-specific notes: This function returns ::OK if the Ethernet
device/lan7800/etherInit.c: * This is a work-around to use USB's dynamic device model at the same time as
device/lan7800/etherInit.c:	ethptr = &ethertab[devptr->minor];
device/lan7800/etherInit.c:	ethptr->dev = devptr;
device/lan7800/etherInit.c:	ethptr->state = ETH_STATE_DOWN;
device/lan7800/etherInit.c:	ethptr->mtu = ETH_MTU;
device/lan7800/etherInit.c:	ethptr->addressLength = ETH_ADDR_LEN;
device/lan7800/etherInit.c:	ethptr->isema = semcreate(0);
device/lan7800/etherInit.c:	if (isbadsem(ethptr->isema))
device/lan7800/etherInit.c:	lan7800_attached[devptr->minor] = semcreate(0);
device/lan7800/etherInit.c:	if (isbadsem(lan7800_attached[devptr->minor]))
device/lan7800/etherInit.c:	memcpy(ethptr->devAddress, addr, sizeof(addr));
device/lan7800/etherInit.c:	lan7800_attached[devptr->minor] = semcreate(0);
device/lan7800/etherInit.c:	semfree(lan7800_attached[devptr->minor]);
device/lan7800/etherInit.c:	semfree(ethptr->isema);
device/lan7800/etherInterrupt.c:    struct ether *ethptr = req->private;
device/lan7800/etherInterrupt.c:    ethptr->txirq++;
device/lan7800/etherInterrupt.c:    usb_dev_debug(req->dev, "LAN7800: Tx complete\n");
device/lan7800/etherInterrupt.c: * new packets).  It then must re-submit the USB bulk transfer request so that
device/lan7800/etherInterrupt.c:    struct ether *ethptr = req->private;
device/lan7800/etherInterrupt.c:    ethptr->rxirq++;
device/lan7800/etherInterrupt.c:    if (req->status == USB_STATUS_SUCCESS)
device/lan7800/etherInterrupt.c:        for (data = req->recvbuf, edata = req->recvbuf + req->actual_size;
device/lan7800/etherInterrupt.c:                (frame_length + LAN7800_RX_OVERHEAD > edata - data) ||
device/lan7800/etherInterrupt.c:                usb_dev_debug(req->dev, "LAN7800: Tallying rx error "
device/lan7800/etherInterrupt.c:                ethptr->errors++;
device/lan7800/etherInterrupt.c:            else if (ethptr->icount == ETH_IBLEN)
device/lan7800/etherInterrupt.c:                usb_dev_debug(req->dev, "LAN7800: Tallying overrun\n");
device/lan7800/etherInterrupt.c:                ethptr->ovrrun++;
device/lan7800/etherInterrupt.c:                pkt = bufget(ethptr->inPool);
device/lan7800/etherInterrupt.c:                pkt->buf = pkt->data = (uint8_t*)(pkt + 1);
device/lan7800/etherInterrupt.c:                pkt->length = frame_length - ETH_CRC_LEN;
device/lan7800/etherInterrupt.c:                memcpy(pkt->buf, data + LAN7800_RX_OVERHEAD, pkt->length);
device/lan7800/etherInterrupt.c:                ethptr->in[(ethptr->istart + ethptr->icount) % ETH_IBLEN] = pkt;
device/lan7800/etherInterrupt.c:                ethptr->icount++;
device/lan7800/etherInterrupt.c:                usb_dev_debug(req->dev, "LAN7800 Receiving "
device/lan7800/etherInterrupt.c:                              pkt->length, ethptr->icount);
device/lan7800/etherInterrupt.c:                signal(ethptr->isema);
device/lan7800/etherInterrupt.c:        usb_dev_debug(req->dev, "LAN7800: USB Rx transfer failed\n");
device/lan7800/etherInterrupt.c:        ethptr->errors++;
device/lan7800/etherInterrupt.c:    usb_dev_debug(req->dev, "LAN7800: Re-submitting USB Rx request\n");
device/lan7800/etherOpen.c:    if (lan7800_wait_device_attached(devptr->minor) != USB_STATUS_SUCCESS)
device/lan7800/etherOpen.c:    ethptr = &ethertab[devptr->minor];
device/lan7800/etherOpen.c:    if (ethptr->state != ETH_STATE_DOWN)
device/lan7800/etherOpen.c:    ethptr->outPool = bfpalloc(sizeof(struct usb_xfer_request) + ETH_MAX_PKT_LEN +
device/lan7800/etherOpen.c:    if (ethptr->outPool == SYSERR)
device/lan7800/etherOpen.c:    ethptr->inPool = bfpalloc(sizeof(struct ethPktBuffer) + ETH_MAX_PKT_LEN,
device/lan7800/etherOpen.c:    if (ethptr->inPool == SYSERR)
device/lan7800/etherOpen.c:    udev = ethptr->csr;
device/lan7800/etherOpen.c:    if (lan7800_set_mac_address(udev, ethptr->devAddress) != USB_STATUS_SUCCESS)
device/lan7800/etherOpen.c:        req = bufget(ethptr->outPool);
device/lan7800/etherOpen.c:        req->dev = udev;
device/lan7800/etherOpen.c:        req->endpoint_desc = udev->endpoints[0][1];
device/lan7800/etherOpen.c:        req->sendbuf = (uint8_t*)req + sizeof(struct usb_xfer_request);
device/lan7800/etherOpen.c:        req->completion_cb_func = lan7800_tx_complete;
device/lan7800/etherOpen.c:        req->private = ethptr;
device/lan7800/etherOpen.c:        req->dev = udev;
device/lan7800/etherOpen.c:        req->endpoint_desc = udev->endpoints[0][0];
device/lan7800/etherOpen.c:        req->completion_cb_func = lan7800_rx_complete;
device/lan7800/etherOpen.c:        req->private = ethptr;
device/lan7800/etherOpen.c:    udev->last_error = USB_STATUS_SUCCESS;
device/lan7800/etherOpen.c:    if (udev->last_error != USB_STATUS_SUCCESS)
device/lan7800/etherOpen.c:    ethptr->state = ETH_STATE_UP;
device/lan7800/etherOpen.c:    bfpfree(ethptr->inPool);
device/lan7800/etherOpen.c:    bfpfree(ethptr->outPool);
device/lan7800/lan7800.h: * According to Linux's open-source 78xx driver:
device/lan7800/lan7800.h: * and also U-Boot:
device/lan7800/lan7800.h: * https://github.com/trini/u-boot/blob/890e79f2b1c26c5ba1a86d179706348aec7feef7/drivers/usb/eth/lan7x.h
device/lan7800/lan7800.h:/* According to U-Boot's LAN78xx driver. */
device/lan7800/lan7800.h:/* Mac-layer transmission. */
device/lan7800/etherRead.c:    ethptr = &ethertab[devptr->minor];
device/lan7800/etherRead.c:    if (ethptr->state != ETH_STATE_UP)
device/lan7800/etherRead.c:    /* Wait for received packet to be available in the ethptr->in circular
device/lan7800/etherRead.c:    wait(ethptr->isema);
device/lan7800/etherRead.c:    pkt = ethptr->in[ethptr->istart];
device/lan7800/etherRead.c:    ethptr->istart = (ethptr->istart + 1) % ETH_IBLEN;
device/lan7800/etherRead.c:    ethptr->icount--;
device/lan7800/etherRead.c:    if (pkt->length < len)
device/lan7800/etherRead.c:        len = pkt->length;
device/lan7800/etherRead.c:    memcpy(buf, pkt->buf, len);
Binary file device/lan7800/etherClose.o matches
Binary file device/lan7800/lan7800.o matches
device/lan7800/lan7800.d: ../system/platforms/arm-rpi3/interrupt.h \
device/lan7800/lan7800.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
device/lan7800/lan7800.d:../system/platforms/arm-rpi3/interrupt.h:
device/lan7800/lan7800.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file device/lan7800/etherInit.o matches
device/lan7800/etherInit.d: ../system/platforms/arm-rpi3/interrupt.h \
device/lan7800/etherInit.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
device/lan7800/etherInit.d: ../device/lan7800/../../system/platforms/arm-rpi3/bcm2837_mbox.h \
device/lan7800/etherInit.d: ../device/lan7800/../../system/platforms/arm-rpi3/bcm2837.h \
device/lan7800/etherInit.d:../system/platforms/arm-rpi3/interrupt.h:
device/lan7800/etherInit.d:../system/platforms/arm-rpi3/bcm2837.h:
device/lan7800/etherInit.d:../device/lan7800/../../system/platforms/arm-rpi3/bcm2837_mbox.h:
device/lan7800/etherInit.d:../device/lan7800/../../system/platforms/arm-rpi3/bcm2837.h:
Binary file device/lan7800/etherOpen.o matches
device/lan7800/etherOpen.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
device/lan7800/etherOpen.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
device/lan7800/etherOpen.d:../system/platforms/arm-rpi3/interrupt.h:
device/lan7800/etherOpen.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file device/lan7800/etherRead.o matches
Binary file device/lan7800/etherInterrupt.o matches
Binary file device/lan7800/etherWrite.o matches
device/lan7800/etherInterrupt.d: ../system/platforms/arm-rpi3/interrupt.h \
device/lan7800/etherInterrupt.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
device/lan7800/etherInterrupt.d:../system/platforms/arm-rpi3/interrupt.h:
device/lan7800/etherInterrupt.d:../system/platforms/arm-rpi3/bcm2837.h:
device/lan7800/etherWrite.c:    ethptr = &ethertab[devptr->minor];
device/lan7800/etherWrite.c:    if (ethptr->state != ETH_STATE_UP ||
device/lan7800/etherWrite.c:    req = bufget(ethptr->outPool);
device/lan7800/etherWrite.c:     * beginning that contain device-specific flags.  These two fields are
device/lan7800/etherWrite.c:    sendbuf = req->sendbuf;
device/lan7800/etherWrite.c:    req->size = len + LAN7800_TX_OVERHEAD;
device/lan7800/etherWrite.c:     * device-specific fields that were added). */
device/lan7800/etherControl.c:    ethptr = &ethertab[devptr->minor];
device/lan7800/etherControl.c:    udev = ethptr->csr;
device/lan7800/etherControl.c:        addr->type = NETADDR_ETHERNET;
device/lan7800/etherControl.c:        addr->len = ETH_ADDR_LEN;
device/lan7800/etherControl.c:        return etherControl(devptr, ETH_CTRL_GET_MAC, (long)addr->addr, 0);
device/lan7800/etherControl.c:        addr->type = NETADDR_ETHERNET;
device/lan7800/etherControl.c:        addr->len = ETH_ADDR_LEN;
device/lan7800/etherControl.c:        memset(addr->addr, 0xFF, ETH_ADDR_LEN);
device/lan7800/etherRead.d: ../system/platforms/arm-rpi3/interrupt.h \
device/lan7800/etherRead.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/string.h
device/lan7800/etherRead.d:../system/platforms/arm-rpi3/interrupt.h:
device/lan7800/etherRead.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file device/lan7800/.lan7800.h.swp matches
device/lan7800/etherWrite.d: ../system/platforms/arm-rpi3/interrupt.h \
device/lan7800/etherWrite.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/string.h \
device/lan7800/etherWrite.d:../system/platforms/arm-rpi3/interrupt.h:
device/lan7800/etherWrite.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file device/lan7800/etherControl.o matches
docs/Getting-Started.rst:as Linux or Mac OS X, or at least a UNIX-compatible environment such
docs/Getting-Started.rst:---------------------------
docs/Getting-Started.rst:http://xinu-os.org/Downloads.
docs/Getting-Started.rst:<http://git-scm.com/>`__.  To download it, `install git
docs/Getting-Started.rst:<http://git-scm.com/book/en/Getting-Started-Installing-Git>`__ and run
docs/Getting-Started.rst:.. code-block:: none
docs/Getting-Started.rst:    $ git clone https://github.com/xinu-os/xinu
docs/Getting-Started.rst:.. code-block:: none
docs/Getting-Started.rst:    $ ls -F
docs/Getting-Started.rst:Note that Embedded Xinu is licensed under a BSD-style license; see the
docs/Getting-Started.rst:-------------------
docs/Getting-Started.rst:either the :doc:`mipsel-qemu <mips/Mipsel-qemu>` or the :doc:`arm-qemu
docs/Getting-Started.rst:<arm/ARM-qemu>` ports, each of which runs in the
docs/Getting-Started.rst:Setting up a cross-compiler
docs/Getting-Started.rst:---------------------------
docs/Getting-Started.rst:Embedded Xinu platform is listed under *Cross-target* in the
docs/Getting-Started.rst:this is the value to pass to ``--target`` when configuring binutils
docs/Getting-Started.rst:Option 1: Install cross-compiler from repository
docs/Getting-Started.rst:Option 2: Build cross-compiler from source
docs/Getting-Started.rst:source in a cross-compiler configuration.
docs/Getting-Started.rst:- On Linux systems, these tools can be found in the software
docs/Getting-Started.rst:- On Windows via `Cygwin <http://www.cygwin.com>`__, these tools can
docs/Getting-Started.rst:- On Mac OS X, these tools come with `Xcode
docs/Getting-Started.rst:   .. code-block:: none
docs/Getting-Started.rst:      $ wget ftp://ftp.gnu.org/gnu/binutils/binutils-2.23.tar.gz
docs/Getting-Started.rst:   .. code-block:: none
docs/Getting-Started.rst:      $ tar xvf binutils-2.23.tar.gz
docs/Getting-Started.rst:   .. code-block:: none
docs/Getting-Started.rst:      $ mkdir binutils-2.23-build
docs/Getting-Started.rst:      $ cd binutils-2.23-build
docs/Getting-Started.rst:   .. code-block:: none
docs/Getting-Started.rst:      $ ../binutils-2.23/configure --prefix=/opt/mipsel-dev --target=mipsel \
docs/Getting-Started.rst:               --disable-nls
docs/Getting-Started.rst:   The argument given to ``--prefix`` is the location into which to
docs/Getting-Started.rst:   The argument given to ``--target`` is the target which the binutils
docs/Getting-Started.rst:   Xinu platform, as shown under *Cross-target* in the :ref:`list of
docs/Getting-Started.rst:   ``--disable-nls`` simply saves time and space by not supporting any
docs/Getting-Started.rst:   .. code-block:: none
docs/Getting-Started.rst:   .. code-block:: none
docs/Getting-Started.rst:   .. code-block:: none
docs/Getting-Started.rst:      $ wget ftp://ftp.gnu.org/gnu/gcc/gcc-4.8.2/gcc-4.8.2.tar.bz2
docs/Getting-Started.rst:   .. code-block:: none
docs/Getting-Started.rst:      $ tar xvf gcc-4.8.2.tar.bz2
docs/Getting-Started.rst:   .. code-block:: none
docs/Getting-Started.rst:      $ mkdir gcc-4.8.2-build
docs/Getting-Started.rst:      $ cd gcc-4.8.2-build
docs/Getting-Started.rst:   .. code-block:: none
docs/Getting-Started.rst:      $ ../gcc-4.8.2/configure --prefix=/opt/mipsel-dev --target=mipsel \
docs/Getting-Started.rst:                --enable-languages=c,c++ --without-headers --disable-nls
docs/Getting-Started.rst:   ``--prefix`` and ``--target`` must be exactly the same as those
docs/Getting-Started.rst:   ``--enable-languages=c,c++`` ensures that only C and C++ compilers
docs/Getting-Started.rst:   ``--enable-languages=c``.
docs/Getting-Started.rst:   ``--without-headers`` is needed when there is no libc (standard C
docs/Getting-Started.rst:   ``--disable-nls`` simply saves time and space by not supporting any
docs/Getting-Started.rst:   .. code-block:: none
docs/Getting-Started.rst:      $ make all-gcc all-target-libgcc
docs/Getting-Started.rst:      can add the argument ``-jN`` to **make**, where N is an integer,
docs/Getting-Started.rst:   .. code-block:: none
docs/Getting-Started.rst:      $ sudo make install-gcc install-target-libgcc
docs/Getting-Started.rst:First, for convenience you may wish to make the cross-utilities
docs/Getting-Started.rst:.. code-block:: none
docs/Getting-Started.rst:   export PATH="$PATH:/opt/mipsel-dev/bin"
docs/Getting-Started.rst:.. code-block:: c
docs/Getting-Started.rst:    mipsel-gcc -c test.c
docs/Getting-Started.rst:-----------------------
docs/Getting-Started.rst:Having built a cross-compiler if needed, compiling Embedded Xinu now
docs/Getting-Started.rst:.. code-block:: none
docs/Getting-Started.rst:   $ make -C compile PLATFORM=wrt54gl
docs/Getting-Started.rst:  may be prefixed with.  Example for ARM-based platforms:
docs/Getting-Started.rst:  ``/opt/arm-dev/bin/arm-none-eabi-``.  Or, if the executables are on
docs/Getting-Started.rst:  ``arm-none-eabi-``; however, that (or the corresponding prefix for a
docs/Getting-Started.rst:  non-ARM-based ``PLATFORM``) is already the default.
docs/Getting-Started.rst:* ``DETAIL`` can be defined as ``-DDETAIL`` to enable certain
docs/Getting-Started.rst:    $ make PLATFORM=arm-rpi
docs/Getting-Started.rst:----------
docs/Getting-Started.rst:running this file is largely platform-dependent.  Just a few examples
docs/Getting-Started.rst:- Raspberry Pi:  See :ref:`raspberry_pi_booting` and
docs/Getting-Started.rst:- Mipsel-QEMU:  See :doc:`/mips/Mipsel-qemu`.
docs/Getting-Started.rst:- ARM-QEMU  See :doc:`/arm/ARM-qemu`.
docs/Getting-Started.rst:- :doc:`features/index`
docs/Getting-Started.rst:- :doc:`teaching/index`
docs/Getting-Started.rst:---------------
docs/Getting-Started.rst:- `GCC Cross-Compiler (OSDev Wiki) <http://wiki.osdev.org/GCC_Cross-Compiler>`__
docs/Introduction.rst:was to re-implement and port the
docs/Introduction.rst::doc:`QEMU MIPSel virtual environment <mips/Mipsel-qemu>`
docs/Introduction.rst::doc:`Raspberry Pi </arm/rpi/Raspberry-Pi>`;
docs/Introduction.rst::doc:`Systems Laboratory <development/Systems-Laboratory>`
docs/Introduction.rst:---------------
docs/Introduction.rst:see :doc:`Getting-Started`.
docs/Introduction.rst:- :doc:`/arm/index`
docs/Introduction.rst:- :doc:`/mips/index`
docs/Introduction.rst:---------------------------
docs/Introduction.rst:-------------------
docs/Introduction.rst:.. list-table::
docs/Introduction.rst:    :header-rows: 1
docs/Introduction.rst:    * - Platform
docs/Introduction.rst:      - Status
docs/Introduction.rst:      - Comments
docs/Introduction.rst:      - :ref:`PLATFORM value <makefile_variables>`
docs/Introduction.rst:      - :ref:`Cross-target <cross_compiler>`
docs/Introduction.rst:    * - :doc:`Linksys WRT54GL <mips/WRT54GL>`
docs/Introduction.rst:      - Supported
docs/Introduction.rst:      - This is our primary development platform, on which Xinu has
docs/Introduction.rst:      - ``wrt54gl``
docs/Introduction.rst:      - ``mipsel``
docs/Introduction.rst:    * - Linksys WRT54G v8
docs/Introduction.rst:      - Supported
docs/Introduction.rst:      - Tested and running at the Embedded Xinu Lab.  Supported via
docs/Introduction.rst:      - ``wrt54gl``
docs/Introduction.rst:      - ``mipsel``
docs/Introduction.rst:    * - Linksys WRT54G v4
docs/Introduction.rst:      - Probably Supported
docs/Introduction.rst:      - The v4 is apparently the version on which WRT54GL is based,
docs/Introduction.rst:      - ``wrt54gl``
docs/Introduction.rst:      - ``mipsel``
docs/Introduction.rst:    * - Linksys WRT160NL
docs/Introduction.rst:      - Supported
docs/Introduction.rst:      - Newer model of WRT54GL. Full O/S teaching core functioning,
docs/Introduction.rst:      - ``wrt160nl``
docs/Introduction.rst:      - ``mips``
docs/Introduction.rst:    * - Linksys E2100L
docs/Introduction.rst:      - Supported
docs/Introduction.rst:      - Full O/S teaching core functioning, including wired network
docs/Introduction.rst:      - ``e2100l``
docs/Introduction.rst:      - ``mips``
docs/Introduction.rst:    * - ASUS WL-330gE
docs/Introduction.rst:      - Not actively maintained
docs/Introduction.rst:      - This platform was working in the past but is no longer being
docs/Introduction.rst:      - ``wl330ge``
docs/Introduction.rst:      - ``mipsel``
docs/Introduction.rst:    * - :doc:`mipsel-qemu </mips/Mipsel-qemu>`
docs/Introduction.rst:      - Supported
docs/Introduction.rst:      - Full O/S teaching core functioning, network support in progress.
docs/Introduction.rst:      - ``mipsel-qemu``
docs/Introduction.rst:      - ``mipsel``
docs/Introduction.rst:    * - :doc:`Raspberry Pi </arm/rpi/Raspberry-Pi>`
docs/Introduction.rst:      - Supported
docs/Introduction.rst:      - Core operating system including wired networking is functional.
docs/Introduction.rst:      - ``arm-rpi``
docs/Introduction.rst:      - ``arm-none-eabi``
docs/Introduction.rst:    * - :doc:`arm-qemu </arm/ARM-qemu>`
docs/Introduction.rst:      - Supported
docs/Introduction.rst:      - Core operating system, excluding wired networking, is functional.
docs/Introduction.rst:      - ``arm-qemu``
docs/Introduction.rst:      - ``arm-none-eabi``
docs/Introduction.rst:-----------------
docs/Introduction.rst:the early 1980s for the LSI-11 platform, it has now been ported to a
docs/Makefile:SPHINXBUILD   = sphinx-build
docs/Makefile:# User-friendly check for sphinx-build
docs/Makefile:$(error The '$(SPHINXBUILD)' command was not found. Make sure you have Sphinx installed, then set the SPHINXBUILD environment variable to point to the full path of the '$(SPHINXBUILD)' executable. Alternatively you can add the directory with the executable to your PATH. If you don't have Sphinx installed, grab it from http://sphinx-doc.org/)
docs/Makefile:PAPEROPT_a4     = -D latex_paper_size=a4
docs/Makefile:PAPEROPT_letter = -D latex_paper_size=letter
docs/Makefile:ALLSPHINXOPTS   = -d $(BUILDDIR)/doctrees $(PAPEROPT_$(PAPER)) $(SPHINXOPTS) .
docs/Makefile:	@echo "  xml        to make Docutils-native XML files"
docs/Makefile:	@echo "  pseudoxml  to make pseudoxml-XML files for display purposes"
docs/Makefile:	rm -rf $(BUILDDIR)/*
docs/Makefile:	$(SPHINXBUILD) -b html $(ALLSPHINXOPTS) $(BUILDDIR)/html
docs/Makefile:	$(SPHINXBUILD) -b dirhtml $(ALLSPHINXOPTS) $(BUILDDIR)/dirhtml
docs/Makefile:	$(SPHINXBUILD) -b singlehtml $(ALLSPHINXOPTS) $(BUILDDIR)/singlehtml
docs/Makefile:	$(SPHINXBUILD) -b pickle $(ALLSPHINXOPTS) $(BUILDDIR)/pickle
docs/Makefile:	$(SPHINXBUILD) -b json $(ALLSPHINXOPTS) $(BUILDDIR)/json
docs/Makefile:	$(SPHINXBUILD) -b htmlhelp $(ALLSPHINXOPTS) $(BUILDDIR)/htmlhelp
docs/Makefile:	$(SPHINXBUILD) -b qthelp $(ALLSPHINXOPTS) $(BUILDDIR)/qthelp
docs/Makefile:	@echo "# assistant -collectionFile $(BUILDDIR)/qthelp/EmbeddedXinu.qhc"
docs/Makefile:	$(SPHINXBUILD) -b devhelp $(ALLSPHINXOPTS) $(BUILDDIR)/devhelp
docs/Makefile:	@echo "# mkdir -p $$HOME/.local/share/devhelp/EmbeddedXinu"
docs/Makefile:	@echo "# ln -s $(BUILDDIR)/devhelp $$HOME/.local/share/devhelp/EmbeddedXinu"
docs/Makefile:	$(SPHINXBUILD) -b epub $(ALLSPHINXOPTS) $(BUILDDIR)/epub
docs/Makefile:	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
docs/Makefile:	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
docs/Makefile:	$(MAKE) -C $(BUILDDIR)/latex all-pdf
docs/Makefile:	$(SPHINXBUILD) -b latex $(ALLSPHINXOPTS) $(BUILDDIR)/latex
docs/Makefile:	$(MAKE) -C $(BUILDDIR)/latex all-pdf-ja
docs/Makefile:	$(SPHINXBUILD) -b text $(ALLSPHINXOPTS) $(BUILDDIR)/text
docs/Makefile:	$(SPHINXBUILD) -b man $(ALLSPHINXOPTS) $(BUILDDIR)/man
docs/Makefile:	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
docs/Makefile:	$(SPHINXBUILD) -b texinfo $(ALLSPHINXOPTS) $(BUILDDIR)/texinfo
docs/Makefile:	make -C $(BUILDDIR)/texinfo info
docs/Makefile:	$(SPHINXBUILD) -b gettext $(I18NSPHINXOPTS) $(BUILDDIR)/locale
docs/Makefile:	$(SPHINXBUILD) -b changes $(ALLSPHINXOPTS) $(BUILDDIR)/changes
docs/Makefile:	$(SPHINXBUILD) -b linkcheck $(ALLSPHINXOPTS) $(BUILDDIR)/linkcheck
docs/Makefile:	$(SPHINXBUILD) -b doctest $(ALLSPHINXOPTS) $(BUILDDIR)/doctest
docs/Makefile:	$(SPHINXBUILD) -b xml $(ALLSPHINXOPTS) $(BUILDDIR)/xml
docs/Makefile:	$(SPHINXBUILD) -b pseudoxml $(ALLSPHINXOPTS) $(BUILDDIR)/pseudoxml
docs/Makefile:	@echo "Build finished. The pseudo-XML files are in $(BUILDDIR)/pseudoxml."
docs/arm/ARM-Interrupt-Handling.rst:concerns ARM-specific details; in particular it must be understood
docs/arm/ARM-Interrupt-Handling.rst:board-specific mechanism, such as the
docs/arm/ARM-Interrupt-Handling.rst::doc:`rpi/BCM2835-Interrupt-Controller` on the
docs/arm/ARM-Interrupt-Handling.rst::doc:`rpi/Raspberry-Pi`.  Furthermore, note that the ARM architecture
docs/arm/ARM-Interrupt-Handling.rst:-------------
docs/arm/ARM-Interrupt-Handling.rst:-  **IRQs** (Interrupt Requests). These are the "normal" type of
docs/arm/ARM-Interrupt-Handling.rst:-  **FIQs** (Fast Interrupt Requests). These are an feature that
docs/arm/ARM-Interrupt-Handling.rst:   design real-time and embedded software on top of or instead of the
docs/arm/ARM-Interrupt-Handling.rst:specifically refers to the ARM-architecture IRQ exception.
docs/arm/ARM-Interrupt-Handling.rst:set in :source:`loader/platforms/arm-rpi/start.S`.  The "full" IRQ
docs/arm/ARM-Interrupt-Handling.rst:-------------------
docs/arm/ARM-Interrupt-Handling.rst:.. code-block:: none
docs/arm/ARM-Interrupt-Handling.rst:``disable()``-d is not lost; instead, it remains pending until IRQs
docs/arm/ARM-Interrupt-Handling.rst:are re-enabled.
docs/arm/ARM-Interrupt-Handling.rst:.. code-block:: none
docs/arm/ARM-Interrupt-Handling.rst:.. code-block:: none
docs/arm/ARM-Interrupt-Handling.rst:``restore()`` (the previous state value--- in the code this is often
docs/arm/ARM-Interrupt-Handling.rst:---------------
docs/arm/ARM-Interrupt-Handling.rst:As mentioned in the introduction, this page deals with ARM-architecture
docs/arm/ARM-Interrupt-Handling.rst:- The interrupt controller on the :doc:`rpi/Raspberry-Pi` is the
docs/arm/ARM-Interrupt-Handling.rst:  :doc:`rpi/BCM2835-Interrupt-Controller`.
docs/arm/ARM-Interrupt-Handling.rst:-----
docs/arm/ARM-Preemptive-Multitasking.rst:multitasking </features/Preemptive-Multitasking>` on :wikipedia:`ARM
docs/arm/ARM-Preemptive-Multitasking.rst::doc:`rpi/Raspberry-Pi`.
docs/arm/ARM-Preemptive-Multitasking.rst:--------------
docs/arm/ARM-Preemptive-Multitasking.rst:-  ARM processors have 16 "general-purpose" registers numbered ``r0`` - ``r15``,
docs/arm/ARM-Preemptive-Multitasking.rst:   despite being considered "general-purpose" registers, ``r13`` - ``r15``
docs/arm/ARM-Preemptive-Multitasking.rst:-  The standard ARM calling convention specifies which registers are
docs/arm/ARM-Preemptive-Multitasking.rst:   callee-save (``r4`` - ``r11``, ``r13`` - ``r14``) and which are
docs/arm/ARM-Preemptive-Multitasking.rst:   caller-save (``r0`` - ``r3``, ``r11``), as well as how arguments are passed to
docs/arm/ARM-Preemptive-Multitasking.rst:   procedures (up to four arguments in ``r0`` - ``r3``; additional
docs/arm/ARM-Preemptive-Multitasking.rst:``0x00``     ``r0``      First thread argument, caller-save
docs/arm/ARM-Preemptive-Multitasking.rst:``0x04``     ``r1``      Second thread argument, caller-save
docs/arm/ARM-Preemptive-Multitasking.rst:``0x08``     ``r2``      Third thread argument, caller-save
docs/arm/ARM-Preemptive-Multitasking.rst:``0x0C``     ``r3``      Fourth thread argument, caller-save
docs/arm/ARM-Preemptive-Multitasking.rst:``0x10``     ``r4``      Callee-save
docs/arm/ARM-Preemptive-Multitasking.rst:``0x14``     ``r5``      Callee-save
docs/arm/ARM-Preemptive-Multitasking.rst:``0x18``     ``r6``      Callee-save
docs/arm/ARM-Preemptive-Multitasking.rst:``0x1C``     ``r7``      Callee-save
docs/arm/ARM-Preemptive-Multitasking.rst:``0x20``     ``r8``      Callee-save
docs/arm/ARM-Preemptive-Multitasking.rst:``0x24``     ``r9``      Callee-save
docs/arm/ARM-Preemptive-Multitasking.rst:``0x28``     ``r10``     Callee-save
docs/arm/ARM-Preemptive-Multitasking.rst:``0x2C``     ``r11``     Callee-save
docs/arm/ARM-Preemptive-Multitasking.rst:----------
docs/arm/ARM-Preemptive-Multitasking.rst:software must make use of a board-specific or chip-specific device
docs/arm/ARM-Preemptive-Multitasking.rst:such as the :doc:`rpi/BCM2835-System-Timer`.
docs/arm/ARM-Preemptive-Multitasking.rst:-----
docs/arm/ARM-qemu.rst:arm-qemu
docs/arm/ARM-qemu.rst::doc:`/mips/Mipsel-qemu` port, the *arm-qemu* port of Embedded Xinu
docs/arm/ARM-qemu.rst:--------
docs/arm/ARM-qemu.rst::ref:`Compile Embedded Xinu <compiling>` with ``PLATFORM=arm-qemu``.
docs/arm/ARM-qemu.rst:-------
docs/arm/ARM-qemu.rst:    $ qemu-system-arm -M versatilepb -cpu arm1176 -m 128M -nographic -kernel xinu.boot
docs/arm/ARM-qemu.rst:Note the ``-cpu arm1176`` option.  This requires QEMU v1.0 (released
docs/arm/ARM-qemu.rst:-----
docs/arm/ARM-qemu.rst:The ``arm-qemu`` platform does not yet support networking.
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:The **BCM2835 Interrupt Controller** is a memory-mapped peripheral
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:available on the :doc:`BCM2835` used in the :doc:`Raspberry-Pi`.  It
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:----------------
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:ARM-specific IRQs, and the layout of the registers reflects this
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:The BCM2835 Interrupt Controller is a memory-mapped peripheral
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:.. list-table:: BCM2835 Interrupt Controller registers
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    :header-rows: 1
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - Offset
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Name
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Description
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - ``+0x200``
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - IRQ_basic_pending
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Bitmask of pending ARM-specific IRQs, as well as additional
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - ``+0x204``
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - IRQ_pending_1
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Bitmask of pending shared IRQs 0-31
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - ``+0x208``
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - IRQ_pending_2
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Bitmask of pending shared IRQs 32-63
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - ``+0x20C``
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - FIQ_control
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - TODO
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - ``+0x210``
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Enable_IRQs_1
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Write 1 to the corresponding bit(s) to enable one or more
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:        shared IRQs in the range 0-31
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - ``+0x214``
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Enable_IRQs_2
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Write 1 to the corresponding bit(s) to enable one or more
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:        shared IRQs in the range 32-63
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - ``+0x218``
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Enable_Basic_IRQs
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Write 1 to the corresponding bit(s) to enable one or more
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:        ARM-specific IRQs
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - ``+0x21C``
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Disable_IRQs_1
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Write 1 to the corresponding bit(s) to disable one or more
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:        shared IRQs in the range 0-31
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - ``+0x220``
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Disable_IRQs_2
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Write 1 to the corresponding bit(s) to disable one or more
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:        shared IRQs in the range 32-63
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - ``+0x224``
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Disable_Basic_IRQs
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Write 1 to the corresponding bit(s) to disable one or more
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:        ARM-specific IRQs
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:<https://github.com/raspberrypi/linux/blob/rpi-3.6.y/arch/arm/mach-bcm2708/include/mach/platform.h>`__
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:Linux, where the shared IRQs are numbered 0-63, and ARM-specific IRQs
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:.. list-table:: Incomplete list of BCM2835 IRQs
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    :header-rows: 1
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - IRQ
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Device
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Notes
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - 0
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - System Timer Compare Register 0
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Do **not** enable this IRQ; it's already used by the GPU.
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - 1
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - System Timer Compare Register 1
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - See :doc:`BCM2835-System-Timer`
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - 2
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - System Timer Compare Register 2
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - Do **not** enable this IRQ; it's already used by the GPU.
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - 3
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - System Timer Compare Register 3
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - See :doc:`BCM2835-System-Timer`
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - 9
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - USB Controller
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - This is the *only* USB IRQ because all communication with USB
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:        :doc:`Synopsys-USB-Controller`.
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - 55
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - PCM Audio
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      -
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:    * - 62
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      - SD Host Controller
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:      -
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:- Software cannot "clear" interrupts using the interrupt controller.
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:  Instead, interrupts must be cleared in a device-specific way.
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:- Although some shared interrupts appear in the IRQ_Basic_Pending
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:--------------------
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:code is in :source:`system/platforms/arm-rpi/dispatch.c`.  These
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:disable.  Shared IRQs are numbered 0-63, while ARM-specific IRQs
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:--------------
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:- `BCM2835 ARM Peripherals datasheet by Broadcom
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:  <http://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf>`__
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:  The interrupt controller is documented in Section 7 (p. 109-118).
docs/arm/rpi/BCM2835-Interrupt-Controller.rst:  don't mention some of the important IRQ numbers, such as 0-3 (System
docs/arm/rpi/BCM2835-Memory-Barriers.rst::doc:`Raspberry-Pi` should:
docs/arm/rpi/BCM2835-Memory-Barriers.rst:- execute a memory write barrier before the first write to a peripheral
docs/arm/rpi/BCM2835-Memory-Barriers.rst:- execute a memory read barrier after the last read to a peripheral
docs/arm/rpi/BCM2835-Memory-Barriers.rst:-----
docs/arm/rpi/BCM2835-Memory-Barriers.rst:.. [#bcm] http://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf
docs/arm/rpi/BCM2835-System-Timer.rst:The **BCM2835 System Timer** is a memory-mapped peripheral available
docs/arm/rpi/BCM2835-System-Timer.rst:on the :doc:`BCM2835` used in the :doc:`Raspberry-Pi`.  It features a
docs/arm/rpi/BCM2835-System-Timer.rst:64-bit free-running counter that runs at 1 MHz and four separate
docs/arm/rpi/BCM2835-System-Timer.rst:----------------
docs/arm/rpi/BCM2835-System-Timer.rst:The interface to the BCM2835 System Timer is a set of 32-bit
docs/arm/rpi/BCM2835-System-Timer.rst:memory-mapped registers beginning at physical address ``0x20003000``.
docs/arm/rpi/BCM2835-System-Timer.rst:.. list-table:: BCM2835 System Timer registers
docs/arm/rpi/BCM2835-System-Timer.rst:    :header-rows: 1
docs/arm/rpi/BCM2835-System-Timer.rst:    * - Offset
docs/arm/rpi/BCM2835-System-Timer.rst:      - Name
docs/arm/rpi/BCM2835-System-Timer.rst:      - Description
docs/arm/rpi/BCM2835-System-Timer.rst:    * - ``+0x00``
docs/arm/rpi/BCM2835-System-Timer.rst:      - ``CS``
docs/arm/rpi/BCM2835-System-Timer.rst:      - System Timer Control and Status
docs/arm/rpi/BCM2835-System-Timer.rst:    * - ``+0x04``
docs/arm/rpi/BCM2835-System-Timer.rst:      - ``CLO``
docs/arm/rpi/BCM2835-System-Timer.rst:      - System Timer Counter Lower 32 bits
docs/arm/rpi/BCM2835-System-Timer.rst:    * - ``+0x08``
docs/arm/rpi/BCM2835-System-Timer.rst:      - ``CHI``
docs/arm/rpi/BCM2835-System-Timer.rst:      - System Timer Counter Upper 32 bits
docs/arm/rpi/BCM2835-System-Timer.rst:    * - ``+0x0C``
docs/arm/rpi/BCM2835-System-Timer.rst:      - ``C0``
docs/arm/rpi/BCM2835-System-Timer.rst:      - System Timer Compare 0; corresponds to IRQ line 0.
docs/arm/rpi/BCM2835-System-Timer.rst:    * - ``+0x10``
docs/arm/rpi/BCM2835-System-Timer.rst:      - ``C1``
docs/arm/rpi/BCM2835-System-Timer.rst:      - System Timer Compare 1; corresponds to IRQ line 1.
docs/arm/rpi/BCM2835-System-Timer.rst:    * - ``+0x14``
docs/arm/rpi/BCM2835-System-Timer.rst:      - ``C2``
docs/arm/rpi/BCM2835-System-Timer.rst:      - System Timer Compare 2; corresponds to IRQ line 2.
docs/arm/rpi/BCM2835-System-Timer.rst:    * - ``+0x18``
docs/arm/rpi/BCM2835-System-Timer.rst:      - ``C3``
docs/arm/rpi/BCM2835-System-Timer.rst:      - System Timer Compare 3; corresponds to IRQ line 3.
docs/arm/rpi/BCM2835-System-Timer.rst:``CLO`` and ``CHI`` form a 64-bit free-running counter, which
docs/arm/rpi/BCM2835-System-Timer.rst:- Appropriate :doc:`memory barriers <BCM2835-Memory-Barriers>` should
docs/arm/rpi/BCM2835-System-Timer.rst:  be inserted to guarantee that read data is not re-ordered with that
docs/arm/rpi/BCM2835-System-Timer.rst:- Reading ``CLO`` can be done in a single 32-bit access.  However, we
docs/arm/rpi/BCM2835-System-Timer.rst:  together atomically.  To work around this when the full 64-bit time
docs/arm/rpi/BCM2835-System-Timer.rst::doc:`BCM2835-Interrupt-Controller`.  To clear the interrupt, software
docs/arm/rpi/BCM2835-System-Timer.rst:--------------------
docs/arm/rpi/BCM2835-System-Timer.rst:In the :doc:`Raspberry-Pi` port of Embedded Xinu, or :doc:`XinuPi`,
docs/arm/rpi/BCM2835-System-Timer.rst:multitasking </features/Preemptive-Multitasking>` and keep the system time.
docs/arm/rpi/BCM2835-System-Timer.rst:The code can be found in :source:`system/platforms/arm-rpi/timer.c`
docs/arm/rpi/BCM2835.rst:The **BCM2835** is a SoC (System-on-a-chip) designed by Broadcom. It
docs/arm/rpi/BCM2835.rst:is used on the :doc:`Raspberry-Pi`, where it is easily visible as the
docs/arm/rpi/BCM2835.rst:The BCM2835 is actually not specific to the :doc:`Raspberry-Pi` and is
docs/arm/rpi/BCM2835.rst:--------
docs/arm/rpi/BCM2835.rst:- :doc:`Raspberry-Pi`
docs/arm/rpi/BCM2835.rst:- :doc:`BCM2835-System-Timer`
docs/arm/rpi/BCM2835.rst:- :doc:`BCM2835-Interrupt-Controller`
docs/arm/rpi/BCM2835.rst:- :doc:`BCM2835-Memory-Barriers`
docs/arm/rpi/BCM2835.rst:- :doc:`Synopsys-USB-Controller`
docs/arm/rpi/BCM2835.rst:-----
docs/arm/rpi/BCM2835.rst:.. [#roku2] http://www.electronicproducts.com/Roku_2_XS_3100R_Streaming_Media_Adapter-whatsinside_text-120.aspx
docs/arm/rpi/BCM2835.rst:--------------
docs/arm/rpi/BCM2835.rst:- `BCM2835 ARM Peripherals (datasheet by Broadcom)
docs/arm/rpi/BCM2835.rst:  <http://www.raspberrypi.org/wp-content/uploads/2012/02/BCM2835-ARM-Peripherals.pdf>`__
docs/arm/rpi/Raspberry-Pi-Interrupt-Handling.rst:Interrupt handling on the :doc:`Raspberry-Pi` is concerned with all
docs/arm/rpi/Raspberry-Pi-Interrupt-Handling.rst:enabled on the :doc:`Raspberry-Pi` is that from the
docs/arm/rpi/Raspberry-Pi-Interrupt-Handling.rst::doc:`BCM2835-System-Timer`, which is used in :doc:`XinuPi` to
docs/arm/rpi/Raspberry-Pi-Interrupt-Handling.rst:</arm/ARM-Preemptive-Multitasking>`.  Interrupt handling on the
docs/arm/rpi/Raspberry-Pi-Interrupt-Handling.rst::doc:`Raspberry-Pi` consists of two complementary parts:
docs/arm/rpi/Raspberry-Pi-Interrupt-Handling.rst:- :doc:`/arm/ARM-Interrupt-Handling`
docs/arm/rpi/Raspberry-Pi-Interrupt-Handling.rst:- :doc:`BCM2835-Interrupt-Controller`
docs/arm/rpi/Raspberry-Pi.rst:The **Raspberry Pi** is an inexpensive credit-card sized computer
docs/arm/rpi/Raspberry-Pi.rst:----------------------
docs/arm/rpi/Raspberry-Pi.rst:-  SD card. To boot, the Raspberry Pi requires an appropriately
docs/arm/rpi/Raspberry-Pi.rst:-  Power source. The Raspberry Pi requires 700 mA at 5V, delivered
docs/arm/rpi/Raspberry-Pi.rst:-  Serial cable for text input/output to/from the Raspberry Pi, such as
docs/arm/rpi/Raspberry-Pi.rst:   as a power source. However, eventually a keyboard-and-monitor setup
docs/arm/rpi/Raspberry-Pi.rst:-  Monitor or TV to display graphics output from the Raspberry Pi. While
docs/arm/rpi/Raspberry-Pi.rst:-  USB devices can be plugged in and recognized, but the device driver
docs/arm/rpi/Raspberry-Pi.rst:-  Ethernet cable to take advantage of the networking support.
docs/arm/rpi/Raspberry-Pi.rst:-  Case to enclose the Raspberry Pi in. This protects the board and adds
docs/arm/rpi/Raspberry-Pi.rst:------------------------
docs/arm/rpi/Raspberry-Pi.rst:directory of a FAT-formatted partition of the SD card.
docs/arm/rpi/Raspberry-Pi.rst:-  ``bootcode.bin`` is a first-stage bootloader.
docs/arm/rpi/Raspberry-Pi.rst:-  ``loader.bin`` is a second-stage bootloader. Apparently, this file is
docs/arm/rpi/Raspberry-Pi.rst:-  ``start.elf`` is the GPU
docs/arm/rpi/Raspberry-Pi.rst:-  ``config.txt`` is parsed by the GPU firmware and is used to set various
docs/arm/rpi/Raspberry-Pi.rst:-  ``cmdline.txt`` is used to pass a command line to the Linux kernel.
docs/arm/rpi/Raspberry-Pi.rst:-  ``kernel.img`` must exist and is loaded as raw data at physical memory
docs/arm/rpi/Raspberry-Pi.rst:   or other bare-metal code such as the *raspbootin* bootloader.
docs/arm/rpi/Raspberry-Pi.rst:-  Follow the installation instructions for a Linux distribution
docs/arm/rpi/Raspberry-Pi.rst:-  Manually partition the SD card and create a FAT filesystem, then copy
Binary file docs/arm/rpi/RaspberryPi.jpg matches
docs/arm/rpi/SMSC-LAN9512.rst:integrated into the :doc:`Raspberry-Pi` Model B.
docs/arm/rpi/SMSC-LAN9512.rst:---------------
docs/arm/rpi/SMSC-LAN9512.rst:------------
docs/arm/rpi/SMSC-LAN9512.rst:----------------------
docs/arm/rpi/SMSC-LAN9512.rst:-----------------------------
docs/arm/rpi/SMSC-LAN9512.rst:of this section therefore describes driver-internal details.
docs/arm/rpi/SMSC-LAN9512.rst:more or less, some device-specific data followed by the raw packet
docs/arm/rpi/SMSC-LAN9512.rst:----------------------
docs/arm/rpi/SMSC-LAN9512.rst:----------------------
docs/arm/rpi/SMSC-LAN9512.rst:- Support for other potentially compatible SMSC LAN95xx devices
docs/arm/rpi/SMSC-LAN9512.rst:- Dynamically attaching/detaching the device
docs/arm/rpi/SMSC-LAN9512.rst:- Reading from attached EEPROM
docs/arm/rpi/SMSC-LAN9512.rst:- VLANs
docs/arm/rpi/SMSC-LAN9512.rst:- TCP/IP checksum offload
docs/arm/rpi/SMSC-LAN9512.rst:- Suspend
docs/arm/rpi/SMSC-LAN9512.rst:- Wake-on-LAN
docs/arm/rpi/SMSC-LAN9512.rst:- Various PHY features
docs/arm/rpi/Synopsys-USB-Controller.rst:The **Synopsys DesignWare High-Speed USB 2.0 On-The-Go Controller** is
docs/arm/rpi/Synopsys-USB-Controller.rst:the USB controller used on the :doc:`Raspberry-Pi`. This hardware is
docs/arm/rpi/Synopsys-USB-Controller.rst:Linux driver.  According to Greg Kroah-Hartman, the maintainer of
docs/arm/rpi/Synopsys-USB-Controller.rst:relatively simple, stripped-down driver that does not support many
docs/arm/rpi/Synopsys-USB-Controller.rst:----------------------------------
docs/arm/rpi/Synopsys-USB-Controller.rst:intended to be simple and well-documented, and appropriate (to the extent
docs/arm/rpi/Synopsys-USB-Controller.rst:-  Device mode. The "On-The-Go" portion of the hardware's name means it
docs/arm/rpi/Synopsys-USB-Controller.rst:   supports the `On-The-Go
docs/arm/rpi/Synopsys-USB-Controller.rst:   protocol <https://en.wikipedia.org/wiki/USB_On-The-Go|USB>`__, which
docs/arm/rpi/Synopsys-USB-Controller.rst:-  Isochronous transfers
docs/arm/rpi/Synopsys-USB-Controller.rst:-  Support for instantiations of the silicon other than the one used on
docs/arm/rpi/Synopsys-USB-Controller.rst:-  Advanced transaction scheduling that takes into account special
docs/arm/rpi/Synopsys-USB-Controller.rst:-  Various module parameters to configure the driver
docs/arm/rpi/Synopsys-USB-Controller.rst:-  Power management, including suspend and hibernation
docs/arm/rpi/Synopsys-USB-Controller.rst:-  Slave or Descriptor DMA modes
docs/arm/rpi/Synopsys-USB-Controller.rst:------------
docs/arm/rpi/Synopsys-USB-Controller.rst:For now, see the source code (:source:`system/platforms/arm-rpi/usb_dwc_hcd.c`
docs/arm/rpi/Synopsys-USB-Controller.rst:and :source:`system/platforms/arm-rpi/usb_dwc_regs.h`), which is intended to be
docs/arm/rpi/Synopsys-USB-Controller.rst:-----
docs/arm/rpi/Synopsys-USB-Controller.rst:.. [#usb_sucks_quote] http://lists.infradead.org/pipermail/linux-rpi-kernel/2012-September/000214.html
docs/arm/rpi/Synopsys-USB-Controller.rst:.. [#linux_driver] https://github.com/raspberrypi/linux/tree/rpi-3.6.y/drivers/usb/host/dwc_otg
docs/arm/rpi/Synopsys-USB-Controller.rst:.. [#plan9_driver] http://plan9.bell-labs.com/sources/plan9/sys/src/9/bcm/usbdwc.c
docs/arm/rpi/XinuPi.rst:**XinuPi** is the port of Embedded Xinu to the :doc:`Raspberry-Pi`.
docs/arm/rpi/XinuPi.rst:code than the Linux-based software stacks that normally run on the
docs/arm/rpi/XinuPi.rst:-----------------------------------
docs/arm/rpi/XinuPi.rst:See :doc:`Raspberry-Pi` for information about the hardware itself.
docs/arm/rpi/XinuPi.rst:------------------------------------------
docs/arm/rpi/XinuPi.rst:in :doc:`/Getting-Started`.  To compile for the Raspberry Pi platform
docs/arm/rpi/XinuPi.rst:``PLATFORM=arm-rpi`` when you run **make**.  You will also need an ARM
docs/arm/rpi/XinuPi.rst:``--target=arm-none-eabi``); more information can be found in
docs/arm/rpi/XinuPi.rst:----------------------------------
docs/arm/rpi/XinuPi.rst:-  The core of XinuPi provides a preemptive multitasking operating
docs/arm/rpi/XinuPi.rst:   :doc:`/arm/ARM-Preemptive-Multitasking` for more details about how
docs/arm/rpi/XinuPi.rst:   Embedded Xinu implements preemptive multitasking on ARM-based
docs/arm/rpi/XinuPi.rst:   :doc:`BCM2835-System-Timer` for the timer on the Raspberry Pi that
docs/arm/rpi/XinuPi.rst:-  Interrupt handling on the Raspberry Pi, required for the timer
docs/arm/rpi/XinuPi.rst:   :doc:`Raspberry-Pi-Interrupt-Handling`.
docs/arm/rpi/XinuPi.rst:-  USB support was added to Embedded Xinu partly because of its
docs/arm/rpi/XinuPi.rst:   information about USB, or :doc:`Synopsys-USB-Controller` for
docs/arm/rpi/XinuPi.rst:-  See :doc:`SMSC-LAN9512` for information about the built-in USB
docs/conf.py:# -*- coding: utf-8 -*-
docs/conf.py:# sphinx-quickstart on Tue Oct  1 20:26:25 2013.
docs/conf.py:# -- General configuration -----------------------------------------------------
docs/conf.py:#source_encoding = 'utf-8-sig'
docs/conf.py:# non-false value, then it is used:
docs/conf.py:# If true, '()' will be appended to :func: etc. cross-reference text.
docs/conf.py:# -- Options for HTML output ---------------------------------------------------
docs/conf.py:# Theme options are theme-specific and customize the look and feel of a theme
docs/conf.py:# -- Options for LaTeX output --------------------------------------------------
docs/conf.py:# -- Options for manual page output --------------------------------------------
docs/conf.py:# -- Options for Texinfo output ------------------------------------------------
docs/development/Build-System.rst:--------
docs/development/Build-System.rst:``mipsVars`` defines the location of the cross-compiler and various
docs/development/Build-System.rst:``make [libname]-clean`` will clean the library.
docs/development/Build-System.rst:---------
docs/development/Build-System.rst:-------
docs/development/Build-System.rst:variables are exported (including the location of the cross-compiler,
docs/development/Documentation.rst:1. "reStructuredText" (.rst) files located under the top-level
docs/development/Documentation.rst:2. Comments in the source code itself, including Doxygen-compatible
docs/development/Documentation.rst::doc:`Kernel-Normal-Form`.
docs/development/Documentation.rst:--------------------------
docs/development/Documentation.rst:can be read at http://embedded-xinu.readthedocs.org/en/latest/,
docs/development/Documentation.rst:`Sphinx documentation tool <http://sphinx-doc.org>`__.   On Linux
docs/development/Documentation.rst:.. code-block:: none
docs/development/Documentation.rst:.. code-block:: none
docs/development/Documentation.rst:---------------------------------
docs/development/Documentation.rst:Platform-dependent documentation (e.g. in ``arm/`` and ``mips/``) is
docs/development/Documentation.rst:<http://sphinx-doc.org/markup/toctree.html>`__.  However, the
docs/development/Documentation.rst:---------
docs/development/Documentation.rst:- `reStructuredText Primer <http://sphinx-doc.org/rest.html>`__
docs/development/Documentation.rst:- `Quick reStructuredText <http://docutils.sourceforge.net/docs/user/rst/quickref.html>`__
docs/development/Git-Repository.rst:switched to `git <http://git-scm.com/>`__ as the preferred
docs/development/Git-Repository.rst:    $ git clone https://github.com/xinu-os/xinu
docs/development/Git-Repository.rst:`"Pro Git" book <http://git-scm.com/book>`__. But briefly, a very
docs/development/Git-Repository.rst:commit`` or ``git commit -a`` to commit the changes to the repository,
docs/development/Git-Repository.rst::doc:`preferred coding style <Kernel-Normal-Form>`.
docs/development/Kernel-Normal-Form.rst:--------
docs/development/Kernel-Normal-Form.rst:Generally, code should be well-commented. However, comments should only
docs/development/Kernel-Normal-Form.rst:Doxygen-style comments should generally be used to document files as
docs/development/Kernel-Normal-Form.rst:meant to be an external interface--- that is, not internal to a file or
docs/development/Kernel-Normal-Form.rst:    /* Typical single-line comments look like this. */
docs/development/Kernel-Normal-Form.rst:     * Multi-line comments that should appear in the autogenerated documentation
docs/development/Kernel-Normal-Form.rst:    /** Single-line comments to appear in documentation look like this. */
docs/development/Kernel-Normal-Form.rst:The first form of single-line comments must be placed above the code
docs/development/Kernel-Normal-Form.rst:does not use the lengthy 20+-line copyright statements used in many
docs/development/Kernel-Normal-Form.rst:------------
docs/development/Kernel-Normal-Form.rst:blank line and begin including non-local header files.
docs/development/Kernel-Normal-Form.rst:the right of the longest line. Any final statement-terminating semicolon
docs/development/Kernel-Normal-Form.rst:--------------------
docs/development/Kernel-Normal-Form.rst:---------
docs/development/Kernel-Normal-Form.rst:     * @return zero on successful completion, non-zero if unsuccessful.
docs/development/Kernel-Normal-Form.rst:-------
docs/development/Kernel-Normal-Form.rst:-------------
docs/development/Porting.rst:------------
docs/development/Porting.rst:This file is intended to be platform-independent and you should not
docs/development/Porting.rst:- A Makefile rule to generate the file ``$(BOOTIMAGE)``, which is by default
docs/development/Porting.rst:- ``APPCOMPS`` must be set to the list of Xinu application components
docs/development/Porting.rst:- ``DEVICES`` must be set to the list of Xinu device drivers to build
docs/development/Porting.rst:- ``BUGFLAG`` must be set to an appropriate compiler flag to enable
docs/development/Porting.rst:- ``ARCH_ROOT`` must be set to the default directory containing the
docs/development/Porting.rst:- ``ARCH_PREFIX`` must be set to the default compiler target prefix.
docs/development/Porting.rst:- ``OCFLAGS`` must be set to the appropriate flags to pass to
docs/development/Porting.rst:- ``FLAGS`` can be modified to add additional compiler flags.
docs/development/Porting.rst:- ``ASFLAGS`` can be modified to add additional assembler flags.
docs/development/Porting.rst:  these with ``-Wa,``.  For the GNU assembler see ``man as`` or ``info
docs/development/Porting.rst:- ``LDFLAGS`` can be modified to add additional linker flags.  These
docs/development/Porting.rst:  ``-Wl,``.  For the GNU linker see ``man ld'` or ``info ld`` for
docs/development/Porting.rst:- ``LDLIBS`` can be modified to add needed external libraries.
docs/development/Porting.rst:  Besides possibly adding libgcc (``-lgcc``) if your architecture has
docs/development/Porting.rst:- ``INCLUDE`` can be modified to add additional include directories.  Prefix each
docs/development/Porting.rst:  with ``-I``.  The toplevel Makefile handles adding these to
docs/development/Porting.rst:- ``DEFS`` can be modified to add additional defines.  Prefix each
docs/development/Porting.rst:  with ``-D``.  The toplevel Makefile handles adding these to
docs/development/Porting.rst:- ``PLATCLEAN`` to be the name of a platform-specific target that will
docs/development/Porting.rst:- ``LIBXC_OVERRIDE_CFILES``
docs/development/Porting.rst:- ``PLATFORM_NAME`` to change the release provided at the top of the
docs/development/Porting.rst:- ``platformVars`` can be shortened by including the corresponding ``platformVars``
docs/development/Porting.rst:- If you do not include a linker script (``ld.script``) in
docs/development/Systems-Laboratory.rst:----------------------------
docs/development/Systems-Laboratory.rst:computer systems. Our emphasis is on embedded, real-time, and network
docs/development/Systems-Laboratory.rst:- Experimental Embedded Networking Platform. Creation of laboratory
docs/development/Systems-Laboratory.rst:- Experimental Embedded Operating System Laboratory. Creation of
docs/development/Systems-Laboratory.rst:- Embedded Software Transactional Memory. Exploration of an innovative
docs/development/Systems-Laboratory.rst:- Many-core Embedded Operating System Laboratory. A port of Embedded
docs/development/Systems-Laboratory.rst:  Xinu to the `48-core SCC processor
docs/development/Systems-Laboratory.rst:<http://www.marquette.edu/mscs/facstaff-research-labs.shtml>`__ page
docs/development/Systems-Laboratory.rst:------------
docs/development/Systems-Laboratory.rst:- Eric Biggers, Farzeen Haruani, Tyler Much, and Dennis Brylow.
docs/development/Systems-Laboratory.rst:  Embedded and Cyber-Physical Systems Education, Organized as a part
docs/development/Systems-Laboratory.rst:- Michael Ziwisky and Dennis Brylow. BareMichael: A Minimalistic
docs/development/Systems-Laboratory.rst:  Bare-metal Framework for the Intel SCC. In Proceedings of `MARC
docs/development/Systems-Laboratory.rst:  Symposium 2012 <http://hal.archives-ouvertes.fr/MARCONERA2012>`__:
docs/development/Systems-Laboratory.rst:  6th Many-core Applications Research Community (MARC) Symposium, Eric
docs/development/Systems-Laboratory.rst:  Noulard and Simon Vernhes (Ed.), ONERA - Toulouse, France, July
docs/development/Systems-Laboratory.rst:  2012.  `(link) <http://hal.archives-ouvertes.fr/docs/00/71/90/38/PDF/MARC6_BareMichael-A-Minimalistic-Bare-metal-Framework-for-the-Intel-SCC.pdf>`__
docs/development/Systems-Laboratory.rst:- Paul Ruth and Dennis Brylow. An Experimental Nexos Laboratory Using
docs/development/Systems-Laboratory.rst:  <http://fie-conference.org/fie2011/>`__: 41st ASEE/IEEE Frontiers in
docs/development/Systems-Laboratory.rst:  Education Conference, pages S2E-1-S2E-6, Rapid City, South Dakota,
docs/development/Systems-Laboratory.rst:- Kyle Persohn and Dennis Brylow. Interactive Real-Time Embedded
docs/development/Systems-Laboratory.rst:  199-204, Munich, Germany, July 2011. `(link)
docs/development/Systems-Laboratory.rst:- Dennis Brylow and Kyle Thurow. Hands-on Networking Labs With
docs/development/Systems-Laboratory.rst:  Symposium on Computer Science Education, pages 399-404, Dallas,
docs/development/Systems-Laboratory.rst:- Matt Netkow and Dennis Brylow. Xest: An Automated Framework for
docs/development/Systems-Laboratory.rst:  `WESE 2010 <http://www.artist-embedded.org/artist/-WESE-10-.html>`__
docs/development/Systems-Laboratory.rst:  6th Workshop on Embedded Systems Education, pages 40-47, Scottsdale,
docs/development/Systems-Laboratory.rst:  <http://www.artist-embedded.org/docs/Events/2010/WESE/Proceedings_WESE_2010.pdf>`__
docs/development/Systems-Laboratory.rst:- Adam Mallen and Dennis Brylow. Compiler Construction With A Dash of
docs/development/Systems-Laboratory.rst:  Trainers' Symposium, pages 161-168, Reno, Nevada, October 2010.
docs/development/Systems-Laboratory.rst:- Dennis Brylow and Bina Ramamurthy. Nexos: A Next Generation Embedded
docs/development/Systems-Laboratory.rst:  Embedded Systems Education, pages 10-17, Atlanta, Georgia, October
docs/development/Systems-Laboratory.rst:  <http://www.cs.virginia.edu/sigbed/archives/2009-01/j-7-wese-journal-p18-final-brylow.pdf>`__
docs/development/Systems-Laboratory.rst:- Dennis Brylow. An Experimental Laboratory Environment for Teaching
docs/development/Systems-Laboratory.rst:  Symposium on Computer Science Education, pages 192-196, Portland,
docs/development/Systems-Laboratory.rst:- Dennis Brylow. An Experimental Laboratory Environment for Teaching
docs/development/Systems-Laboratory.rst:  on Computer Architecture Education, pages 44-51, San Diego,
docs/development/Systems-Laboratory.rst:  <http://www.mscs.mu.edu/~brylow/papers/Brylow-WCAE2007.pdf>`__
docs/development/Systems-Laboratory.rst:- Kyle Thurow and Dennis Brylow. A Network Emulator on Embedded Xinu.
docs/development/Systems-Laboratory.rst:  advanced to the semi-finals round.
docs/development/Systems-Laboratory.rst:- Gabe Van Eyck and Dennis Brylow. Xinu as a Multi-Core Operating
docs/development/Systems-Laboratory.rst:- Aaron Gember and Dennis Brylow. Real-Time TCP Extensions. Poster
docs/development/Systems-Laboratory.rst:  division, Chattanooga, Tennessee. Aaron advanced to semi-finals,
docs/development/Systems-Laboratory.rst:- Dennis Brylow. Experimental Operating System Lab On A Dime. `SIGCSE
docs/development/Systems-Laboratory.rst:  `(link) <http://www.mscs.mu.edu/~brylow/papers/Brylow-SIGCSE2007.pdf>`__.
docs/development/Systems-Laboratory.rst:- Paul Ruth and Dennis Brylow. Teaching With Embedded Xinu. Workshop
docs/development/Systems-Laboratory.rst:- Dennis Brylow and Paul Ruth. Teaching With Embedded Xinu. Workshop
docs/development/Systems-Laboratory.rst:-------------
docs/development/Systems-Laboratory.rst:dual-headed Linux boxes running the latest version of `Fedora
docs/development/Systems-Laboratory.rst:include a dual-core Apple G5 running OS X, and several multi-core boxes
docs/development/Systems-Laboratory.rst:for higher-end computation.
docs/development/Systems-Laboratory.rst:Z8F04A28100KIT-C <http://www.zilog.com/index.php?option=com_product&Itemid=26&mode=showProdDet&businessLine=1&familyId=6&productId=Z8F04A28100KIT>`__.
docs/development/Systems-Laboratory.rst:-------------
docs/development/Systems-Laboratory.rst:<http://www.linkedin.com/pub/kyle-persohn/31/a31/990>`__, `Matt Bajzek
docs/development/Systems-Laboratory.rst:.. figure:: XINU-Summer2011.png
docs/development/Systems-Laboratory.rst:   <http://www.linkedin.com/pub/kyle-persohn/31/a31/990>`__, `Matt
docs/development/Systems-Laboratory.rst:   <http://www.linkedin.com/pub/paul-spillane/22/a07/56b>`__, `Dr.
docs/development/Systems-Laboratory.rst:   <http://www.linkedin.com/pub/blas-victor/27/781/351>`__.  Not
docs/development/Systems-Laboratory.rst:Tim Blattner, B.S. 2009. Now at `University of Maryland - Baltimore
docs/development/Systems-Laboratory.rst:`University of Wisconsin-Madison <http://www.cs.wisc.edu/>`__ doctoral
docs/development/Systems-Laboratory.rst:Joseph Pintozzi, B.S. 2010. Now works as a developer for `Core-Apps,
docs/development/Systems-Laboratory.rst:LLC <http://core-apps.com/>`__.
docs/development/Systems-Laboratory.rst:Spillane <http://www.linkedin.com/pub/paul-spillane/22/a07/56b>`__, B.S.
docs/development/Systems-Laboratory.rst:`Victor Blas <http://www.linkedin.com/pub/blas-victor/27/781/351>`__,
docs/development/Systems-Laboratory.rst:`Kyle Persohn <http://www.linkedin.com/pub/kyle-persohn/31/a31/990>`__,
Binary file docs/development/XINU-Summer2011.png matches
docs/development/index.rst:   Git-Repository
docs/development/index.rst:   Kernel-Normal-Form
docs/development/index.rst:   Build-System
docs/features/Mailboxes.rst::doc:`message passing <Message-Passing>` capability built into the
docs/features/Memory-Management.rst:build up a simple-to-understand memory management system.
docs/features/Memory-Management.rst:-----------------
docs/features/Memory-Management.rst:is a user allocator, that allocates memory from a per-thread memory
docs/features/Memory-Management.rst:This allocator works on a per-thread memory list of free memory, this
docs/features/Memory-Management.rst:-----------------
docs/features/Message-Passing.rst:``recvclr()`` is a non-blocking version of ``receive()``. If there is a
docs/features/Preemptive-Multitasking.rst:----------------
docs/features/Preemptive-Multitasking.rst:-  ``setupStack()``, which is responsible for setting up the stack
docs/features/Preemptive-Multitasking.rst:-  ``ctxsw()``, which is responsible for switching between threads. More
docs/features/Preemptive-Multitasking.rst:- :doc:`/arm/ARM-Preemptive-Multitasking`
docs/features/Preemptive-Multitasking.rst:----------
docs/features/Preemptive-Multitasking.rst:is a no-op.) The means of generating a timer interrupt is
docs/features/Preemptive-Multitasking.rst:platform-dependent and may even differ among platforms that share the
docs/features/Preemptive-Multitasking.rst::doc:`/arm/rpi/BCM2835-System-Timer`, which is used in the
docs/features/Preemptive-Multitasking.rst::doc:`/arm/rpi/Raspberry-Pi`, an ARM-based platform.
docs/features/Shell.rst:command-line interface for human interaction with the operating
docs/features/Shell.rst:------------
docs/features/Shell.rst:typically is set up as :doc:`TTY device <TTY-Driver>` that wraps
docs/features/Shell.rst:the format of command name, is the command built-in (ie can the
docs/features/Shell.rst:Built-in commands are executed by calling the function that implements
docs/features/Shell.rst:----------------
docs/features/Shell.rst:``COMMAND --help`` or ``help COMMAND``.
docs/features/Shell.rst:---------------
docs/features/Shell.rst:-  the function prototype needs to be added to the header file
docs/features/Shell.rst:-  the command table (:source:`shell/shell.c`) must be updated, and
docs/features/Shell.rst:-  the make file (:source:`shell/Makerules`) must build the file
docs/features/Shell.rst:allow for an argument of ``--help`` as ``arg[1]``. This argument should
docs/features/Shell.rst:``--help`` argument.
docs/features/Shell.rst:command name, is the command built-in (ie can the command run in the
docs/features/Shell.rst:        /* Output help, if '--help' argument was supplied */
docs/features/Shell.rst:        if (nargs == 2 && strcmp(args[1], "--help") == 0)
docs/features/Shell.rst:            fprintf(stdout, "\t--help\t display this help and exit\n");
docs/features/Standard-Library.rst:--------
docs/features/Standard-Library.rst:than high-performance or fully standards compliant.  However, the
docs/features/Standard-Library.rst:---
docs/features/Standard-Library.rst::source:`stdint.h <include/stdint.h>`     Fixed-width integer types
docs/features/Standard-Library.rst:XINU-specific types in addition to the standard ``offsetof``,
docs/features/Standard-Library.rst:---------------------------------
docs/features/Standard-Library.rst:- Many standard functions (and some headers) are simply not
docs/features/Standard-Library.rst:  implemented.  Examples:  Floating-point mathematics functions;
docs/features/Standard-Library.rst:- Formatted printing and scanning support only a limited range of
docs/features/Standard-Library.rst:- The ctype functions declared in :source:`include/ctype.h` do not
docs/features/Standard-Library.rst:  handle ``EOF`` (end-of-file) as specified by C99.
docs/features/Standard-Library.rst:- ``putc()`` is not implemented in libxc.  In Xinu it's actually a
docs/features/Standard-Library.rst:- The stdio functions do not buffer the output like a standard
docs/features/Standard-Library.rst:- :source:`strlcpy() <lib/libxc/strlcpy.c>` is implemented, even
docs/features/Standard-Library.rst:Platform-specific overrides
docs/features/Standard-Library.rst:---------------------------
docs/features/Standard-Library.rst:variable ``LIBXC_OVERRIDE_CFILES`` in the platform-specific
docs/features/Standard-Library.rst:the corresponding function(s), but please do it in a platform-specific
docs/features/Standard-Library.rst:----------
docs/features/Standard-Library.rst:- :wikipedia:`C standard library - Wikipedia <C standard library>`
docs/features/Standard-Library.rst:- `C99 standard <http://www.open-std.org/jtc1/sc22/wg14/www/docs/n1124.pdf>`_
docs/features/Standard-Library.rst:-  Brian Kernighan and Dennis Ritchie. *The C Programming Language*,
docs/features/TTY-Driver.rst:------------
docs/features/TTY-Driver.rst:char-oriented hardware device.  The underlying device driver must
docs/features/TTY-Driver.rst:----
docs/features/TTY-Driver.rst:-  ``TTY_IRAW`` - reads input unbuffered and uncooked
docs/features/TTY-Driver.rst:-  ``TTY_INLCR`` - converts ``'\n'`` to ``'\r'``
docs/features/TTY-Driver.rst:-  ``TTY_IGNCR`` - ignores ``'\r'``
docs/features/TTY-Driver.rst:-  ``TTY_ICRNL`` - converts ``'\r'`` to ``'\n'``
docs/features/TTY-Driver.rst:-  ``TTY_ECHO`` - echoes input
docs/features/TTY-Driver.rst:-----
docs/features/TTY-Driver.rst:-  ``TTY_ONLCR`` - converts ``'\n'`` to ``'\r\n'``
docs/features/TTY-Driver.rst:-  ``TTY_OCRNL`` - converts ``'\r'`` to ``'\n'``
docs/features/TTY-Driver.rst:-------
Binary file docs/features/TtyDriver.png matches
docs/features/USB-Keyboard-Driver.rst:------------------
docs/features/USB-Keyboard-Driver.rst:-----
docs/features/USB-Keyboard-Driver.rst:defines a fixed 8-byte report that the keyboard provides over its IN
docs/features/USB-Keyboard-Driver.rst:Since data is provided by *usbkbd* as 8-bit characters, there is
docs/features/USB-Keyboard-Driver.rst:----------------------
docs/features/USB-Keyboard-Driver.rst:--------
docs/features/USB-Keyboard-Driver.rst:- :doc:`USB`
docs/features/USB-Keyboard-Driver.rst:- :ref:`how_to_write_usb_device_driver`
docs/features/USB-Keyboard-Driver.rst:- :doc:`TTY-Driver`
docs/features/USB-Keyboard-Driver.rst:----------
docs/features/USB-Keyboard-Driver.rst:- `Universal Serial Bus (USB) Device Class Definition for Human Interface Devices (HID), Version 1.11
docs/features/USB-Keyboard-Driver.rst:- `Universal Serial Bus (USB) HID Usage Tables, Version 1.11
docs/features/USB.rst:-----------------------
docs/features/USB.rst:-  A USB device has one or more **configurations**.
docs/features/USB.rst:-  A configuration has one or more **interfaces**.
docs/features/USB.rst:-  An interface has one or more **alternate settings**.
docs/features/USB.rst:-  An alternate setting has one or more **endpoints**.
docs/features/USB.rst:present standard interfaces (such as UHCI, OHCI, or EHCI--- all
docs/features/USB.rst:have vendor-provided documentation and/or a vendor-provided driver; an
docs/features/USB.rst:example of this is the :doc:`/arm/rpi/Synopsys-USB-Controller` used on
docs/features/USB.rst:the :doc:`/arm/rpi/Raspberry-Pi`.  Obviously, a standard interface is
docs/features/USB.rst:-  **Control** transfers. These are typically used for device
docs/features/USB.rst:-  **Interrupt** transfers. These are used for time-bounded transmission
docs/features/USB.rst:-  **Bulk** transfers. These are used for reliable (with error
docs/features/USB.rst:-  **Isochronous** transfers. These are used for regular transmission of
docs/features/USB.rst:in all cases, the time-bounded transmission required by the USB
docs/features/USB.rst:-  1.5 Mbit/s (Low Speed) (USB 1+)
docs/features/USB.rst:-  12 Mbit/s (Full Speed) (USB 1+)
docs/features/USB.rst:-  480 Mbit/s (High Speed) (USB 2.0+)
docs/features/USB.rst:-  5000 Mbit/s (Super Speed) (USB 3.0+)
docs/features/USB.rst:-----------------------------
docs/features/USB.rst:    that the physical devices are still hot-pluggable.
docs/features/USB.rst:-  The **USB Host Controller Driver** is responsible for actually
docs/features/USB.rst:   platform-dependent host controller hardware. The purpose of this
docs/features/USB.rst:   the :doc:`/arm/rpi/Synopsys-USB-Controller` used on the
docs/features/USB.rst:   :doc:`/arm/rpi/Raspberry-Pi`.)
docs/features/USB.rst:-  The **USB Core Driver** is responsible for maintaining the USB device
docs/features/USB.rst:   isolate the platform-dependent Host Controller Driver as much as
docs/features/USB.rst:-  **USB device drivers** are responsible for controlling specific USB
docs/features/USB.rst:Driver, which is platform-dependent code and is not located in this
docs/features/USB.rst:example, :source:`system/platforms/arm-rpi/usb_dwc_hcd.c` is the Host
docs/features/USB.rst:critical, unnecessary human-friendly functionality can be omitted from
docs/features/USB.rst:USB-related shell commands
docs/features/USB.rst:for more details, or run ``usbinfo --help``.
docs/features/USB.rst:reverse-engineered by snooping on USB traffic generated by binary
docs/features/USB.rst:- USB Human Interface Devices such as mice are required to have an IN
docs/features/USB.rst:- USB networking devices, such as the :doc:`/arm/rpi/SMSC-LAN9512`,
docs/features/USB.rst::doc:`/arm/rpi/Synopsys-USB-Controller` used on the
docs/features/USB.rst::doc:`/arm/rpi/Raspberry-Pi`.
docs/features/USB.rst:but some changes may be needed (e.g. the location of memory-mapped registers).
docs/features/USB.rst:interrupt-driven.  Note that the hub driver uses interrupt transfers in order
docs/features/USB.rst:---------------
docs/features/USB.rst:- `USB 2.0 Specification <http://www.usb.org/developers/docs/>`__
docs/features/USB.rst:- `USB 3.1 Specification <http://www.usb.org/developers/docs/>`__
docs/features/USB.rst:- Embedded Xinu USB 2.0 subsystem. (:source:`device/usb`)
docs/features/USB.rst:- Embedded Xinu USB device drivers. (Example: :source:`device/smsc9512/`)
docs/features/USB.rst:- Embedded Xinu USB host controller drivers. (Example: :source:`system/platforms/arm-rpi/usb_dwc_hcd.c`)
docs/features/index.rst:platforms.  Platform-specific documentation can be found in
docs/features/index.rst:   Preemptive-Multitasking
docs/features/index.rst:   TTY-Driver
docs/features/index.rst:   Memory-Management
docs/features/index.rst:   Message-Passing
docs/features/index.rst:   Standard-Library
docs/features/index.rst:   USB-Keyboard-Driver
docs/features/networking/ARP.rst:----------
docs/features/networking/ARP.rst:-------------------------------
docs/features/networking/ARP.rst:--------------
docs/features/networking/ARP.rst:.. code-block:: none
docs/features/networking/ARP.rst:---------
docs/features/networking/DHCP.rst:Currently, only IPv4 client support--- that is, acquiring IPv4 address
docs/features/networking/DHCP.rst:information--- is supported. The code is located in
docs/features/networking/DHCP.rst:and gateway) the DHCP client returns the "bootfile" and "next-server"
docs/features/networking/DHCP.rst:    included in CFE, which is third-party firmware.
docs/features/networking/DHCP.rst:---------
docs/features/networking/DHCP.rst:- :wikipedia:`Dynamic Host Configuration Protocol - Wikipedia <Dynamic Host Configuration Protocol>`
docs/features/networking/DHCP.rst:- :rfc:`2131`
docs/features/networking/ICMP.rst:---------
docs/features/networking/ICMP.rst:- :rfc:`792`
docs/features/networking/Networking-Stack.rst:pool, calls the appropriate lower-level send function (ex.
docs/features/networking/Networking-Stack.rst:router and a multi-homed host. Packets received on any of a backend's
docs/features/networking/Networking-Stack.rst:.. image:: XINUNetStack-Screen.jpeg
docs/features/networking/Routing.rst:-----------
docs/features/networking/Routing.rst:.. code-block:: none
docs/features/networking/Routing.rst:.. code-block:: none
docs/features/networking/Routing.rst:--------------
docs/features/networking/Routing.rst:.. code-block:: none
docs/features/networking/Routing.rst:.. code-block:: none
docs/features/networking/Routing.rst:---------
docs/features/networking/TCP.rst:---------
docs/features/networking/TCP.rst:Example - TCP Echo Test
docs/features/networking/TCP.rst:-----------------------
docs/features/networking/TCP.rst:-  Add the source file as ``shell/xsh_echotest.c``.
docs/features/networking/TCP.rst:-  Modify ``shell/shell.c`` and ``include/shell.h`` to include the
docs/features/networking/TCP.rst:-  Modify ``shell/Makerules`` to include ``xsh_echotest.c`` and then
docs/features/networking/TCP.rst:-  Boot XINU
docs/features/networking/TCP.rst:-  Run **netup** command from the shell
docs/features/networking/TCP.rst:-  Run **echoclient** from the shell with the arguments of the echoserver's
docs/features/networking/TCP.rst:------------------
docs/features/networking/TCP.rst:     * @return non-zero value on error
docs/features/networking/TCP.rst:        interface = netLookup((ethertab[0].dev)->num);
docs/features/networking/TCP.rst:        localhost = &(interface->ip);
docs/features/networking/TCP.rst:            printf("Client: Got response - %s\r\n", buf);
docs/features/networking/TCP.rst:---------
docs/features/networking/TCP.rst:* :wikipedia:`Transmission Control Protocol - Wikipedia <Transmission Control Protocol>`
docs/features/networking/TFTP.rst:included in :doc:`CFE </mips/Common-Firmware-Environment>` on the
docs/features/networking/TFTP.rst:various MIPS-based routers, which is third-party firmware.
docs/features/networking/TFTP.rst::source:`include/tftp.h` also includes several compile-time parameters
docs/features/networking/TFTP.rst:---------
docs/features/networking/TFTP.rst:- :wikipedia:`Trivial File Transfer Protocol - Wikipedia <Trivial File Transfer Protocol>`
docs/features/networking/TFTP.rst:- :rfc:`1350`
docs/features/networking/UDP.rst:---------
docs/features/networking/UDP.rst:---------------------
docs/features/networking/UDP.rst:-------------------------
docs/features/networking/UDP.rst:-  Add the both of the files to the shell directory as ``xsh_udpclient.c``
docs/features/networking/UDP.rst:-  Modify ``system/shell.c`` and ``include/shell.h`` to include the
docs/features/networking/UDP.rst:-  Modify ``shell/Makerules`` to include ``xsh_udpclient.c`` and
docs/features/networking/UDP.rst:-  Boot two separate XINU consoles
docs/features/networking/UDP.rst:-  Run **netup** from the shell on both consoles
docs/features/networking/UDP.rst:-  Run **udpserver** from the shell on the first console
docs/features/networking/UDP.rst:-  Run **udpclient** from the shell on the second console with the arguments
docs/features/networking/UDP.rst:    * @return non-zero value on error
docs/features/networking/UDP.rst:        interface = netLookup((ethertab[0].dev)->num);
docs/features/networking/UDP.rst:        localhost = &(interface->ip);
docs/features/networking/UDP.rst:    * @return non-zero value on error
docs/features/networking/UDP.rst:        interface = netLookup((ethertab[0].dev)->num);
docs/features/networking/UDP.rst:        localhost = &(interface->ip);
docs/features/networking/UDP.rst:            printf("Server: Received Message - %s\r\n", udp->data);
docs/features/networking/UDP.rst:---------
docs/features/networking/UDP.rst:* :wikipedia:`User Datagram Protocol - Wikipedia <User Datagram Protocol>`
Binary file docs/features/networking/XINUNetStack-Print.jpeg matches
Binary file docs/features/networking/XINUNetStack-Screen.jpeg matches
Binary file docs/features/networking/XINUNetStack.pdf matches
docs/features/networking/index.rst:   Networking-Stack
docs/index.rst:   Getting-Started
docs/make.bat:	set SPHINXBUILD=sphinx-build
docs/make.bat:set ALLSPHINXOPTS=-d %BUILDDIR%/doctrees %SPHINXOPTS% .
docs/make.bat:	set ALLSPHINXOPTS=-D latex_paper_size=%PAPER% %ALLSPHINXOPTS%
docs/make.bat:	set I18NSPHINXOPTS=-D latex_paper_size=%PAPER% %I18NSPHINXOPTS%
docs/make.bat:	echo.  xml        to make Docutils-native XML files
docs/make.bat:	echo.  pseudoxml  to make pseudoxml-XML files for display purposes
docs/make.bat:	echo.The 'sphinx-build' command was not found. Make sure you have Sphinx
docs/make.bat:	echo.to the full path of the 'sphinx-build' executable. Alternatively you
docs/make.bat:	echo.http://sphinx-doc.org/
docs/make.bat:	%SPHINXBUILD% -b html %ALLSPHINXOPTS% %BUILDDIR%/html
docs/make.bat:	%SPHINXBUILD% -b dirhtml %ALLSPHINXOPTS% %BUILDDIR%/dirhtml
docs/make.bat:	%SPHINXBUILD% -b singlehtml %ALLSPHINXOPTS% %BUILDDIR%/singlehtml
docs/make.bat:	%SPHINXBUILD% -b pickle %ALLSPHINXOPTS% %BUILDDIR%/pickle
docs/make.bat:	%SPHINXBUILD% -b json %ALLSPHINXOPTS% %BUILDDIR%/json
docs/make.bat:	%SPHINXBUILD% -b htmlhelp %ALLSPHINXOPTS% %BUILDDIR%/htmlhelp
docs/make.bat:	%SPHINXBUILD% -b qthelp %ALLSPHINXOPTS% %BUILDDIR%/qthelp
docs/make.bat:	echo.^> assistant -collectionFile %BUILDDIR%\qthelp\EmbeddedXinu.ghc
docs/make.bat:	%SPHINXBUILD% -b devhelp %ALLSPHINXOPTS% %BUILDDIR%/devhelp
docs/make.bat:	%SPHINXBUILD% -b epub %ALLSPHINXOPTS% %BUILDDIR%/epub
docs/make.bat:	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
docs/make.bat:	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
docs/make.bat:	make all-pdf
docs/make.bat:	%SPHINXBUILD% -b latex %ALLSPHINXOPTS% %BUILDDIR%/latex
docs/make.bat:	make all-pdf-ja
docs/make.bat:	%SPHINXBUILD% -b text %ALLSPHINXOPTS% %BUILDDIR%/text
docs/make.bat:	%SPHINXBUILD% -b man %ALLSPHINXOPTS% %BUILDDIR%/man
docs/make.bat:	%SPHINXBUILD% -b texinfo %ALLSPHINXOPTS% %BUILDDIR%/texinfo
docs/make.bat:	%SPHINXBUILD% -b gettext %I18NSPHINXOPTS% %BUILDDIR%/locale
docs/make.bat:	%SPHINXBUILD% -b changes %ALLSPHINXOPTS% %BUILDDIR%/changes
docs/make.bat:	%SPHINXBUILD% -b linkcheck %ALLSPHINXOPTS% %BUILDDIR%/linkcheck
docs/make.bat:	%SPHINXBUILD% -b doctest %ALLSPHINXOPTS% %BUILDDIR%/doctest
docs/make.bat:	%SPHINXBUILD% -b xml %ALLSPHINXOPTS% %BUILDDIR%/xml
docs/make.bat:	%SPHINXBUILD% -b pseudoxml %ALLSPHINXOPTS% %BUILDDIR%/pseudoxml
docs/make.bat:	echo.Build finished. The pseudo-XML files are in %BUILDDIR%/pseudoxml.
docs/mips/Common-Firmware-Environment.rst:-----
docs/mips/Common-Firmware-Environment.rst:-  Initializes the system
docs/mips/Common-Firmware-Environment.rst:-  Sets up a basic environment in which code can run
docs/mips/Common-Firmware-Environment.rst:-  Optionally provides a command line interface non-standard usage
docs/mips/Common-Firmware-Environment.rst:-  Loads and executes a kernel image (expecting to be jettisoned shortly
docs/mips/Common-Firmware-Environment.rst:----------------
docs/mips/Common-Firmware-Environment.rst:<HOWTO-Connect-to-Modified-Router>`, just type "reboot" (assuming
docs/mips/Common-Firmware-Environment.rst:reboot the router. This can also be done by power-cycling the router.
docs/mips/Common-Firmware-Environment.rst:----------------------
docs/mips/Common-Firmware-Environment.rst:The CFE Command Line Interface (CLI) is a very simple "shell-like"
docs/mips/Common-Firmware-Environment.rst:To get the to the CLI, you can use either the power-on method or load
docs/mips/Common-Firmware-Environment.rst:.. code-block:: none
docs/mips/Common-Firmware-Environment.rst:    Total memory used by CFE:  0x80300000 - 0x803A39C0 (670144)
docs/mips/Common-Firmware-Environment.rst:    Initialized Data:          0x803398D0 - 0x8033BFE0 (10000)
docs/mips/Common-Firmware-Environment.rst:    BSS Area:                  0x8033BFE0 - 0x8033D9C0 (6624)
docs/mips/Common-Firmware-Environment.rst:    Local Heap:                0x8033D9C0 - 0x803A19C0 (409600)
docs/mips/Common-Firmware-Environment.rst:    Stack Area:                0x803A19C0 - 0x803A39C0 (8192)
docs/mips/Common-Firmware-Environment.rst:    Text (code) segment:       0x80300000 - 0x803398D0 (235728)
docs/mips/Common-Firmware-Environment.rst:    Boot area (physical):      0x003A4000 - 0x003E4000
docs/mips/Common-Firmware-Environment.rst:    Relocation Factor:         I:00000000 - D:00000000
docs/mips/Common-Firmware-Environment.rst:    Device eth0:  hwaddr 00-16-B6-28-7D-4F, ipaddr 192.168.1.1, mask 255.255.255.0
docs/mips/Common-Firmware-Environment.rst:.. code-block:: none
docs/mips/Common-Firmware-Environment.rst:    For more information about a command, enter 'help command-name'
docs/mips/Common-Firmware-Environment.rst:From there we type ``ifconfig -auto eth0`` which will ask the xinu
docs/mips/Common-Firmware-Environment.rst:.. code-block:: none
docs/mips/Common-Firmware-Environment.rst:    CFE> ifconfig -auto eth0
docs/mips/Common-Firmware-Environment.rst:    Device eth0:  hwaddr 00-16-B6-28-7D-4F, ipaddr 192.168.5.2, mask 255.255.254.0
docs/mips/Common-Firmware-Environment.rst:.. code-block:: none
docs/mips/Common-Firmware-Environment.rst:    CFE> boot -elf 192.168.5.220:supervoc.boot
docs/mips/Common-Firmware-Environment.rst:.. code-block:: none
docs/mips/Common-Firmware-Environment.rst:    boot -elf 192.168.5.220:supervoc.boot
docs/mips/Common-Firmware-Environment.rst:.. code-block:: none
docs/mips/Common-Firmware-Environment.rst:.. code-block:: none
docs/mips/Common-Firmware-Environment.rst:.. code-block:: none
docs/mips/EJTAG.rst:EJTAG is a MIPS-specific extension of IEEE 1149.1, the Joint Test Action
docs/mips/EJTAG.rst:-  direct control of processor for step-by-step debugging
docs/mips/EJTAG.rst:-  access to busses and registers
docs/mips/EJTAG.rst:   -  aids in debugging
docs/mips/EJTAG.rst:   -  possible usage as additional peripheral data bus
docs/mips/EJTAG.rst:   -  direct writing to flash for firmware updates (and de-bricking)
docs/mips/EJTAG.rst:---------
docs/mips/EJTAG.rst:The use of the EJTAG port on the WRT54-series routers gives the user
docs/mips/EJTAG.rst:the host parallel port, and vice-versa. An implementation of this
docs/mips/EJTAG.rst:------------------------
docs/mips/EJTAG.rst:check :doc:`EJTAG-ID-Codes-and-Implementation-Registers`.
docs/mips/EJTAG.rst:------
docs/mips/EJTAG.rst:   unbuffered cable from OpenWRT; used by de-brick utility
docs/mips/EJTAG.rst:.. figure:: images/Xinu-Wiggler.png
docs/mips/EJTAG.rst:--------
docs/mips/EJTAG.rst:- :doc:`EJTAG-ID-Codes-and-Implementation-Registers`
docs/mips/Exception-and-Interrupt-Handling.rst:at runtime or fall-back to the default trap handler.
docs/mips/Exception-and-Interrupt-Handling.rst:of these steps do not exist, the handler will fall-back to the default
docs/mips/Flash-Driver.rst:|EX| uses a multi-layered approach to dealing with :doc:`Flash-Memory`
docs/mips/Flash-Driver.rst:on platforms where it is available (including MIPS-based routers such
docs/mips/Flash-Driver.rst:--------------
docs/mips/Flash-Driver.rst:-  ``FLASH_BLOCK_SIZE`` returns the size of logical blocks for the Flash
docs/mips/Flash-Driver.rst:-  ``FLASH_N_BLOCKS`` returns the number of block available on the Flash
docs/mips/Flash-Driver.rst:-  ``FLASH_SYNC`` forces a synchronization from cached data onto Flash
docs/mips/Flash-Driver.rst:   -  ``FLASH_BLOCK`` synchronizes a specific erase block, and
docs/mips/Flash-Driver.rst:   -  ``FLASH_LOGBLOCK`` synchronizes a logical block of data.
docs/mips/Flash-Driver.rst:-------------
docs/mips/Flash-Driver.rst:Normal block-oriented devices present a consistent view of data storage
docs/mips/Flash-Driver.rst:bytes. Flash memory does not act like normal block-oriented devices
docs/mips/Flash-Driver.rst:into two erase block regions, one with 8 - 8 KB erase blocks and the
docs/mips/Flash-Driver.rst:other with 63 - 64 KB erase blocks.
docs/mips/Flash-Driver.rst:--------------
docs/mips/Flash-Driver.rst:When a non-read request is made to the physical layer the software steps
docs/mips/Flash-Driver.rst:through a series of operations to change an erase block from read-mode
docs/mips/Flash-Driver.rst:spin the physical layer off as a separate pre-emptible process.
docs/mips/Flash-Driver.rst:-----
docs/mips/Flash-Memory.rst:memory is mapped 1-1 into the address range between ``0xBC00 0000``
docs/mips/Flash-Memory.rst:and ``0xBC3F FFFF``. This allows for random read-access without using
docs/mips/Flash-Memory.rst:--------------
docs/mips/Flash-Memory.rst:-  ``0xBC00 1000`` has backup NVRAM settings. If the "proper" settings
docs/mips/Flash-Memory.rst:-  ``0xBC00 1E00`` holds the "true" MAC address of device. During CFE
docs/mips/Flash-Memory.rst:-  ``0xBC00 1F00`` holds the current CFE boot version (should be "v3.7"
docs/mips/Flash-Memory.rst:-  ``0xBC00 2000`` is the beginning of CFE code.
docs/mips/Flash-Memory.rst:-  ``0xBC03 F400`` is a unique device ID (should match the NVRAM setting
docs/mips/Flash-Memory.rst:-  ``0xBC03 F408`` is a unique private key for device (should match the
docs/mips/Flash-Memory.rst:-  ``0xBC03 F508`` is a unique public key for device (should match the
docs/mips/Flash-Memory.rst:-  ``0xBC04 0000`` is the beginning of the operating system kernel
docs/mips/Flash-Memory.rst:   :doc:`TRX-Header`.
docs/mips/Flash-Memory.rst:-  ``0xBC3F 8000`` is the location of proper :ref:`NVRAM settings
docs/mips/Flash-Memory.rst:-------------
docs/mips/Flash-Memory.rst:operations are more detailed on the :doc:`Flash-Driver` page
docs/mips/Flash-Memory.rst:----------------------
docs/mips/Flash-Memory.rst:device size (as :math:`2^n`), and information about up-to four erase
docs/mips/Flash-Memory.rst:-----
docs/mips/Flash-Memory.rst:While technically a misnomer, NVRAM (non-volatile random access memory)
docs/mips/Flash-Memory.rst:| ``+---------------------------------------------------------------+``
docs/mips/Flash-Memory.rst:| ``+---------------------------------------------------------------+``
docs/mips/Flash-Memory.rst:| ``+---------------+---------------+-------------------------------+``
docs/mips/Flash-Memory.rst:| ``+---------------+---------------+-------------------------------+``
docs/mips/Flash-Memory.rst:| ``+-------------------------------+-------------------------------+``
docs/mips/Flash-Memory.rst:| ``+---------------------------------------------------------------+``
docs/mips/General-Purpose-Input-Output.rst:----------------
docs/mips/General-Purpose-Input-Output.rst:---------
docs/mips/General-Purpose-Input-Output.rst:-  Input (0xb8000060) - If a GPIO pin is set for output, its input bit
docs/mips/General-Purpose-Input-Output.rst:-  Output (0xb8000064) - If a GPIO pin is set for input, its output bit
docs/mips/General-Purpose-Input-Output.rst:-  Enable (0xb8000068) - Determines if a GPIO pin is used for input or
docs/mips/General-Purpose-Input-Output.rst:-  Control (0xb800006c) - Usage is currently unknown.
docs/mips/General-Purpose-Input-Output.rst:----
docs/mips/General-Purpose-Input-Output.rst:-  An LED is enabled by setting its enable bit to 1.
docs/mips/General-Purpose-Input-Output.rst:-  When an LED is enabled, its input bit becomes 0.
docs/mips/General-Purpose-Input-Output.rst:-  Once an LED is enabled, if its output bit is 0, the LED is on and if
docs/mips/General-Purpose-Input-Output.rst:---------
docs/mips/General-Purpose-Input-Output.rst:-  `SD Card Reader
docs/mips/General-Purpose-Input-Output.rst:   Driver <http://devel.masikh.org/OpenWRT/mmc/wrt54gl-v1.1/mmc.c>`__
docs/mips/General-Purpose-Input-Output.rst:-  `Adding an MMC/SD
docs/mips/HOWTO-Backup-Router.rst:dd-wrt
docs/mips/HOWTO-Backup-Router.rst:------
docs/mips/HOWTO-Backup-Router.rst:`dd-wrt <http://www.dd-wrt.com/>`__, you can download the CFE from the
docs/mips/HOWTO-Backup-Router.rst:---
docs/mips/HOWTO-Backup-Router.rst::doc:`serial console <HOWTO-Connect-to-Modified-Router>` and a live
docs/mips/HOWTO-Backup-Router.rst:</teaching/HOWTO-Deploy-Xinu>`. On the TFTP server, create a file for
docs/mips/HOWTO-Backup-Router.rst:the backup image. It must be world writable.  If you do not pre-create
docs/mips/HOWTO-Backup-Router.rst:Access the :doc:`CFE <Common-Firmware-Environment>` using the
docs/mips/HOWTO-Backup-Router.rst:    CFE> ifconfig eth0 -auto
docs/mips/HOWTO-Backup-Router.rst:    Device eth0:  hwaddr 00-1E-E5-86-02-7A, ipaddr 192.168.6.122, mask 255.255.255.0
docs/mips/HOWTO-Backup-Router.rst::doc:`recover <HOWTO-Recover-Router>` via JTAG it will take a LONG
docs/mips/HOWTO-Backup-Router.rst:----
docs/mips/HOWTO-Backup-Router.rst::doc:`HOWTO-Recover-Router` page.
docs/mips/HOWTO-Backup-Router.rst:Use the ``-probeonly`` option to figure out what options TJTAG needs for
docs/mips/HOWTO-Backup-Router.rst:    user@host:tjtag$ ./tjtag -backup:cfe /wiggler /noemw /noreset
docs/mips/HOWTO-Connect-to-Modified-Router.rst:-------
docs/mips/HOWTO-Connect-to-Modified-Router.rst:---------------
docs/mips/HOWTO-Connect-to-Modified-Router.rst:yet, please see :doc:`HOWTO-Modify-the-Linksys-Hardware`.
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Loaded plugins: refresh-packagekit
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    --> Running transaction check
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    ---> Package picocom.i386 0:1.4-4.fc9 set to be updated
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    --> Finished Dependency Resolution
docs/mips/HOWTO-Connect-to-Modified-Router.rst:     picocom                 i386       1.4-4.fc9        fedora             29 k
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    (1/1): picocom-1.4-4.fc9.i386.rpm                        |  29 kB     00:00
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Installed: picocom.i386 0:1.4-4.fc9
docs/mips/HOWTO-Connect-to-Modified-Router.rst:includes a basic serial console utility called **tty-connect**. However
docs/mips/HOWTO-Connect-to-Modified-Router.rst:Tools <Console Tools>`__'s **tty-connect** utility for directly
docs/mips/HOWTO-Connect-to-Modified-Router.rst:utility does not allow the user to send a ``ctrl-C`` command over the
docs/mips/HOWTO-Connect-to-Modified-Router.rst:------------------------------
docs/mips/HOWTO-Connect-to-Modified-Router.rst:port--if you followed our instructions on :doc:`modifying the router
docs/mips/HOWTO-Connect-to-Modified-Router.rst:<HOWTO-Modify-the-Linksys-Hardware>` it will be the **DB9 Female**
docs/mips/HOWTO-Connect-to-Modified-Router.rst::doc:`Null Modem <Serial-Adapter-Diagrams>`; check your
docs/mips/HOWTO-Connect-to-Modified-Router.rst:`` picocom -b 115200 /dev/ttyS0 `` (where `` /dev/ttyS0 `` is the name
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    [root@argolis ~]# picocom -b 115200 /dev/ttyS0
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    escape is      : C-a
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    send_cmd is    : ascii_xfr -s -v -l10
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    receive_cmd is : rz -vv
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Total memory used by CFE:  0x80300000 - 0x803A39C0 (670144)
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Initialized Data:          0x803398D0 - 0x8033BFE0 (10000)
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    BSS Area:                  0x8033BFE0 - 0x8033D9C0 (6624)
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Local Heap:                0x8033D9C0 - 0x803A19C0 (409600)
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Stack Area:                0x803A19C0 - 0x803A39C0 (8192)
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Text (code) segment:       0x80300000 - 0x803398D0 (235728)
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Boot area (physical):      0x003A4000 - 0x003E4000
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Relocation Factor:         I:00000000 - D:00000000
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Device eth0:  hwaddr 00-18-39-6F-78-15, ipaddr 192.168.1.1, mask 255.255.255.0
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    BusyBox v0.60.0 (2005.11.14-09:45+0000) Built-in shell (msh)
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Enter 'help' for a list of built-in commands.
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Total memory used by CFE:  0x80300000 - 0x803A39C0 (670144)
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Initialized Data:          0x803398D0 - 0x8033BFE0 (10000)
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    BSS Area:                  0x8033BFE0 - 0x8033D9C0 (6624)
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Local Heap:                0x8033D9C0 - 0x803A19C0 (409600)
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Stack Area:                0x803A19C0 - 0x803A39C0 (8192)
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Text (code) segment:       0x80300000 - 0x803398D0 (235728)
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Boot area (physical):      0x003A4000 - 0x003E4000
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Relocation Factor:         I:00000000 - D:00000000
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Device eth0:  hwaddr 00-18-39-6F-78-15, ipaddr 192.168.1.1, mask 255.255.255.0
docs/mips/HOWTO-Connect-to-Modified-Router.rst:    Automatic startup canceled via Ctrl-C
docs/mips/HOWTO-Connect-to-Modified-Router.rst:----------------
docs/mips/HOWTO-Connect-to-Modified-Router.rst:you are ready to :doc:`Build </Getting-Started>` and :doc:`Deploy
docs/mips/HOWTO-Connect-to-Modified-Router.rst:</teaching/HOWTO-Deploy-Xinu>` XINU.
docs/mips/HOWTO-Connect-to-Modified-Router.rst:----------------
docs/mips/HOWTO-Connect-to-Modified-Router.rst:*This work is supported in part by NSF grant DUE-CCLI-0737476.*
docs/mips/HOWTO-Install-OpenWRT.rst:----------------
docs/mips/HOWTO-Install-OpenWRT.rst:-  Download the correct toolchain
docs/mips/HOWTO-Install-OpenWRT.rst:-  Build the toolchain
docs/mips/HOWTO-Install-OpenWRT.rst:-  Download a linux kernel
docs/mips/HOWTO-Install-OpenWRT.rst:-  Download selected packages
docs/mips/HOWTO-Install-OpenWRT.rst:-  Use the toolchain to build the kernel / packages
docs/mips/HOWTO-Install-OpenWRT.rst:-  Smush everything together into several flavors of executable
docs/mips/HOWTO-Install-OpenWRT.rst:-  Also create versions with proper Linksys headers so that they can be
docs/mips/HOWTO-Install-OpenWRT.rst:------------------
docs/mips/HOWTO-Install-OpenWRT.rst:OpenWRT does not interest us--it only provides us with a working
docs/mips/HOWTO-Install-OpenWRT.rst:open-source implementation of an embedded operating system on the
docs/mips/HOWTO-Install-OpenWRT.rst:is ``openwrt-wrt54g-squashfs.bin``
docs/mips/HOWTO-Install-OpenWRT.rst:   OpenWRT-running box.
docs/mips/HOWTO-Install-OpenWRT.rst:hardware <HOWTO-Modify-the-Linksys-Hardware>`.
docs/mips/HOWTO-Install-OpenWRT.rst:-------------
docs/mips/HOWTO-Install-OpenWRT.rst:-  http://www.openwrt.org - OpenWRT home page
docs/mips/HOWTO-Install-OpenWRT.rst:-  http://wiki.openwrt.org/OpenWrtDocs/Hardware/Linksys/WRT54GL -
docs/mips/HOWTO-Install-OpenWRT.rst:-----
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:-------
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:the ASUS wl-330gE router to take advantage of the serial port on the
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:Firmware Environment <Common-Firmware-Environment>`'s, or :doc:`CFE
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:<Common-Firmware-Environment>`, command line interface which is
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:---------------
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:- `Transceiver schematic
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:  <http://www.mscs.mu.edu/~brylow/xinu/Xinu-Transceiver.ps>`__ is in
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:- `Transceiver PCB layout <http://www.mscs.mu.edu/~brylow/xinu/Xinu-Transceiver.pcb>`__
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:- `Transceiver fabrication tarball
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:  <http://www.mscs.mu.edu/~brylow/xinu/Xinu-Transceiver.tgz>`__
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:.. list-table::
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:    :header-rows: 1
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:    * - Quantity
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Part Name
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Details
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Part / Model Number
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Price
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:    * - 1
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - ASUS [[wl-330gE]] Router
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - 802.11b/g wireless access point
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - http://usa.asus.com/
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - ~$40.00
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:    * - 1
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - IDC socket connector
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - 4 pin header
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Jameco
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      -
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:    * - 1
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - IDC socket connector
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - 5 pin header
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Jameco
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      -
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:    * - 1
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - IDC shrouded double header
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - 0.1”, 10 conductor
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Jameco 67811CM
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - $0.33
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:    * - 1
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - ADM202 Transceiver Chip
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Serial Transceiver ADM202EAN
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Jameco 1800464
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - $1.60
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:    * - 2
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Capacitor 220 nF
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Tantalum,.22uF,35V,10%
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Jameco 33507
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - $0.18
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:    * - 3
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Capacitor 100 nF
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Tantalum,.1uF,35V,10%
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Jameco 33488
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - $0.22
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:    * - 1
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - DB9 Female
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - 22AWG,SOLDER CUP
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - Jameco 15771CM
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:      - $0.59
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:- Soldering Iron
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:- Dremel tool (for cutting holes in plastic case)
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:- Continuity Tester (Multimeter, or some other way of checking for
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:- Voltmeter (Multimeter will work for this, too)
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:----------------------------
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:For easier connectivity, we can use a 4-pin header on the board to
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:solder the 4-pin header onto the board.
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:be used for a 4-wired cable to attach the router to the transceiver
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:.. figure:: images/Transceiver_schematic_wl-330gE.jpg
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:from the router to conventional RS-232 serial voltages. To do this, we
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:The easiest way to accomplish this is to use an 4-wire audio cable
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:the transceiver board. Using the 4-pin header on the router, connect
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:the four wires from the audio cable into the 4-pin header. On the
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:cables on the shrouded double header, but using a 5-pin serial header
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:----------------
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:<HOWTO-Connect-to-Modified-Router>`.
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:----------
docs/mips/HOWTO-Modify-the-ASUS-Hardware.rst:*This work is supported in part by NSF grant DUE-CCLI-0737476.*
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:-------
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:<Common-Firmware-Environment>`'s command line interface.  Gaining
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:direct access to :doc:`CFE <Common-Firmware-Environment>` is a key
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:---------------
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:- `Transceiver schematic
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:  <http://www.mscs.mu.edu/~brylow/xinu/Xinu-Transceiver.ps>`__ is in
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:- `Transceiver PCB layout <http://www.mscs.mu.edu/~brylow/xinu/Xinu-Transceiver.pcb>`__
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:- `Transceiver fabrication tarball
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:  <http://www.mscs.mu.edu/~brylow/xinu/Xinu-Transceiver.tgz>`__
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:.. list-table::
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:    :header-rows: 1
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:    * - Quantity
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Part Name
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Details
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Part / Model Number
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Price
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:    * - 1
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Linksys :doc:`WRT54GL <WRT54GL>` Router
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - 802.11b/g wireless broadband router
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - `Linksys WRT54GL <http://www.linksys.com/servlet/Satellite?c=L_Product_C2&childpagename=US%2FLayout&cid=1133202177241&pagename=Linksys%2FCommon%2FVisitorWrapper>`__
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - ~$65.00
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:    * - 1
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Ribbon cable
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - 28 AWG, 10 conductor, 25'
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Jameco  643508CM
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - $4.99
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:    * - 2
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - IDC socket connector
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - 0.1”, 10 conductor
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Jameco  32491CM
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - $0.25
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:    * - 2
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - IDC shrouded double header
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - 0.1”, 10 conductor
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Jameco 67811CM
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - $0.33
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:    * - 1
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - ADM202 Transceiver Chip
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Serial Transceiver ADM202EAN
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Jameco 1800464
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - $1.60
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:    * - 2
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Capacitor 220 nF
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Tantalum,.22uF,35V,10%
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Jameco 33507
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - $0.18
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:    * - 3
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Capacitor 100 nF
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Tantalum,.1uF,35V,10%
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Jameco 33488
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - $0.22
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:    * - 1
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - DB9 Female
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - 22AWG,SOLDER CUP
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Jameco 15771CM
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - $0.59
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:    * - 1
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - DB9 Male
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - 22AWG,SOLDER CUP
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - Jameco 15747CM
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:      - $0.59
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:- Soldering Iron
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:- Dremel tool (for cutting holes in plastic case)
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:- Continuity Tester (Multimeter, or some other way of checking for proper connections)
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:- Voltmeter (Multimeter will work for this, too)
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:----------------------------
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:.. figure::  images/Opening-linksys.jpg
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:<http://voidmain.is-a-geek.net/redhat/wrt54g_revival.html>`__ can be
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:.. figure:: images/Wrt54gl-layout.jpg
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:grid of 10 holes (5x2) located on the bottom-right corner of the board
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:when the antennae stubs are on top (see the top-down photo for
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:the two serial interfaces--UART0, and UART1--on the device.
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:placing a nice 10-pin header on the board we can easily attach and
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:3.3 volt serial signals from the router to conventional RS-232 serial
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:custom-made printed circuit board to simplify assembly, as shown here.
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:marking -- direction matters!
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:------------------------   -------------------------
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:------------------------   -------------------------
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:   Now that everything is connected we can re-assemble it.  First you
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:----------------
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:<HOWTO-Connect-to-Modified-Router>`.
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:----------------
docs/mips/HOWTO-Modify-the-Linksys-Hardware.rst:*This work is supported in part by NSF grant DUE-CCLI-0737476.*
Binary file docs/mips/images/Attach_Back.jpg matches
Binary file docs/mips/images/Attach_Front.jpg matches
Binary file docs/mips/images/Baytech.png matches
Binary file docs/mips/images/BaytechWiring.png matches
Binary file docs/mips/images/Complete.jpg matches
Binary file docs/mips/images/Complete_transceiver_board.jpg matches
Binary file docs/mips/images/Completed_transceiver.jpg matches
Binary file docs/mips/images/DB9M.png matches
Binary file docs/mips/images/DB9_serial_port_wiring.jpg matches
Binary file docs/mips/images/Drilled_front.jpg matches
Binary file docs/mips/images/Front.jpg matches
Binary file docs/mips/images/Front_sticker.jpg matches
Binary file docs/mips/images/Impcode.png matches
Binary file docs/mips/images/JTAGunbuffered.png matches
Binary file docs/mips/images/NullModem.png matches
Binary file docs/mips/images/Opening-linksys.jpg matches
Binary file docs/mips/images/Serial.jpg matches
Binary file docs/mips/images/Serial_Port_Connection.jpg matches
Binary file docs/mips/images/Serial_ports_diagram.jpg matches
Binary file docs/mips/images/Serial_ports_done.jpg matches
Binary file docs/mips/images/Serial_ports_done1.jpg matches
Binary file docs/mips/images/Te_jtag_cable.png matches
Binary file docs/mips/images/Tranceiver_attached.jpg matches
Binary file docs/mips/images/Transceiver_board.jpg matches
Binary file docs/mips/images/Transceiver_schematic.jpg matches
Binary file docs/mips/images/Transceiver_schematic_wl-330gE.jpg matches
Binary file docs/mips/images/UartAsyncDriver.png matches
Binary file docs/mips/images/Wiggler.png matches
Binary file docs/mips/images/Wrt54gl-layout.jpg matches
Binary file docs/mips/images/Xinu-Wiggler.png matches
docs/mips/HOWTO-Recover-Router.rst:considered non-functional. The information below is mostly specific to
docs/mips/HOWTO-Recover-Router.rst:commands vary slightly between bootloaders (ex.  `U-Boot
docs/mips/HOWTO-Recover-Router.rst:<http://sourceforge.net/projects/u-boot/>`__ vs CFE).
docs/mips/HOWTO-Recover-Router.rst:----------------
docs/mips/HOWTO-Recover-Router.rst:<HOWTO-Backup-Router>`. Hopefully you did this earlier so you can
docs/mips/HOWTO-Recover-Router.rst:-------------
docs/mips/HOWTO-Recover-Router.rst:power it back up. If this isn't working for you, try the dd-wrt
docs/mips/HOWTO-Recover-Router.rst:<http://www.dd-wrt.com/wiki/index.php/Hard_reset_or_30/30/30>`__ reset
docs/mips/HOWTO-Recover-Router.rst:that were stored in NVRAM. Don't forget to re-configure and commit your
docs/mips/HOWTO-Recover-Router.rst:--------------
docs/mips/HOWTO-Recover-Router.rst:configured, then your flash image is probably fine--fix your serial
docs/mips/HOWTO-Recover-Router.rst:re-flashing the firmware with TFTP.
docs/mips/HOWTO-Recover-Router.rst:----
docs/mips/HOWTO-Recover-Router.rst:.. code-block:: none
docs/mips/HOWTO-Recover-Router.rst:make/model this seems to vary greatly--most likely because of various
docs/mips/HOWTO-Recover-Router.rst:flash chip manufacturers. For starters, we'll use the ``-probeonly``
docs/mips/HOWTO-Recover-Router.rst:    ``user@host:tjtag$ ./tjtag -probeonly /wiggler /noemw /noreset``
docs/mips/HOWTO-Recover-Router.rst:.. code-block:: none
docs/mips/HOWTO-Recover-Router.rst:     EJTAG Debrick Utility v3.0.1 Tornado-MOD
docs/mips/HOWTO-Recover-Router.rst:        - EJTAG IMPCODE ....... : 00000000100000000000100100000100 (00800904)
docs/mips/HOWTO-Recover-Router.rst:        - EJTAG Version ....... : 1 or 2.0
docs/mips/HOWTO-Recover-Router.rst:        - EJTAG DMA Support ... : Yes
docs/mips/HOWTO-Recover-Router.rst:        - EJTAG Implementation flags: R4k MIPS32
docs/mips/HOWTO-Recover-Router.rst:        - Flash Chip Window Start .... : 1fc00000
docs/mips/HOWTO-Recover-Router.rst:        - Flash Chip Window Length ... : 00400000
docs/mips/HOWTO-Recover-Router.rst:        - Selected Area Start ........ : 00000000
docs/mips/HOWTO-Recover-Router.rst:        - Selected Area Length ....... : 00000000
docs/mips/HOWTO-Recover-Router.rst:.. code-block:: none
docs/mips/HOWTO-Recover-Router.rst:     EJTAG Debrick Utility v3.0.1 Tornado-MOD
docs/mips/HOWTO-Recover-Router.rst:        - EJTAG IMPCODE ....... : 00000000100000000000100100000100 (00800904)
docs/mips/HOWTO-Recover-Router.rst:        - EJTAG Version ....... : 1 or 2.0
docs/mips/HOWTO-Recover-Router.rst:        - EJTAG DMA Support ... : Yes
docs/mips/HOWTO-Recover-Router.rst:        - EJTAG Implementation flags: R4k MIPS32
docs/mips/HOWTO-Recover-Router.rst:.. code-block:: none
docs/mips/HOWTO-Recover-Router.rst:     EJTAG Debrick Utility v3.0.1 Tornado-MOD
docs/mips/HOWTO-Recover-Router.rst:-  the header is soldered properly
docs/mips/HOWTO-Recover-Router.rst:-  tjtag has permission to use the parallel port
docs/mips/HOWTO-Recover-Router.rst:-  you didn't forget the ``/wiggler`` switch (active cable only).
docs/mips/HOWTO-Recover-Router.rst:options correct with the ``-probeonly`` option. If an operation hangs
docs/mips/HOWTO-Recover-Router.rst:not lost. Be patient--be sure you've given it ample time to complete. If
docs/mips/HOWTO-Recover-Router.rst:    ``user@host:tjtag$ ./tjtag -erase:nvram /wiggler /noemw /noreset``
docs/mips/HOWTO-Recover-Router.rst:options you figured out during the ``-probeonly`` phase.
docs/mips/HOWTO-Recover-Router.rst:    ``user@host:tjtag$ ./tjtag -erase:kernel /wiggler /noemw /noreset``
docs/mips/HOWTO-Recover-Router.rst:using :doc:`the usual methods <HOWTO-Backup-Router>`.
docs/mips/HOWTO-Recover-Router.rst:see our :doc:`flash memory <Flash-Memory>` page for specific locations.
docs/mips/HOWTO-Recover-Router.rst:persistently). Especially, if you are running a pseudo-static DHCP
docs/mips/HOWTO-Recover-Router.rst:.. code-block:: none
docs/mips/HOWTO-Recover-Router.rst:    ``user@host:tjtag$ ./tjtag -flash:cfe /wiggler /noemw /noreset``
docs/mips/HOWTO-Recover-Router.rst:Now, go get a cup of coffee or take a power nap. Bit-banging a few
docs/mips/HOWTO-Recover-Router.rst:-------------------
docs/mips/HOWTO-Recover-Router.rst:-  `OpenWrt JTAG
docs/mips/HOWTO-Recover-Router.rst:-  `OpenWrt Utilities <http://downloads.openwrt.org/utils/>`__
docs/mips/HOWTO-Recover-Router.rst:-  `TJTAG
docs/mips/HOWTO-Recover-Router.rst:-  `TIAO Wiki Debrick
docs/mips/HOWTO-Recover-Router.rst:-  `Shed <http://sourceforge.net/projects/shed/>`__ (Simple Hex Editor)
docs/mips/Memory.rst:Memory on MIPS-based processors is broken into several segments,
docs/mips/Memory.rst:consuming the entire 32-address space. These segments are arranged as
docs/mips/Memory.rst:-  `User Segment`_ (USEG), 2 GB **mapped** and
docs/mips/Memory.rst:-  `Kernel Segment 0`_ (KSEG0), 512 MB **unmapped** and **cached**,
docs/mips/Memory.rst:-  `Kernel Segment 1`_ (KSEG1), 512 MB **unmapped** and **uncached**,
docs/mips/Memory.rst:-  `Kernel Segment 2`_ (KSEG2), 1 GB **mapped** and **cached**,
docs/mips/Memory.rst:Note that the :doc:`WRT54GL` only has 16 MB of main memory, so a 1-1
docs/mips/Memory.rst:------------
docs/mips/Memory.rst:turn into 1-1, so directly accessing these address is not recommended.
docs/mips/Memory.rst:</features/Memory-Management>` as of the 2.0 release.  During
docs/mips/Memory.rst:into the system page table. All mappings are 1-1 since there is no
docs/mips/Memory.rst:---------------
docs/mips/Memory.rst:segment is sub-divided into three segments with different memory access
docs/mips/Memory.rst:-  `KSEG0 <Kernel Segment 0>`_ uses **unmapped** and **cached** memory
docs/mips/Memory.rst:-  `KSEG1 <Kernel Segment 1>`_ uses **unmapped** and **uncached**
docs/mips/Memory.rst:-  `KSEG2 <Kernel Segment 2>`_ uses **mapped** and **cached** memory
docs/mips/Memory.rst:manager for a mapping, but will store and modifications in the on-chip
docs/mips/Memory.rst:-  ``0x8000 0000`` (32 instructions) is for the TLB exception handler,
docs/mips/Memory.rst:-  ``0x8000 0080`` (32 instructions) is for the 64-bit TLB exception
docs/mips/Memory.rst:-  ``0x8000 0180`` (32 instructions) is for the generic exception
docs/mips/Memory.rst::doc:`WRT54GL` uses a 32-bit MIPS processor, Embedded Xinu loads a
docs/mips/Memory.rst:entry points (32-bit function pointers for 32 possible exceptions) and
docs/mips/Memory.rst:(32-bit function pointers for 8 possible interrupts).
docs/mips/Memory.rst:``ld.script``): text, read-only data, data, and block started by symbol
docs/mips/Memory.rst:The :doc:`kernel memory allocator </features/Memory-Management>` will
docs/mips/Memory.rst:read-only in all address spaces, giving a user thread the ability to
docs/mips/Memory.rst:mapping and it *will* bypass the on-chip memory cache for memory loads
docs/mips/Memory.rst:pre-existing, so they are out-of-range of physical memory addresses, or
docs/mips/Memory.rst:out-of-range of physical memory and some hardware devices that use
docs/mips/Memory.rst:-  Broadcom I/O controller registers at ``0xB800 0000``,
docs/mips/Memory.rst:-  UART registers at ``0xB800 0300`` and ``0xB800 0400``,
docs/mips/Memory.rst:-  Broadcom Ethernet 47xx registers at ``0xB800 1000``,
docs/mips/Memory.rst:-  Broadcom Wireless LAN controller registers at ``0xB800 5000``,
docs/mips/Memory.rst:-  Broadcom 47xx RoboSwitch registers at ``0xB800 6000``, and
docs/mips/Memory.rst:-  :doc:`Flash memory <Flash-Memory>` (4 MB) read mapped beginning at
docs/mips/Memory.rst:problematic because both KSEG0 and KSEG1 use a 1-1 memory mapping. With
docs/mips/Memory.rst:on-chip cache.
docs/mips/Memory.rst:----------
docs/mips/Mips-console.rst:    #!/usr/bin/expect -f
docs/mips/Mips-console.rst:            send -null 1
docs/mips/Mips-console.rst:            expect "(command-mode)"
docs/mips/Mips-console.rst:            send -- "p"
docs/mips/Mips-console.rst:                    -re ".*\r\n"    { send "\003"
docs/mips/Mips-console.rst:    set timeout -1
docs/mips/Mips-console.rst:      puts "usage: mips-console [backend]"
docs/mips/Mips-console.rst:      set spawned [spawn xinu-console -c mips $argv]
docs/mips/Mips-console.rst:      set spawned [spawn xinu-console -c mips]
docs/mips/Mips-console.rst:            -re "connection '(.*)', class '(.*)', host '(.*)'\r\n"
docs/mips/Mips-console.rst:    send -null 1
docs/mips/Mips-console.rst:    expect "(command-mode) "
docs/mips/Mips-console.rst:    send -- "d"
docs/mips/Mips-console.rst:    send -- "xinu.boot\r"
docs/mips/Mips-console.rst:    send -- "\r"
docs/mips/Mips-console.rst:            -timeout 1 "CFE> " {set boot 0}
docs/mips/Mips-console.rst:    send -- "ifconfig -auto eth0\r"
docs/mips/Mips-console.rst:    send -- "boot -elf $ip:$backend"
docs/mips/Mips-console.rst:    send -- ".boot\r"
docs/mips/Mips-console.rst:    expect -- "Starting program"
docs/mips/Mipsel-qemu.rst:mipsel-qemu
docs/mips/Mipsel-qemu.rst:|EX| has been ported to the MIPSel (little-endian MIPS) virtual
docs/mips/Mipsel-qemu.rst:--------
docs/mips/Mipsel-qemu.rst:``PLATFORM=mipsel-qemu``.  Note that this requires a :ref:`cross
docs/mips/Mipsel-qemu.rst:compiler <cross_compiler>` targeting little-endian MIPS ("mipsel").
docs/mips/Mipsel-qemu.rst:-------
docs/mips/Mipsel-qemu.rst:    $ qemu-system-mipsel -M mips -m 16M -kernel xinu.boot -nographic
docs/mips/Mipsel-qemu.rst:-----
docs/mips/Mipsel-qemu.rst:The ``mipsel-qemu`` platform does not yet support networking.
docs/mips/Processor.rst:------------------------
docs/mips/Processor.rst:The identification is split into 4 8-byte chunks in the following order
docs/mips/Processor.rst:-------------
docs/mips/Processor.rst:-  bit 31 - (1) CP0\_CONFIG1 exisits
docs/mips/Processor.rst:-  bit 15 - (0) Little Endian
docs/mips/Processor.rst:-  bit 14:13 - (0) MIPS 32 standard
docs/mips/Processor.rst:-  bit 12:10 - (0) Revision 1
docs/mips/Processor.rst:-  bit 9:7 - (1) MIPS 32/64 Compliant TLB
docs/mips/Processor.rst:-  bit 3 - (0) I-cache is not indexed or tagged with virtual addresses
docs/mips/Processor.rst:-  bit 2:0 - (3) kseg0 coherency algorithm (cacheable)
docs/mips/Processor.rst:-  bit 30:25 - (31) 2\ :sup:`5` entries in TLB (31+1)
docs/mips/Processor.rst:-  bit 24:22 - (3) I-cache number of index positions 64\*2\ :sup:`3` =
docs/mips/Processor.rst:   512-bytes
docs/mips/Processor.rst:-  bit 21:19 - (3) I-cache line size 2\*2\ :sup:`3` = 16-bytes
docs/mips/Processor.rst:-  bit 18:16 - (1) I-cache associativity (A+1) = 2-way set associative
docs/mips/Processor.rst:-  bit 15:13 - (2) D-cache number of index positions 64\*2\ :sup:`2` =
docs/mips/Processor.rst:   256-bytes
docs/mips/Processor.rst:-  bit 12:10 - (3) D-cache line size 2\*2\ :sup:`3` = 16-bytes
docs/mips/Processor.rst:-  bit 9:7 - (1) D-cache associativity (A+1) = 2-way set associative
docs/mips/Processor.rst:-  bit 6 - (0) no CP2
docs/mips/Processor.rst:-  bit 5 - (0) no MDMX ASE implementation
docs/mips/Processor.rst:-  bit 4 - (0) no performance counter
docs/mips/Processor.rst:-  bit 3 - (0) no watchpoint register
docs/mips/Processor.rst:-  bit 2 - (0) no MIPS16e instruction set available
docs/mips/Processor.rst:-  bit 1 - (1) EJTAG debug unit IS available
docs/mips/Processor.rst:-  bit 0 - (0) no floating point unit attached
docs/mips/Processor.rst:This gives the following data: I-cache has 512 sets/way, 16 bytes/line,
docs/mips/Processor.rst:and is 2-way set-associative (16 KByte I-cache) and D-cache has 256
docs/mips/Processor.rst:sets/way, 16 bytes/line, and is 2-way set-associative (8 KByte D-cache).
docs/mips/Processor.rst:-  bit 30:25 - (31) 2\ :sup:`5` entries in TLB (31+1, same as WRT54GL)
docs/mips/Processor.rst:-  bit 24:22 - (2) I-cache number of index positions 64\*2\ :sup:`2` =
docs/mips/Processor.rst:   256-bytes
docs/mips/Processor.rst:-  bit 21:19 - (3) I-cache line size 2\*2\ :sup:`3` = 16-bytes
docs/mips/Processor.rst:-  bit 18:16 - (3) I-cache associativity (A+1) = 2-way set associative
docs/mips/Processor.rst:-  bit 15:13 - (3) D-cache number of index positions 64\*2\ :sup:`3` =
docs/mips/Processor.rst:   512-bytes
docs/mips/Processor.rst:-  bit 12:10 - (3) D-cache line size 2\*2\ :sup:`3` = 16-bytes
docs/mips/Processor.rst:-  bit 9:7 - (1) D-cache associativity (A+1) = 2-way set associative
docs/mips/Processor.rst:-  bit 6 - (0) no CP2
docs/mips/Processor.rst:-  bit 5 - (0) no MDMX ASE implementation
docs/mips/Processor.rst:-  bit 4 - (0) no performance counter
docs/mips/Processor.rst:-  bit 3 - (0) no watchpoint register
docs/mips/Processor.rst:-  bit 2 - (1) MIPS16e instruction set IS available
docs/mips/Processor.rst:-  bit 1 - (1) EJTAG debug unit IS available
docs/mips/Processor.rst:-  bit 0 - (0) no floating point unit attached
docs/mips/Processor.rst:I-cache has 256 sets/way, 16 bytes/line, and is 2-way set-associative (8
docs/mips/Processor.rst:KByte I-cache) and D-cache has 512 sets/way, 16 bytes/line, and is 2-way
docs/mips/Processor.rst:set-associative (16 KByte D-cache)
docs/mips/Serial-Adapter-Diagrams.rst:-----------------
docs/mips/Serial-Adapter-Diagrams.rst:</teaching/HOWTO-Build-Backend-Pool>` in a pool. The first diagram is
docs/mips/Serial-Adapter-Diagrams.rst:for UART 0 (DTE). The second diagram is for the platform-dependent
docs/mips/Serial-Adapter-Diagrams.rst:----------
docs/mips/Serial-Adapter-Diagrams.rst:--------------------
docs/mips/Serial-Adapter-Diagrams.rst:Baytech serial-controlled power strip and the EtherLite terminal annex.
docs/mips/Startup.rst:------------
docs/mips/Startup.rst:-----------
docs/mips/Switch-Driver.rst:-----------------------
docs/mips/Switch-Driver.rst:+-------+-----+-----+-----+-----+
docs/mips/Switch-Driver.rst:+-------+-----+-----+-----+-----+
docs/mips/Switch-Driver.rst:+-----+-----+-----+-----+-----+
docs/mips/Switch-Driver.rst:+-----+-----+-----+-----+-----+
docs/mips/Switch-Driver.rst:----------------------------------
docs/mips/Switch-Driver.rst:By default, the four LAN ports (0-3) are part of the same VLAN in CFE.
docs/mips/TRX-Header.rst:TRX is the format used to store kernel images in :doc:`Flash-Memory`
docs/mips/TRX-Header.rst:-  alignment problems,
docs/mips/TRX-Header.rst:-  compression/extraction problems,
docs/mips/TRX-Header.rst:-  incorrectly configuration at startup (differences between TFTP
docs/mips/TRX-Header.rst:-  combination of above and some unknown problem.
docs/mips/TRX-Header.rst:.. code-block:: none
docs/mips/TRX-Header.rst:    +---------------------------------------------------------------+
docs/mips/TRX-Header.rst:    +---------------------------------------------------------------+
docs/mips/TRX-Header.rst:    +---------------+---------------+-------------------------------+
docs/mips/TRX-Header.rst:    |                       32-bit CRC value                        |
docs/mips/TRX-Header.rst:    +---------------+---------------+-------------------------------+
docs/mips/TRX-Header.rst:    +-------------------------------+-------------------------------+
docs/mips/TRX-Header.rst:    +---------------------------------------------------------------+
docs/mips/TRX-Header.rst:    +---------------------------------------------------------------+
docs/mips/TRX-Header.rst:    +---------------------------------------------------------------+
docs/mips/TRX-Header.rst:------------
docs/mips/TRX-Header.rst:<https://dev.openwrt.org/browser/trunk/tools/firmware-utils/src/addpattern.c>`__
docs/mips/UART-Driver.rst:The UART driver is a char-oriented driver designed to work with a
docs/mips/UART-Driver.rst:-------------
docs/mips/UART-Driver.rst:--------------
docs/mips/UART-Driver.rst:-  Line control is set to 8 bit, no parity, 1 stop.
docs/mips/UART-Driver.rst:-  Receiver FIFO full, transmitt buffer empty, and receiver line status
docs/mips/UART-Driver.rst:-  Hardware FIFOs are enabled.
docs/mips/UART-Driver.rst:-  Divisor Latch bits (high and low)
docs/mips/UART-Driver.rst:   -  The divisor can be calculated by using the formula:
docs/mips/UART-Driver.rst:the clockspeed. (The WRT54GL, for example, has a hard-coded clockrate of
docs/mips/UART-Driver.rst:---------------------------
docs/mips/UART-Driver.rst:------------------------------
docs/mips/UART-Driver.rst:-  Line or modem status: The interrupt is merely noted in the UART's
docs/mips/UART-Driver.rst:-  Receiver hardware FIFO trigger level: The driver moves bytes from the
docs/mips/UART-Driver.rst:-  Transmitter hardware FIFO empty: The lower half fills the UART's
docs/mips/UART-Driver.rst:-------
docs/mips/UART-Driver.rst:output flags for the UART driver. Non-blocking flags indicate the upper
docs/mips/UART-Driver.rst:--------
docs/mips/UART-Driver.rst:- :doc:`/features/TTY-Driver`
docs/mips/WRT54GL.rst:-------------
docs/mips/WRT54GL.rst:-  **eth0**: Broadcom 47xx 10/100BaseT Ethernet
docs/mips/WRT54GL.rst:-  **eth1**: Broadcom BCM4320 802.11 Wireless Controller 3.90.37.0
docs/mips/WRT54GL.rst:--------
docs/mips/WRT54GL.rst:-  WRT54G
docs/projects/Curses.rst:</features/TTY-Driver>` and :doc:`serial driver </mips/UART-Driver>`.
docs/projects/Curses.rst:-----------------------
docs/projects/Curses.rst:interfaces. This terminal independence requires a multi-layered internal
docs/projects/Curses.rst:-------------
docs/projects/Curses.rst:---------
docs/projects/Curses.rst:-  Strang, John. *Programming with curses*. Sebastopol, CA: O'Reilly,
docs/projects/Curses.rst:-  Gookin, Dan. *Programmer's Guide to nCurses*. Indianapolis: Wiley,
docs/projects/Curses.rst:-  `Announcing ncurses 5.6 <http://www.gnu.org/software/ncurses/>`__
docs/projects/WinX.rst:----------
docs/projects/WinX.rst:-  Working Objective Statement
docs/projects/WinX.rst:   -  Design and implement a Windows program to allow Windows-based
docs/projects/WinX.rst:-  Current developers include:
docs/projects/WinX.rst:   -  Adam Koehler
docs/projects/WinX.rst:   -  Nicholas McMillan
docs/projects/WinX.rst:   -  Matthew Thomson
docs/projects/WinX.rst:   -  Christopher Swiderski
docs/projects/WinX.rst:--------------
docs/projects/WinX.rst:-  Design
docs/projects/WinX.rst:   -  The design phase spanned the whole first academic semester
docs/projects/WinX.rst:-  Implementation
docs/projects/WinX.rst:   -  The implementation stage will span the whole second academic
docs/projects/WinX.rst:-  Major Implemenation Phases
docs/projects/WinX.rst:   -  Internal: January - Alpha Stage (Completed)
docs/projects/WinX.rst:   -  Alpha: March 12, 2008 (Completed)
docs/projects/WinX.rst:   -  Beta: [STRIKEOUT:April 9, 2008] April 16, 2008 (Active)
docs/projects/WinX.rst:   -  Live: April 28, 2008
docs/projects/WinX.rst:----------------
docs/projects/WinX.rst:---------------
docs/projects/WinX.rst:-  Step 1: Copy the WinXINU-Installer folder via SSH to your desktop:
docs/projects/WinX.rst:   web location ~ http://www.mscs.mu.edu/~nmcmilla/WinXINU-Installer/
docs/projects/WinX.rst:-  Step 2: Go into Cygwin Install Folder
docs/projects/WinX.rst:   -  2a) Run Setup.exe
docs/projects/WinX.rst:   -  2b) Select Install from Local - Folder is the only other folder in
docs/projects/WinX.rst:   -  2c) Click ALL to set it to Uninstall all packages its at top of
docs/projects/WinX.rst:   -  2d) Click Devel package to set it to Install it is found within in
docs/projects/WinX.rst:-  Step 3: Change the first line of the compiler/makeVars file (found in
docs/projects/WinX.rst:-  Step 4: Run WinXINU executable
docs/projects/WinX.rst:-  Step 5: Navigate to config tab, change location of cygwin\\bin to
docs/projects/WinX.rst:-  Step 6: Navigate to config tab, change location of compile directory
docs/projects/WinX.rst:------------------------
docs/projects/WinX.rst:--------------
docs/projects/WinX.rst:-  Improve cygwin installation process.
docs/projects/WinX.rst:   -  (Didn't work very well on a computer that had already been setup.)
docs/projects/WinX.rst:      - Outside scope, no its not
docs/projects/WinX.rst:   -  Get rid of stuff in devel package that is unnecessary
docs/projects/WinX.rst:-  [STRIKEOUT:I should be able to click 'make' or 'make clean' whenever
docs/projects/WinX.rst:   -  [STRIKEOUT:and there should be a mechanism for making other
docs/projects/WinX.rst:      targets as well.] - Outside scope
docs/projects/WinX.rst:-  [STRIKEOUT:Implement 'Errors and Warnings' checkbox.] **Fixed:
docs/projects/WinX.rst:xinu-status
docs/projects/WinX.rst:-  Perhaps only query morbius at most once per second (disabling the
docs/projects/WinX.rst:-  [STRIKEOUT:Connect to backend, select mips-console, program complains
docs/projects/WinX.rst:   and goes on anyway. No good.] **Fixed: 4/21/08 by nmcmilla** - Checks
docs/projects/WinX.rst:-  [STRIKEOUT:Run 'testsuite' and compare output to linux version
docs/projects/WinX.rst:   -  [STRIKEOUT:also typing a single \\ should produce a single slash.
docs/projects/WinX.rst:-  [STRIKEOUT:Verify \*ALL\* control characters are not printed.]
docs/projects/WinX.rst:-  [STRIKEOUT:Is there any way that hitting backspace won't jump to the
docs/projects/WinX.rst:-  [STRIKEOUT:Something with 'mips-console' and xinu just going,
docs/projects/WinX.rst:   -  [STRIKEOUT:if the download fails it still keeps on a truckin'.]
docs/projects/WinX.rst:-  [STRIKEOUT:Continue session doesn't continue session until a client
docs/projects/WinX.rst:   -  [STRIKEOUT:Also, I can backspace over previous characters after
docs/projects/WinX.rst:      typing ctrl-space.] '''Fixed: 4/22/08 by nmcmilla '''
docs/projects/WinX.rst:   -  [STRIKEOUT:Perhaps, ctrl-space should also be the continue code
docs/projects/WinX.rst:-  [STRIKEOUT:Clear history in the interaction tabs (or even have a
docs/projects/WinX.rst:-  [STRIKEOUT:xsh$ clear (makes WinX go boom).] **Fixed: 4/16/08 by
docs/projects/WinX.rst:-  'Command request timed out' ... clearly it did not.
docs/projects/WinX.rst:-  [STRIKEOUT:Should have option to connect to same backend2 name as
docs/projects/WinX.rst:-  [STRIKEOUT:Clicking cancel in the select specific backend2 should not
docs/projects/WinX.rst:-  [STRIKEOUT:Connect to preferred when already connected produces no
docs/projects/WinX.rst:-  [STRIKEOUT:Connecting to backend2 hops to the top of the textbox.]
docs/projects/WinX.rst:-  [STRIKEOUT:Is there any way that hitting backspace won't jump to the
docs/projects/WinX.rst:   top and back down?] - NO
docs/projects/WinX.rst:-  [STRIKEOUT:Ctrl-space should work here too. And make sure continue
docs/projects/WinX.rst:-  [STRIKEOUT:New user profile should auto-set in config after
docs/projects/WinX.rst:-  [STRIKEOUT:The color seems funky (tab color doesn't match background
docs/projects/WinX.rst:-  Needs icon.
docs/projects/WinX.rst:-  [STRIKEOUT:Needs About.]\ **Fixed 4/23/08 by mthomson**
docs/projects/WinX.rst:-  Needs 'command descriptions'
docs/projects/WinX.rst:-  Possibly needs a quick start guide in the help menu.-should be
docs/projects/WinX.rst:-  [STRIKEOUT:No keybindings for 'New Profile,' 'Save Profile,'
docs/projects/WinX.rst:--------------
docs/projects/WinXinu-Installation.rst:-------------------
docs/projects/WinXinu-Installation.rst:-  Operating System: Windows XP or Windows Vista
docs/projects/WinXinu-Installation.rst:-  Ability to connect to XINU server
docs/projects/WinXinu-Installation.rst:-  Microsoft .Net Framework v3.0 or higher
docs/projects/WinXinu-Installation.rst:-  `Cygwin <http://www.cygwin.com>`__ w/ Development package
docs/projects/WinXinu-Installation.rst:-  HDD Space
docs/projects/WinXinu-Installation.rst:   -  60 megabytes (WinXINU)
docs/projects/WinXinu-Installation.rst:   -  1310 megabytes (Cygwin)
docs/projects/WinXinu-Installation.rst:   -  Total ~1.4 gigabytes
docs/projects/WinXinu-Installation.rst:-------------------------
docs/projects/WinXinu-Installation.rst:-  `WinXINU + Cygwin Installation & Configuration
docs/projects/WinXinu-Installation.rst:   Guide <http://xinu.mscs.mu.edu/wiki/images/9/93/WinXINU-install_guide.pdf>`__
docs/projects/WinXinu-Installation.rst:-  Step 1: Go to `Cygwin.com <http://www.cygwin.com/>`__
docs/projects/WinXinu-Installation.rst:-  Step 2: Download the installation file, setup.exe
docs/projects/WinXinu-Installation.rst:-  Step 3: Run Cygwin Setup
docs/projects/WinXinu-Installation.rst:   -  Note: During setup, the only package that needs to be set to
docs/projects/WinXinu-Installation.rst:-  Step 1: Download the
docs/projects/WinXinu-Installation.rst:   `setup <http://www.mscs.mu.edu/~brylow/xinu/WinXINU-setup.exe>`__
docs/projects/WinXinu-Installation.rst:-  Step 2: Run the WinXINU setup file and follow the `Instruction
docs/projects/WinXinu-Installation.rst:   Gude <http://xinu.mscs.mu.edu/wiki/images/9/93/WinXINU-install_guide.pdf>`__
docs/projects/WinXinu-Installation.rst:--------------------------
docs/projects/WinXinu-Installation.rst:-  Modify the make file of your code
docs/projects/WinXinu-Installation.rst:   -  Change the first line of the mipsVars file to the location of the
docs/projects/WinXinu-Installation.rst:      -  NOTE: this should be found within your XINU code directory in
docs/projects/WinXinu-Installation.rst:      -  e.g. xinu/compile/mipsVars
docs/projects/WinXinu-Installation.rst:-  Modify the server settings XML file
docs/projects/WinXinu-Installation.rst:   -  Ensure the server IP is correct
docs/projects/WinXinu-Installation.rst:   -  Ensure that the server port number is correct
docs/projects/WinXinu-Installation.rst:   -  Ensure that the IP address in the automation command is correct
docs/projects/WinXinu-Installation.rst:-  Modify the configuration profile settings within the program
docs/projects/WinXinu-Installation.rst:   -  Navigate to the config tab, then change:
docs/projects/WinXinu-Installation.rst:      -  the location of cygwin\\bin to its location on local machine
docs/projects/WinXinu-Installation.rst:      -  the location of compile directory where the Makefile is located
docs/projects/WinXinu.rst:--------------------
docs/projects/WinXinu.rst:-------------
docs/projects/WinXinu.rst:-  Operating System: Windows XP or Windows Vista
docs/projects/WinXinu.rst:-  Ability to connect to XINU server
docs/projects/WinXinu.rst:-  Microsoft .Net Framework v3.0 or higher
docs/projects/WinXinu.rst:-  HDD Space
docs/projects/WinXinu.rst:   -  60 megabytes (WinXINU)
docs/projects/WinXinu.rst:   -  1310 megabytes (Cygwin)
docs/projects/WinXinu.rst:   -  Total ~1.4 gigabytes
docs/projects/WinXinu.rst:-  `WinXINU
docs/projects/WinXinu.rst:   Manual <http://xinu.mscs.mu.edu/wiki/images/6/6d/WinXINU-manual.pdf>`__
docs/projects/WinXinu.rst:-------------------
docs/projects/WinXinu.rst:-  Goal
docs/projects/WinXinu.rst:   -  To design and develop frontend client that is graphically oriented
docs/projects/WinXinu.rst:-  Subversion Repository
docs/projects/WinXinu.rst:   -  https://xinu.mscs.mu.edu/svn/projects/windows-tools/
docs/projects/WinXinu.rst:----------------
docs/projects/XinuPhone.rst:hands-on interactive learning that is both cross-discipline and
docs/projects/XinuPhone.rst:open-source platform useful for benchmarking experimental methods
docs/projects/XinuPhone.rst:.. image:: Xinuphone-system.jpg
docs/projects/XinuPhone.rst:------------
docs/projects/XinuPhone.rst:<http://en.wikipedia.org/wiki/Digital-to-analog_converter>`__ from
docs/projects/XinuPhone.rst:network-enabled backend running the Embedded Xinu operating system in
docs/projects/XinuPhone.rst:first passes through an analog low-pass anti-aliasing filter before it
docs/projects/XinuPhone.rst:RS-232 capable network device, such as a slightly modified Linksys
docs/projects/XinuPhone.rst:on-board the DSC converts the audio samples back to an analog waveform
docs/projects/XinuPhone.rst:--------
docs/projects/XinuPhone.rst:.. image:: Xinuphone-schematic-page1.png
docs/projects/XinuPhone.rst:.. image:: Xinuphone-schematic-page2.png
docs/projects/XinuPhone.rst:Sheet 2 illustrates the headphone amplifier, microphone pre-amplifier,
docs/projects/XinuPhone.rst:and low-pass anti-aliasing filter.
docs/projects/XinuPhone.rst:-  Components are specified to EIA E96 standard values for resistors (1%
docs/projects/XinuPhone.rst:-  For capacitors in the audio path, temperature coefficient X7R, NP0,
docs/projects/XinuPhone.rst:---------
docs/projects/XinuPhone.rst:.. list-table::
docs/projects/XinuPhone.rst:   :header-rows: 1
docs/projects/XinuPhone.rst:   * - File
docs/projects/XinuPhone.rst:     - Download Link
docs/projects/XinuPhone.rst:     - Checksum (SHA1)
docs/projects/XinuPhone.rst:   * - XinuPhone Firmware 1.0 (Binary+Source)
docs/projects/XinuPhone.rst:     - `gzip <http://www.mscs.mu.edu/~kpersohn/xinuphone/download/xinuphone-1.0.tar.gz>`__
docs/projects/XinuPhone.rst:     - 8aa4b4d7ed38c4c641e920905aabfee1a9d2dbc0
docs/projects/XinuPhone.rst:   * -
docs/projects/XinuPhone.rst:     - `bzip2 <http://www.mscs.mu.edu/~kpersohn/xinuphone/download/xinuphone-1.0.tar.bz2>`__
docs/projects/XinuPhone.rst:     - 6ecfecbb9d9bc399b961d0764923ce609b4c569a
docs/projects/XinuPhone.rst:   * - XinuPhone Hardware Schematic Rev 2.1
docs/projects/XinuPhone.rst:     - `pdf <http://www.mscs.mu.edu/~kpersohn/xinuphone/xinuphone.pdf>`__
docs/projects/XinuPhone.rst:     - a0f07d543f2b85440c31daa7d530066f682a8a5a
docs/projects/XinuPhone.rst:   * - Embedded Xinu Operating System
docs/projects/XinuPhone.rst:     - `url <http://xinu-os.org/Downloads>`__
docs/projects/XinuPhone.rst:     -
docs/projects/XinuPhone.rst:-----------------------
docs/projects/XinuPhone.rst:-  Interactive Real-Time Embedded Systems Education Infused with Applied
docs/projects/XinuPhone.rst:   Conference, pages 199-204, Munich, Germany, July 2011.
docs/projects/XinuPhone.rst:-  :doc:`/teaching/index`
docs/projects/XinuPhone.rst:-----------
docs/projects/XinuPhone.rst:-  Real-Time Transport Protocol support in Embedded Xinu
docs/projects/XinuPhone.rst:-  Analog Telephone Adapter (ATA) interface
docs/projects/XinuPhone.rst:-  Simple XinuPhone discovery protocol / address book
docs/projects/XinuPhone.rst:--------------
docs/projects/XinuPhone.rst:-  `dsPIC33FJ64GP802 Product Home <http://www.microchip.com/wwwproducts/Devices.aspx?dDocName=en532310>`__
docs/projects/XinuPhone.rst:-  `MPLAB IDE <http://www.microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=1406&dDocName=en019469&part=SW007002>`__
docs/projects/XinuPhone.rst:-  `Audio & Speech Application Libraries <http://www.microchip.com/stellent/idcplg?IdcService=SS_GET_PAGE&nodeId=2660&param=en535144>`__
docs/projects/XinuPhone.rst:-  `ITU-T Test Signals for Telecommunication Systems <http://www.itu.int/net/itu-t/sigdb/genaudio/Pseries.htm>`__
docs/projects/XinuPhone.rst:-  `ITU-T G.711 - Pulse Code Modulation (PCM) of Voice Frequencies <http://www.itu.int/rec/T-REC-G.711/en>`__
docs/projects/XinuPhone.rst:-  :rfc:`RFC 3550 - RTP: A Transport Protocol for Real-Time Applications <3550>`
docs/projects/XinuPhone.rst:-  `Advanced Circuits <http://www.4pcb.com>`__
docs/projects/XinuPhone.rst:-  `CadSoft EAGLE Schematic Capture & Board Layout Software <http://www.cadsoftusa.com/>`__
docs/projects/XinuPhone.rst:-  `SparkFun Tutorials <http://www.sparkfun.com/tutorials>`__
Binary file docs/projects/Xinuphone-schematic-page1.png matches
Binary file docs/projects/Xinuphone-schematic-page2.png matches
Binary file docs/projects/Xinuphone-system.jpg matches
docs/projects/Xipx.rst:16-bit address range because it all executes in 16-bit real mode. Also,
docs/projects/Xipx.rst:dumb -- why not just use the thrtab[thrcurrent].pdloc instead? Then you
docs/teaching/Adding-Monitors-To-Xinu.rst:------------------
docs/teaching/Adding-Monitors-To-Xinu.rst:Java-style monitors and typical counting semaphores. Any thread holding
docs/teaching/Adding-Monitors-To-Xinu.rst:----------------
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:--------
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:---------------
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:-  Lexical Analysis
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:-  Syntax Analysis
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:-  Semantic Analysis
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:-  IR Translation
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:-  Instruction Selection
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:-  Register Allocation
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:-  Recognize various classes of grammars, languages, and automata, and
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:-  Explain the major steps involved in compiling a high-level
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:   programming language down to a low-level target machine language.
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:-  Construct and use the major components of a modern compiler.
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:-  Work together effectively in teams on a substantial software
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:--------------------------
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:add high-level I/O and concurrency features to Appel and Palsberg's
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:We allow Java-like threading and synchronization with our added support
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:assignment to add these high-level I/O and concurrency features to the
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:constucts <Adding-Monitors-To-Xinu>` must be added to Xinu.
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:language one needs our :doc:`Xinu.java <Xinu-Helper-Class>` helper class.
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:.. list-table::
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    :header-rows: 1
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - Week
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Topics
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Assignments
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 01
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Introduction
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Project 1: Interpreter
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 02
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Lexical Analysis, Automata
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - :doc:`Project 2: Scanner <assignments/Scanner>`
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 03
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Syntax Analysis, Grammars
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Homework 1: Automata and Grammars
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 04
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Parser Generators
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - :doc:`Project 3: Parser <assignments/Parser>`
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 05
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Abstract Syntax Trees
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      -
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 06
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Semantic Analysis
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - :doc:`Project 4: Semantic Analysis <assignments/Semantic-Analysis>`
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 07
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Activation Records
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      -
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 08
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - IR Translation
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      -
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 09
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Basic Blocks
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - :doc:`Project 5: Translation <assignments/Translation>`
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 10
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Instruction Selection
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Homework 2: Activation Records
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 11
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Liveness Analysis
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      -
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 12
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Register Allocation
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      -
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 13
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Register Allocation
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - :doc:`Project 6: Instruction Selection <assignments/Instruction-Selection>`
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 14
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Advanced Topics
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      -
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:    * - 15
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Advanced Topics
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:      - Homework 3: Register Allocation
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:- [#appel2002]_
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:----------
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:--------------
docs/teaching/Compiler-Construction-With-Embedded-Xinu.rst:This work funded in part by NSF grant DUE-CCLI-0737476.
docs/teaching/HOWTO-Build-Backend-Pool.rst:-------
docs/teaching/HOWTO-Build-Backend-Pool.rst:---------------
docs/teaching/HOWTO-Build-Backend-Pool.rst:Image:XINU-Lab-schematic.gif
docs/teaching/HOWTO-Build-Backend-Pool.rst:</mips/HOWTO-Modify-the-Linksys-Hardware>` (~$10) running an embedded
docs/teaching/HOWTO-Build-Backend-Pool.rst::ref:`cross-compilers <cross_compiler>` are readily available when the
docs/teaching/HOWTO-Build-Backend-Pool.rst:</mips/HOWTO-Connect-to-Modified-Router>` to frontend serial ports, or
docs/teaching/HOWTO-Build-Backend-Pool.rst:-  Terminal Annex (EtherLite 32)
docs/teaching/HOWTO-Build-Backend-Pool.rst:-  Serial-Controlled Power Strip (BayTech)
docs/teaching/HOWTO-Build-Backend-Pool.rst:-  :doc:`/mips/Serial-Adapter-Diagrams`
docs/teaching/HOWTO-Build-Backend-Pool.rst:---------------------
docs/teaching/HOWTO-Build-Backend-Pool.rst:*tcp_wrappers-devel*, and *expect* packages. We used the commands
docs/teaching/HOWTO-Build-Backend-Pool.rst:``yum install tcp_wrappers``, ``yum install tcp_wrappers-devel``, and
docs/teaching/HOWTO-Build-Backend-Pool.rst:command ``rpmbuild --rebuild xinu-console-latest.src.rpm``. This will
docs/teaching/HOWTO-Build-Backend-Pool.rst:create four RPM files: ``xinu-console-server-2.05-3.i386.rpm``,
docs/teaching/HOWTO-Build-Backend-Pool.rst:``xinu-console-clients-2.05-3.i386.rpm``,
docs/teaching/HOWTO-Build-Backend-Pool.rst:``xinu-console-powerd-2.05-3.i386.rpm``,
docs/teaching/HOWTO-Build-Backend-Pool.rst:``xinu-console-debuginfo-2.05-3.i386.rpm `` (**NOTE:** the version
docs/teaching/HOWTO-Build-Backend-Pool.rst:``rpm -iv xinu-console-server-3.05-3.i386.rpm`` and
docs/teaching/HOWTO-Build-Backend-Pool.rst:``rpm -iv xinu-console-clients-2.05-3.i386.rpm``. You now have all the
docs/teaching/HOWTO-Build-Backend-Pool.rst:-----------
docs/teaching/HOWTO-Build-Backend-Pool.rst:``ifconfig -auto eth0``
docs/teaching/HOWTO-Build-Backend-Pool.rst:over the serial console. See :doc:`HOWTO-Deploy-Xinu` for more details.
docs/teaching/HOWTO-Build-Backend-Pool.rst:distribution (dhcp-3.0.5-3.fc6, as of this writing). Here is a sample
docs/teaching/HOWTO-Build-Backend-Pool.rst:`dhcpd.conf <http://www.mscs.mu.edu/~brylow/xinu/Morbius-dhcpd.conf>`__.
docs/teaching/HOWTO-Build-Backend-Pool.rst:-----------
docs/teaching/HOWTO-Build-Backend-Pool.rst:distribution (tftp-server-0.42-3.1, at this writing,) configured to
docs/teaching/HOWTO-Build-Backend-Pool.rst:writable by the xinu-console daemon user ID. Most TFTP daemons use TCP
docs/teaching/HOWTO-Build-Backend-Pool.rst:the command ``chgrp -R xinu /tftpboot`` followed by the command
docs/teaching/HOWTO-Build-Backend-Pool.rst:the line ``iptables -I INPUT -i eth1 -j ACCEPT`` to the
docs/teaching/HOWTO-Build-Backend-Pool.rst:-------------------
docs/teaching/HOWTO-Build-Backend-Pool.rst:    iptables -I INPUT -s $TRUSTED_NET -p tcp --destination-port 1024:65535 -j ACCEPT
docs/teaching/HOWTO-Build-Backend-Pool.rst:    iptables -I INPUT -s $TRUSTED_NET -p udp --destination-port $XINUD_PORT -j ACCEPT
docs/teaching/HOWTO-Build-Backend-Pool.rst:``/etc/xinu-consoled.conf``. Here is a sample of the configuration
docs/teaching/HOWTO-Build-Backend-Pool.rst:    #-------------------------- Connections ------------------------------
docs/teaching/HOWTO-Build-Backend-Pool.rst:    #---------------------------------------------------------------------
docs/teaching/HOWTO-Build-Backend-Pool.rst:    router1 mips /usr/sbin/tty-connect -r 115200 /dev/ttyS0
docs/teaching/HOWTO-Build-Backend-Pool.rst:    router1-dl DOWNLOAD   /usr/sbin/cp-download /tftpboot/router1.boot
docs/teaching/HOWTO-Build-Backend-Pool.rst:    router1-pc POWERCYCLE /usr/bin/xinu-power r01
docs/teaching/HOWTO-Build-Backend-Pool.rst:    router1-pf POWEROFF   /usr/bin/xinu-power d01
docs/teaching/HOWTO-Build-Backend-Pool.rst:    router1-pn POWERON    /usr/bin/xinu-power u01
docs/teaching/HOWTO-Build-Backend-Pool.rst:    router2 mips /usr/sbin/tty-connect -r 115200 /dev/ttyS1
docs/teaching/HOWTO-Build-Backend-Pool.rst:    router2-dl DOWNLOAD   /usr/sbin/cp-download /tftpboot/router2.boot
docs/teaching/HOWTO-Build-Backend-Pool.rst:    router2-pc POWERCYCLE /bin/echo "Turn off the router, then turn it on"
docs/teaching/HOWTO-Build-Backend-Pool.rst:    router2-pf POWEROFF   /bin/echo "Turn off the router"
docs/teaching/HOWTO-Build-Backend-Pool.rst:    router2-pn POWERON    /bin/echo "Turn on the router"
docs/teaching/HOWTO-Build-Backend-Pool.rst:``router1 mips /usr/sbin/tty-connect -r 115200 /dev/ttyS0`` tells the
docs/teaching/HOWTO-Build-Backend-Pool.rst:daemon should use ``tty-connect`` with a baudrate of 115200 on serial
docs/teaching/HOWTO-Build-Backend-Pool.rst:image for that backend router. So the line ``router1-dl DOWNLOAD
docs/teaching/HOWTO-Build-Backend-Pool.rst:/usr/sbin/cp-download /tftpboot/router1.boot`` tells the Xinu Console
docs/teaching/HOWTO-Build-Backend-Pool.rst:program ``/usr/sbin/cp-download`` which will take a user specified
docs/teaching/HOWTO-Build-Backend-Pool.rst:changing ``router1-dl`` to ``[backend name]-dl`` and by changing
docs/teaching/HOWTO-Build-Backend-Pool.rst:control the power of the backend pool (such as a Serial-Controlled Power
docs/teaching/HOWTO-Build-Backend-Pool.rst:----------
docs/teaching/HOWTO-Build-Backend-Pool.rst:Clients use the ``xinu-console`` program to connect their frontend
docs/teaching/HOWTO-Build-Backend-Pool.rst:command: ``xinu-console``. You may also pass as an argument to this
docs/teaching/HOWTO-Build-Backend-Pool.rst:work on and used **tty-connect** to establish a serial connection, the
docs/teaching/HOWTO-Build-Backend-Pool.rst:user can use the ``xinu-console`` program to interact with the backend
docs/teaching/HOWTO-Build-Backend-Pool.rst:by using some built-in commands and also by sending characters over
docs/teaching/HOWTO-Build-Backend-Pool.rst:*help* output for the built-in commands:
docs/teaching/HOWTO-Build-Backend-Pool.rst:Xinu Console Daemon configuration file ``xinu-consoled.conf``.
docs/teaching/HOWTO-Build-Backend-Pool.rst:Built-in xinu-console commands with these key words in them will call
docs/teaching/HOWTO-Build-Backend-Pool.rst:should see the words ``(command-mode)``, letting them know that the
docs/teaching/HOWTO-Build-Backend-Pool.rst:next character they enter will be interpreted by the xinu-console
docs/teaching/HOWTO-Build-Backend-Pool.rst:program as a built-in command and not as just another character to
docs/teaching/HOWTO-Build-Backend-Pool.rst:``xinu-console`` program, enter command mode and then type either "x"
docs/teaching/HOWTO-Build-Backend-Pool.rst:Mips-Console Wrapper Script
docs/teaching/HOWTO-Build-Backend-Pool.rst:So, though it is entirely possible to just use the ``xinu-console``
docs/teaching/HOWTO-Build-Backend-Pool.rst:backend (like our LinkSys routers). This is our ``mips-console``
docs/teaching/HOWTO-Build-Backend-Pool.rst:wrapper script located in the file ``/usr/bin/mips-console``. Here is
docs/teaching/HOWTO-Build-Backend-Pool.rst:a copy of the :doc:`mips-console file </mips/Mips-console>`. In order
docs/teaching/HOWTO-Build-Backend-Pool.rst:command ``mips-console`` to receive, connect to, and boot their own
docs/teaching/HOWTO-Deploy-Xinu.rst:necessary modifications </mips/HOWTO-Modify-the-Linksys-Hardware>` to
docs/teaching/HOWTO-Deploy-Xinu.rst:</mips/HOWTO-Connect-to-Modified-Router>` using serial communication
docs/teaching/HOWTO-Deploy-Xinu.rst:software (such as PICOCOM), and have :ref:`built a cross-compiler
docs/teaching/HOWTO-Deploy-Xinu.rst:-----------
docs/teaching/HOWTO-Deploy-Xinu.rst:end's package install commands to search for a tftp-server package and
docs/teaching/HOWTO-Deploy-Xinu.rst:    tftp.i386                                0.48-6.fc9             mulugupdates
docs/teaching/HOWTO-Deploy-Xinu.rst:    tftp-server.i386                         0.48-6.fc9             mulugupdates
docs/teaching/HOWTO-Deploy-Xinu.rst:"tftp" in the title. We want the package called *tftp-server.i386*
docs/teaching/HOWTO-Deploy-Xinu.rst:because this will allow us to run a **TFTP-Server** on our front end
docs/teaching/HOWTO-Deploy-Xinu.rst:tftp-server`` and obtained the following output::
docs/teaching/HOWTO-Deploy-Xinu.rst:    [root@argolis compile]# yum install tftp-server
docs/teaching/HOWTO-Deploy-Xinu.rst:    Loaded plugins: refresh-packagekit
docs/teaching/HOWTO-Deploy-Xinu.rst:    --> Running transaction check
docs/teaching/HOWTO-Deploy-Xinu.rst:    ---> Package tftp-server.i386 0:0.48-6.fc9 set to be updated
docs/teaching/HOWTO-Deploy-Xinu.rst:    --> Finished Dependency Resolution
docs/teaching/HOWTO-Deploy-Xinu.rst:     tftp-server             i386       0.48-6.fc9       mulugupdates       35 k 
docs/teaching/HOWTO-Deploy-Xinu.rst:    (1/1): tftp-server-0.48-6.fc9.i386.rpm                   |  35 kB     00:00    
docs/teaching/HOWTO-Deploy-Xinu.rst:      Installing: tftp-server                  ######################### [1/1] 
docs/teaching/HOWTO-Deploy-Xinu.rst:    Installed: tftp-server.i386 0:0.48-6.fc9
docs/teaching/HOWTO-Deploy-Xinu.rst:the command ``chkconfig --list`` and check to make sure *xinetd* is
docs/teaching/HOWTO-Deploy-Xinu.rst:     [root@argolis compile]# chkconfig --list
docs/teaching/HOWTO-Deploy-Xinu.rst:     avahi-daemon    0:off   1:off   2:off   3:on    4:on    5:on    6:off
docs/teaching/HOWTO-Deploy-Xinu.rst:     xinu-consoled   0:off   1:off   2:off   3:on    4:on    5:on    6:off
docs/teaching/HOWTO-Deploy-Xinu.rst:     yum-updatesd    0:off   1:off   2:on    3:on    4:on    5:on    6:off
docs/teaching/HOWTO-Deploy-Xinu.rst:             chargen-dgram:  off
docs/teaching/HOWTO-Deploy-Xinu.rst:             chargen-stream: off
docs/teaching/HOWTO-Deploy-Xinu.rst:             daytime-dgram:  off
docs/teaching/HOWTO-Deploy-Xinu.rst:             daytime-stream: off
docs/teaching/HOWTO-Deploy-Xinu.rst:             discard-dgram:  off
docs/teaching/HOWTO-Deploy-Xinu.rst:             discard-stream: off
docs/teaching/HOWTO-Deploy-Xinu.rst:             echo-dgram:     off
docs/teaching/HOWTO-Deploy-Xinu.rst:             echo-stream:    off
docs/teaching/HOWTO-Deploy-Xinu.rst:             tcpmux-server:  off
docs/teaching/HOWTO-Deploy-Xinu.rst:             time-dgram:     off
docs/teaching/HOWTO-Deploy-Xinu.rst:             time-stream:    off
docs/teaching/HOWTO-Deploy-Xinu.rst:    #       workstations, download configuration files to network-aware printers, \
docs/teaching/HOWTO-Deploy-Xinu.rst:            server_args             = -s /var/lib/tftpboot
docs/teaching/HOWTO-Deploy-Xinu.rst:     #       workstations, download configuration files to network-aware printers, \
docs/teaching/HOWTO-Deploy-Xinu.rst:             server_args             = -s /tftpboot
docs/teaching/HOWTO-Deploy-Xinu.rst:``iptables -I INPUT -i eth1 -j ACCEPT``. If you do not want to run this
docs/teaching/HOWTO-Deploy-Xinu.rst:``ifconfig eth0 -auto`` on your backend's CFE prompt to obtain an IP
docs/teaching/HOWTO-Deploy-Xinu.rst:configured with a static IP address in the 192.168.1.[2-255] range
docs/teaching/HOWTO-Deploy-Xinu.rst:----------------------------
docs/teaching/HOWTO-Deploy-Xinu.rst:static IP address in the 192.168.1.[2-255] range on its network
docs/teaching/HOWTO-Deploy-Xinu.rst:backend router </mips/HOWTO-Connect-to-Modified-Router>`. In the CFE
docs/teaching/HOWTO-Deploy-Xinu.rst:prompt type the command ``boot -elf [host ip]:xinu.boot`` where "[host
docs/teaching/HOWTO-Deploy-Xinu.rst:    CFE> boot -elf 192.168.1.2:xinu.boot
docs/teaching/HOWTO-Deploy-Xinu.rst:using [command] --help.
docs/teaching/HOWTO-Deploy-Xinu.rst:*tftp server directory*, and use the same ``boot -elf [host
docs/teaching/HOWTO-Deploy-Xinu.rst:----------------
docs/teaching/HOWTO-Deploy-Xinu.rst:</teaching/HOWTO-Build-Backend-Pool>` to allow multiple users to each
docs/teaching/HOWTO-Deploy-Xinu.rst:----------------
docs/teaching/HOWTO-Deploy-Xinu.rst:*This work is supported in part by NSF grant DUE-CCLI-0737476.*
docs/teaching/Laboratory.rst:------------------------------------
docs/teaching/Laboratory.rst:be more Xinu-specific information.
docs/teaching/Laboratory.rst:    WRT54Gv4, WRT54Gv8, or WL-330gE routers.
docs/teaching/Laboratory.rst:#. :doc:`Modify the Linksys hardware </mips/HOWTO-Modify-the-Linksys-Hardware>`
docs/teaching/Laboratory.rst:   or :doc:`Modify the ASUS hardware </mips/HOWTO-Modify-the-ASUS-Hardware>`
docs/teaching/Laboratory.rst:#. :doc:`/mips/HOWTO-Connect-to-Modified-Router`
docs/teaching/Laboratory.rst:#. :doc:`Build Xinu </Getting-Started>`
docs/teaching/Laboratory.rst:#. :doc:`Deploy Xinu </teaching/HOWTO-Deploy-Xinu>`
docs/teaching/Laboratory.rst:#. (Optional) :doc:`Build a pool of backends </teaching/HOWTO-Build-Backend-Pool>`
docs/teaching/Laboratory.rst:#. (Recommended) :doc:`Backup your router's factory configuration </mips/HOWTO-Backup-Router>`
docs/teaching/Networking-With-Xinu.rst:--------
docs/teaching/Networking-With-Xinu.rst:---------------
docs/teaching/Networking-With-Xinu.rst:-  History of networking.
docs/teaching/Networking-With-Xinu.rst:-  Overview of the specializations within net-centric computing.
docs/teaching/Networking-With-Xinu.rst:-  Network standards.
docs/teaching/Networking-With-Xinu.rst:-  ISO 7-layer reference model
docs/teaching/Networking-With-Xinu.rst:-  Circuit switching and packet switching
docs/teaching/Networking-With-Xinu.rst:-  Streams and datagrams
docs/teaching/Networking-With-Xinu.rst:-  Concepts and services for specific network layers.
docs/teaching/Networking-With-Xinu.rst:-  Protocol and application overview/implementation.
docs/teaching/Networking-With-Xinu.rst:-  Overview of network security.
docs/teaching/Networking-With-Xinu.rst:-  Discuss the evolution of early networks and the Internet.
docs/teaching/Networking-With-Xinu.rst:-  Explain the hierarchical, layered structure of network architecture.
docs/teaching/Networking-With-Xinu.rst:-  Identify and explain the development of important network standards.
docs/teaching/Networking-With-Xinu.rst:-  Discuss the advantages and disadvantages of different types of
docs/teaching/Networking-With-Xinu.rst:-  Demonstrate how a packet traverses the Internet.
docs/teaching/Networking-With-Xinu.rst:-  Implement a simple network using devices running the Embedded Xinu
docs/teaching/Networking-With-Xinu.rst:-  Discuss and explain the reasoning for network security.
docs/teaching/Networking-With-Xinu.rst:--------------------------
docs/teaching/Networking-With-Xinu.rst:.. list-table::
docs/teaching/Networking-With-Xinu.rst:    :header-rows: 1
docs/teaching/Networking-With-Xinu.rst:    * - Week
docs/teaching/Networking-With-Xinu.rst:      - Topics
docs/teaching/Networking-With-Xinu.rst:      - Assignments
docs/teaching/Networking-With-Xinu.rst:    * - 01
docs/teaching/Networking-With-Xinu.rst:      - History of networking and the Internet & specializations of net-centric computing
docs/teaching/Networking-With-Xinu.rst:      - :doc:`Networking Standards <assignments/Networking-Standards>`
docs/teaching/Networking-With-Xinu.rst:    * - 02
docs/teaching/Networking-With-Xinu.rst:      - Networking standards & 7-layer ISO model
docs/teaching/Networking-With-Xinu.rst:      - :doc:`Packet Demultiplexing <assignments/Packet-Demultiplexing>`
docs/teaching/Networking-With-Xinu.rst:    * - 03
docs/teaching/Networking-With-Xinu.rst:      - Ethernet & Address Resolution Protocol
docs/teaching/Networking-With-Xinu.rst:      - :doc:`Implementing ARP <assignments/ARP>`
docs/teaching/Networking-With-Xinu.rst:    * - 04
docs/teaching/Networking-With-Xinu.rst:      - Internet Protocol
docs/teaching/Networking-With-Xinu.rst:      - :doc:`Implementing IP & ICMP <assignments/IP-ICMP>`
docs/teaching/Networking-With-Xinu.rst:    * - 05
docs/teaching/Networking-With-Xinu.rst:      - Internet Protocol and Internet Control Message Protocol
docs/teaching/Networking-With-Xinu.rst:      -
docs/teaching/Networking-With-Xinu.rst:    * - 06
docs/teaching/Networking-With-Xinu.rst:      - Internet Packet Traversal, Security Concerns for IP & ARP
docs/teaching/Networking-With-Xinu.rst:      - :doc:`IP, ICMP, and ARP Applications <assignments/IP-ICMP-ARP-Applications>`
docs/teaching/Networking-With-Xinu.rst:    * - 07
docs/teaching/Networking-With-Xinu.rst:      - Datagrams - UDP
docs/teaching/Networking-With-Xinu.rst:      - :doc:`UDP Development and Implementation <assignments/UDP-Implementation>`
docs/teaching/Networking-With-Xinu.rst:    * - 08
docs/teaching/Networking-With-Xinu.rst:      - Datagrams - UDP, Dynamic Host Configuration Protocol
docs/teaching/Networking-With-Xinu.rst:      -
docs/teaching/Networking-With-Xinu.rst:    * - 09
docs/teaching/Networking-With-Xinu.rst:      - Dynamic Host Configuration Protocol
docs/teaching/Networking-With-Xinu.rst:      - :doc:`DHCP Development and Implementation <assignments/DHCP-Implementation>`
docs/teaching/Networking-With-Xinu.rst:    * - 10
docs/teaching/Networking-With-Xinu.rst:      - Streams - TCP
docs/teaching/Networking-With-Xinu.rst:      -
docs/teaching/Networking-With-Xinu.rst:    * - 11
docs/teaching/Networking-With-Xinu.rst:      - Security Concerns for UDP and TCP
docs/teaching/Networking-With-Xinu.rst:      - :doc:`TCP Development and Implementation <assignments/TCP-Implementation>`
docs/teaching/Networking-With-Xinu.rst:    * - 12
docs/teaching/Networking-With-Xinu.rst:      - Interaction Protocols for Networked Devices
docs/teaching/Networking-With-Xinu.rst:      -
docs/teaching/Networking-With-Xinu.rst:    * - 13
docs/teaching/Networking-With-Xinu.rst:      - Wireless Networking
docs/teaching/Networking-With-Xinu.rst:      -
docs/teaching/Networking-With-Xinu.rst:    * - 14
docs/teaching/Networking-With-Xinu.rst:      - Network Based Application Development
docs/teaching/Networking-With-Xinu.rst:      - :doc:`Network Based Applications <assignments/Networking-Applications>`
docs/teaching/Networking-With-Xinu.rst:    * - 15
docs/teaching/Networking-With-Xinu.rst:      - Networking Future
docs/teaching/Networking-With-Xinu.rst:      -
docs/teaching/Networking-With-Xinu.rst:non-implemented protocols. The student should also be able to understand
docs/teaching/Networking-With-Xinu.rst:of the networking architecture the student should be able to pin-point
docs/teaching/Networking-With-Xinu.rst:-  Currently this course structure has no suggested books.
docs/teaching/Networking-With-Xinu.rst:----------
docs/teaching/Networking-With-Xinu.rst:----------------
docs/teaching/Networking-With-Xinu.rst:This work funded in part by NSF grant DUE-CCLI-0737476.
docs/teaching/Student-Built-Xinu.rst:--------
docs/teaching/Student-Built-Xinu.rst:---------------
docs/teaching/Student-Built-Xinu.rst:-  Overview of operating systems
docs/teaching/Student-Built-Xinu.rst:-  Operating system principles
docs/teaching/Student-Built-Xinu.rst:-  Concurrency
docs/teaching/Student-Built-Xinu.rst:-  Scheduling and dispatch
docs/teaching/Student-Built-Xinu.rst:-  Memory management
docs/teaching/Student-Built-Xinu.rst:-  Device management
docs/teaching/Student-Built-Xinu.rst:-  Security and protection
docs/teaching/Student-Built-Xinu.rst:-  File systems
docs/teaching/Student-Built-Xinu.rst:-  Evaluating system performance
docs/teaching/Student-Built-Xinu.rst:-  Discuss the history of operating systems.
docs/teaching/Student-Built-Xinu.rst:-  Overview of the general and specific purpose of an operating system.
docs/teaching/Student-Built-Xinu.rst:-  Understanding concurrency and state flow diagrams.
docs/teaching/Student-Built-Xinu.rst:-  Understanding deadlock and starvation.
docs/teaching/Student-Built-Xinu.rst:-  Ability to decipher between scheduling algorithms.
docs/teaching/Student-Built-Xinu.rst:-  Understanding the use of memory and virtual memory.
docs/teaching/Student-Built-Xinu.rst:-  Characteristics of serial and parallel devices.
docs/teaching/Student-Built-Xinu.rst:-  Deciphering the concepts behind various file systems
docs/teaching/Student-Built-Xinu.rst:-  Understanding the necessity of security and locating potential system
docs/teaching/Student-Built-Xinu.rst:--------------------------
docs/teaching/Student-Built-Xinu.rst:.. list-table::
docs/teaching/Student-Built-Xinu.rst:   :header-rows: 1
docs/teaching/Student-Built-Xinu.rst:   * - Week
docs/teaching/Student-Built-Xinu.rst:     - Topics
docs/teaching/Student-Built-Xinu.rst:     - Assignments Track One
docs/teaching/Student-Built-Xinu.rst:     - Assignments Track Two
docs/teaching/Student-Built-Xinu.rst:     - Assignments Track Three
docs/teaching/Student-Built-Xinu.rst:   * - 01
docs/teaching/Student-Built-Xinu.rst:     - C (basics) and OS Structures, Processes
docs/teaching/Student-Built-Xinu.rst:     - :doc:`C Basics    <assignments/C-Basics>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`C Basics    <assignments/C-Basics>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`C Basics    <assignments/C-Basics>`
docs/teaching/Student-Built-Xinu.rst:   * - 02
docs/teaching/Student-Built-Xinu.rst:     - C (functions, control flow) and Processes
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:   * - 03
docs/teaching/Student-Built-Xinu.rst:     - C (pointers, arrays, structs) and Threads
docs/teaching/Student-Built-Xinu.rst:     - :doc:`C Structs and Pointers <assignments/C-Structs-and-Pointers>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`C Structs and Pointers <assignments/C-Structs-and-Pointers>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`C Structs and Pointers <assignments/C-Structs-and-Pointers>`
docs/teaching/Student-Built-Xinu.rst:   * - 04
docs/teaching/Student-Built-Xinu.rst:     - CPU Scheduling
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Synchronous Serial Driver <assignments/Synchronous-Serial-Driver>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Synchronous Serial Driver <assignments/Synchronous-Serial-Driver>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`SCC Serial Communication`
docs/teaching/Student-Built-Xinu.rst:   * - 05
docs/teaching/Student-Built-Xinu.rst:     - CPU Scheduling
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:   * - 06
docs/teaching/Student-Built-Xinu.rst:     - Process Synchronization
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Context Switch and Non-Preemptive Scheduling
docs/teaching/Student-Built-Xinu.rst:       <assignments/Context-Switch-and-Non-Preemptive-Scheduling>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Context Switch and Non-Preemptive Scheduling
docs/teaching/Student-Built-Xinu.rst:       <assignments/Context-Switch-and-Non-Preemptive-Scheduling>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Context Switch and Non-Preemptive Scheduling
docs/teaching/Student-Built-Xinu.rst:       <assignments/Context-Switch-and-Non-Preemptive-Scheduling>`
docs/teaching/Student-Built-Xinu.rst:   * - 07
docs/teaching/Student-Built-Xinu.rst:     - Deadlocks
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Priority Scheduling and Process Termination
docs/teaching/Student-Built-Xinu.rst:       <assignments/Priority-Scheduling-and-Process-Termination>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Priority Scheduling & Preemption
docs/teaching/Student-Built-Xinu.rst:       <assignments/Priority-Scheduling-and-Preemption>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Priority Scheduling & Preemption
docs/teaching/Student-Built-Xinu.rst:       <assignments/Priority-Scheduling-and-Preemption>`
docs/teaching/Student-Built-Xinu.rst:   * - 08
docs/teaching/Student-Built-Xinu.rst:     - Main Memory and Virtual Memory
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:   * - 09
docs/teaching/Student-Built-Xinu.rst:     - File System Interface
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Preemption & Synchronization
docs/teaching/Student-Built-Xinu.rst:       <assignments/Preemption-and-Synchronization>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Interprocess Communication
docs/teaching/Student-Built-Xinu.rst:       <assignments/Synchronization-and-Interprocess-Communication>`
docs/teaching/Student-Built-Xinu.rst:       or :doc:`LL/SC <assignments/LL-SC>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Interprocess Communication
docs/teaching/Student-Built-Xinu.rst:       <assignments/Synchronization-and-Interprocess-Communication>`
docs/teaching/Student-Built-Xinu.rst:   * - 10
docs/teaching/Student-Built-Xinu.rst:     - File System Implementation
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:   * - 11
docs/teaching/Student-Built-Xinu.rst:     - Mass-Storage Structure
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Delta Queues <assignments/Delta-Queues>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Delta Queues <assignments/Delta-Queues>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Delta Queues <assignments/Delta-Queues>`
docs/teaching/Student-Built-Xinu.rst:   * - 12
docs/teaching/Student-Built-Xinu.rst:     - I/O Systems
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Heap Memory <assignments/Heap-Memory>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Heap Memory <assignments/Heap-Memory>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Heap Memory <assignments/Heap-Memory>`
docs/teaching/Student-Built-Xinu.rst:   * - 13
docs/teaching/Student-Built-Xinu.rst:     - Protection, Security and Distributed System Structures
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Asynchronous Device Driver <assignments/Asynchronous-Device-Driver>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Ultra-Tiny File System <assignments/Ultra-Tiny-File-System>`
docs/teaching/Student-Built-Xinu.rst:     - Parallel Execution Speedup
docs/teaching/Student-Built-Xinu.rst:   * - 14
docs/teaching/Student-Built-Xinu.rst:     - Distributed System Structures
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:     -
docs/teaching/Student-Built-Xinu.rst:   * - 15
docs/teaching/Student-Built-Xinu.rst:     - Distributed File Systems
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Ultra-Tiny File System <assignments/Ultra-Tiny-File-System>`
docs/teaching/Student-Built-Xinu.rst:     - :doc:`Basic Networking - Ping <assignments/Basic-Networking---Ping>`
docs/teaching/Student-Built-Xinu.rst:     - Inter-core Message Passing
docs/teaching/Student-Built-Xinu.rst:-  `Abraham Silberschatz, Peter Baer Galvin, and Greg Gagne, Operating
docs/teaching/Student-Built-Xinu.rst:   #0-471-69466-5. <http://www.os-book.com/>`__
docs/teaching/Student-Built-Xinu.rst:-  `Brian W. Kernighan and Dennis M. Richie, The C Programming Language,
docs/teaching/Student-Built-Xinu.rst:   Prentice-Hall, 1978. <http://netlib.bell-labs.com/cm/cs/cbook/>`__
docs/teaching/Student-Built-Xinu.rst:----------
docs/teaching/Student-Built-Xinu.rst:----------------
docs/teaching/Student-Built-Xinu.rst:This work funded in part by NSF grant DUE-CCLI-0737476.
docs/teaching/Student-Extended-Xinu.rst:--------
docs/teaching/Student-Extended-Xinu.rst:---------------
docs/teaching/Student-Extended-Xinu.rst:-  Overview of operating systems
docs/teaching/Student-Extended-Xinu.rst:-  Operating system principles
docs/teaching/Student-Extended-Xinu.rst:-  Concurrency
docs/teaching/Student-Extended-Xinu.rst:-  Scheduling and dispatch
docs/teaching/Student-Extended-Xinu.rst:-  Memory management
docs/teaching/Student-Extended-Xinu.rst:-  Device management
docs/teaching/Student-Extended-Xinu.rst:-  Security and protection
docs/teaching/Student-Extended-Xinu.rst:-  File systems
docs/teaching/Student-Extended-Xinu.rst:-  Evaluating system performance
docs/teaching/Student-Extended-Xinu.rst:-  Intimate knowledge of embedded devices.
docs/teaching/Student-Extended-Xinu.rst:-  Overview of the general and specific purpose of an operating system.
docs/teaching/Student-Extended-Xinu.rst:-  Understanding concurrency and state flow diagrams.
docs/teaching/Student-Extended-Xinu.rst:-  Understanding deadlock and starvation.
docs/teaching/Student-Extended-Xinu.rst:-  Understanding the use of memory and virtual memory.
docs/teaching/Student-Extended-Xinu.rst:-  Characteristics of serial and parallel devices.
docs/teaching/Student-Extended-Xinu.rst:--------------------------
docs/teaching/Student-Extended-Xinu.rst:.. list-table::
docs/teaching/Student-Extended-Xinu.rst:   :header-rows: 1
docs/teaching/Student-Extended-Xinu.rst:   * - Week
docs/teaching/Student-Extended-Xinu.rst:     - Topics
docs/teaching/Student-Extended-Xinu.rst:     - Assignments
docs/teaching/Student-Extended-Xinu.rst:   * - 01
docs/teaching/Student-Extended-Xinu.rst:     - C (basics) and OS Structures, Processes
docs/teaching/Student-Extended-Xinu.rst:     - Extending Xinu #1
docs/teaching/Student-Extended-Xinu.rst:   * - 02
docs/teaching/Student-Extended-Xinu.rst:     - C (functions, control flow) and Processes
docs/teaching/Student-Extended-Xinu.rst:     -
docs/teaching/Student-Extended-Xinu.rst:   * - 03
docs/teaching/Student-Extended-Xinu.rst:     - C (pointers, arrays, structs) and Threads
docs/teaching/Student-Extended-Xinu.rst:     -
docs/teaching/Student-Extended-Xinu.rst:   * - 04
docs/teaching/Student-Extended-Xinu.rst:     - CPU Scheduling
docs/teaching/Student-Extended-Xinu.rst:     - Extending Xinu #2
docs/teaching/Student-Extended-Xinu.rst:   * - 05
docs/teaching/Student-Extended-Xinu.rst:     - CPU Scheduling
docs/teaching/Student-Extended-Xinu.rst:     -
docs/teaching/Student-Extended-Xinu.rst:   * - 06
docs/teaching/Student-Extended-Xinu.rst:     - Process Synchronization
docs/teaching/Student-Extended-Xinu.rst:     -
docs/teaching/Student-Extended-Xinu.rst:   * - 07
docs/teaching/Student-Extended-Xinu.rst:     - Deadlocks
docs/teaching/Student-Extended-Xinu.rst:     -
docs/teaching/Student-Extended-Xinu.rst:   * - 08
docs/teaching/Student-Extended-Xinu.rst:     - Main Memory and Virtual Memory
docs/teaching/Student-Extended-Xinu.rst:     - Extending Xinu #3
docs/teaching/Student-Extended-Xinu.rst:   * - 09
docs/teaching/Student-Extended-Xinu.rst:     - File System Interface
docs/teaching/Student-Extended-Xinu.rst:     -
docs/teaching/Student-Extended-Xinu.rst:   * - 10
docs/teaching/Student-Extended-Xinu.rst:     - File System Implementation
docs/teaching/Student-Extended-Xinu.rst:     -
docs/teaching/Student-Extended-Xinu.rst:   * - 11
docs/teaching/Student-Extended-Xinu.rst:     - Mass-Storage Structure
docs/teaching/Student-Extended-Xinu.rst:     -
docs/teaching/Student-Extended-Xinu.rst:   * - 12
docs/teaching/Student-Extended-Xinu.rst:     - I/O Systems
docs/teaching/Student-Extended-Xinu.rst:     - Extending Xinu #4
docs/teaching/Student-Extended-Xinu.rst:   * - 13
docs/teaching/Student-Extended-Xinu.rst:     - Protection, Security and Distributed System Structures
docs/teaching/Student-Extended-Xinu.rst:     -
docs/teaching/Student-Extended-Xinu.rst:   * - 14
docs/teaching/Student-Extended-Xinu.rst:     - Distributed System Structures
docs/teaching/Student-Extended-Xinu.rst:     -
docs/teaching/Student-Extended-Xinu.rst:   * - 15
docs/teaching/Student-Extended-Xinu.rst:     - Distributed File Systems
docs/teaching/Student-Extended-Xinu.rst:     -
docs/teaching/Student-Extended-Xinu.rst:-  There are no suggested books for this course outline.
docs/teaching/Student-Extended-Xinu.rst:----------
docs/teaching/Student-Extended-Xinu.rst:----------------
docs/teaching/Student-Extended-Xinu.rst:This work funded in part by NSF grant DUE-CCLI-0737476.
docs/teaching/Xinu-Helper-Class.rst:.. code-block:: java
docs/teaching/assignments/ARP.rst:    --David C. Plummer [#]_
docs/teaching/assignments/ARP.rst:--------
docs/teaching/assignments/ARP.rst:This assignment is part of the :doc:`/teaching/Networking-With-Xinu` track for
docs/teaching/assignments/ARP.rst:-----------
docs/teaching/assignments/ARP.rst:A new tar-ball is provided with a solution to the previous assignment.
docs/teaching/assignments/ARP.rst:---------------------------
docs/teaching/assignments/ARP.rst:-------------------------
docs/teaching/assignments/ARP.rst:-  add and remove ARP table entries
docs/teaching/assignments/ARP.rst:-  send, receive and process ARP requests
docs/teaching/assignments/ARP.rst:-  have ARP entries time out and be removed
docs/teaching/assignments/ARP.rst:-  lookup MAC address from table (given an IP) and return it to help
docs/teaching/assignments/ARP.rst:-------------------------
docs/teaching/assignments/ARP.rst:-  shell integration: add an **arp** command to the shell
docs/teaching/assignments/ARP.rst:   -  options for: adding entry, removing entry, sending request and
docs/teaching/assignments/ARP.rst:to run one or more tests on your implementation at run-time. Optional
docs/teaching/assignments/ARP.rst:----------------
docs/teaching/assignments/ARP.rst:--------------------
docs/teaching/assignments/ARP.rst:- :rfc:`826`
docs/teaching/assignments/ARP.rst:- :wikipedia:`Address Resolution Protocol`
docs/teaching/assignments/ARP.rst:-----
docs/teaching/assignments/Asynchronous-Device-Driver.rst::doc:`/teaching/Student-Built-Xinu` track for professors that are
docs/teaching/assignments/Asynchronous-Device-Driver.rst:-----------
docs/teaching/assignments/Asynchronous-Device-Driver.rst: cp -R
docs/teaching/assignments/Asynchronous-Device-Driver.rst:--------------------
docs/teaching/assignments/Asynchronous-Device-Driver.rst:-------------
docs/teaching/assignments/Asynchronous-Device-Driver.rst:with device-specific functions using standard names like ``open()`` and
docs/teaching/assignments/Asynchronous-Device-Driver.rst:few of the high-level device functions. They are very short, and almost
docs/teaching/assignments/Asynchronous-Device-Driver.rst:---------------------------
docs/teaching/assignments/Asynchronous-Device-Driver.rst:for an interrupt-driven UART. The difference between the existing
docs/teaching/assignments/Asynchronous-Device-Driver.rst:address of its memory-mapped I/O region is noted in the master device
docs/teaching/assignments/Asynchronous-Device-Driver.rst:user-level processes, functions such as ``ttyRead`` and ``ttyWrite``. As
docs/teaching/assignments/Asynchronous-Device-Driver.rst:-------
docs/teaching/assignments/Asynchronous-Device-Driver.rst:port available via the xinu-console system. When running
docs/teaching/assignments/Asynchronous-Device-Driver.rst:``mips-console`` normally, note the name of the backend you are
docs/teaching/assignments/Asynchronous-Device-Driver.rst:``xinu-console name2`` to gain access to the second serial port for
docs/teaching/assignments/Asynchronous-Device-Driver.rst:backend "name." The xinu-console reservation system tracks these two
docs/teaching/assignments/Asynchronous-Device-Driver.rst:The command "``xinu-status``\ " will list the users on each backend, and
docs/teaching/assignments/Asynchronous-Device-Driver.rst:"``xinu-status -c uart``\ " will list the users on each backend's second
docs/teaching/assignments/Basic-Networking---Ping.rst:part of the :doc:`/teaching/Student-Built-Xinu` track for professors that
docs/teaching/assignments/Basic-Networking---Ping.rst:-----------
docs/teaching/assignments/Basic-Networking---Ping.rst: cp -R
docs/teaching/assignments/Basic-Networking---Ping.rst:--------------
docs/teaching/assignments/Basic-Networking---Ping.rst:With the addition of a full-featured TTY driver in the previous
docs/teaching/assignments/Basic-Networking---Ping.rst:assignment, we can now add the command-line Xinu user interface, the
docs/teaching/assignments/Basic-Networking---Ping.rst:---------------
docs/teaching/assignments/Basic-Networking---Ping.rst:This project tarball equips your Xinu kernel with a block-oriented,
docs/teaching/assignments/Basic-Networking---Ping.rst:asynchronous ethernet driver for the router's built-in BCM4713 network
docs/teaching/assignments/Basic-Networking---Ping.rst:---------------
docs/teaching/assignments/Basic-Networking---Ping.rst:``network/snoop.c``, which will attempt to provide human-readable
docs/teaching/assignments/Basic-Networking---Ping.rst:----------------------
docs/teaching/assignments/Basic-Networking---Ping.rst:to the simplified nature of packet de-multiplexing in our current
docs/teaching/assignments/Basic-Networking---Ping.rst:a single command-line argument consisting of a destination IP address in
docs/teaching/assignments/Basic-Networking---Ping.rst:-  generate a sequence of 20 (``MAX_REQUESTS`` in ``include/network.h``)
docs/teaching/assignments/Basic-Networking---Ping.rst:-  watch for ping replies from the target machine;
docs/teaching/assignments/Basic-Networking---Ping.rst:-  print out replies received (see the ``icmp_reqreply`` function in
docs/teaching/assignments/Basic-Networking---Ping.rst:-  print out a summary of results.
docs/teaching/assignments/Basic-Networking---Ping.rst:Zardoz, the Xinu Network Gateway.  The gateway's MAC address is hard-coded in
docs/teaching/assignments/Basic-Networking---Ping.rst:---------
docs/teaching/assignments/Basic-Networking---Ping.rst:- :wikipedia:`Wikipedia: Ping <Ping>`
docs/teaching/assignments/Basic-Networking---Ping.rst:- :rfc:`RFC 792 - Internet Control Message Protocol <792>`
docs/teaching/assignments/Basic-Networking---Ping.rst:- :wikipedia:`Wikipedia: Internet Control Message Protocol (ICMP) <Internet_Control_Message_Protocol>`
docs/teaching/assignments/C-Basics.rst:This assignment is part of the :doc:`/teaching/Student-Built-Xinu` track for
docs/teaching/assignments/C-Basics.rst:The Multi-Base Calculator
docs/teaching/assignments/C-Basics.rst:-------------------------
docs/teaching/assignments/C-Basics.rst:-  Write a calculator program that reads in expressions consisting of
docs/teaching/assignments/C-Basics.rst:   integers and the operators +, -, \*, /, %, ^ (exponentiation), &
docs/teaching/assignments/C-Basics.rst:   shift), and prints the results when evaluated in simple left-to-right
docs/teaching/assignments/C-Basics.rst:-  Your calculator should understand positive integers in binary
docs/teaching/assignments/C-Basics.rst:   will be in decimal (base-10).
docs/teaching/assignments/C-Basics.rst:-  You should use the ``getchar()`` library function to read console input one
docs/teaching/assignments/C-Basics.rst:-----
docs/teaching/assignments/C-Basics.rst:-  This project can seem deceptively complex, but is quite tractable if
docs/teaching/assignments/C-Basics.rst:   We encourage the disciplined practice of test-driven development.
docs/teaching/assignments/C-Basics.rst:-  The internal data representation of the calculator values can be
docs/teaching/assignments/C-Basics.rst:-  Parsing input is always tedious, particularly when the input is not
docs/teaching/assignments/C-Basics.rst:   this assignment). In lieu of a parser-generator, consider drawing
docs/teaching/assignments/C-Basics.rst:-  Consider various operational and parsing errors that can take place.
docs/teaching/assignments/C-Basics.rst:-  Devise test cases to discover the expected behavior, and do your best
docs/teaching/assignments/C-Structs-and-Pointers.rst:---------------------------------------------------
docs/teaching/assignments/C-Structs-and-Pointers.rst:---------------------------------------------------
docs/teaching/assignments/C-Structs-and-Pointers.rst::doc:`/teaching/Student-Built-Xinu` track for professors that are :doc:`teaching
docs/teaching/assignments/C-Structs-and-Pointers.rst:-------
docs/teaching/assignments/C-Structs-and-Pointers.rst:-  Write a C program that reads in an arbitrarily long sequence of
docs/teaching/assignments/C-Structs-and-Pointers.rst:-  Your program should understand positive integers in binary (starting
docs/teaching/assignments/C-Structs-and-Pointers.rst:-  Your program should ignore any amount of white space between
docs/teaching/assignments/C-Structs-and-Pointers.rst:-  To store an arbitrary list of integers, your program will need to
docs/teaching/assignments/C-Structs-and-Pointers.rst:- `Billionrandom`_ is a random number generator that takes a single
docs/teaching/assignments/C-Structs-and-Pointers.rst:  command-line parameter for the number of integers desired, and then
docs/teaching/assignments/C-Structs-and-Pointers.rst:-----
docs/teaching/assignments/C-Structs-and-Pointers.rst:-  There are a variety of approaches for storing an arbitrarily long
docs/teaching/assignments/C-Structs-and-Pointers.rst:   blocks. This is an excellent balance in efficiency -- if your block
docs/teaching/assignments/C-Structs-and-Pointers.rst:-  This project is inherently dangerous; please exercise both great care
docs/teaching/assignments/C-Structs-and-Pointers.rst:   -  list of DO NOTs for this project:
docs/teaching/assignments/C-Structs-and-Pointers.rst:      -  DO NOT run your program with a large test size on any other
docs/teaching/assignments/C-Structs-and-Pointers.rst:      -  DO NOT pipe the output of billionrandom or your program to a
docs/teaching/assignments/C-Structs-and-Pointers.rst:      -  DO NOT run large test cases when it is apparent that a bunch of
docs/teaching/assignments/C-Structs-and-Pointers.rst:   -  list of DOs for this project:
docs/teaching/assignments/C-Structs-and-Pointers.rst:      -  DO check your dynamic allocation code by adjusting your block
docs/teaching/assignments/C-Structs-and-Pointers.rst:      -  DO check your ``malloc()`` error handling by adjusting your block
docs/teaching/assignments/C-Structs-and-Pointers.rst:      -  DO run your program with large test input (more than a few
docs/teaching/assignments/C-Structs-and-Pointers.rst:         properly -- so that you only have to do it once.
docs/teaching/assignments/C-Structs-and-Pointers.rst:-------------
docs/teaching/assignments/C-Structs-and-Pointers.rst:          if (('-' == argv[1][0])
docs/teaching/assignments/C-Structs-and-Pointers.rst:          e = e * 10 + *val - '0';
docs/teaching/assignments/Context-Switch-and-Non-Preemptive-Scheduling.rst:Assignment: Context Switch and Non-Preemptive Scheduling
docs/teaching/assignments/Context-Switch-and-Non-Preemptive-Scheduling.rst:system work.  This assignment is part of the :doc:`/teaching/Student-Built-Xinu`
docs/teaching/assignments/Context-Switch-and-Non-Preemptive-Scheduling.rst:-----------
docs/teaching/assignments/Context-Switch-and-Non-Preemptive-Scheduling.rst:--------------
docs/teaching/assignments/Context-Switch-and-Non-Preemptive-Scheduling.rst:----------------------
docs/teaching/assignments/Context-Switch-and-Non-Preemptive-Scheduling.rst:not modeled well in higher-level languages. If you have not worked in
docs/teaching/assignments/Context-Switch-and-Non-Preemptive-Scheduling.rst:available online. Despite its low-level nature, a context switch does
docs/teaching/assignments/Context-Switch-and-Non-Preemptive-Scheduling.rst:------
docs/teaching/assignments/Context-Switch-and-Non-Preemptive-Scheduling.rst:-------
docs/teaching/assignments/Context-Switch-and-Non-Preemptive-Scheduling.rst:-  Processes can be passed an arbitrary number of parameters upon
docs/teaching/assignments/Context-Switch-and-Non-Preemptive-Scheduling.rst:-  Processes should terminate cleanly upon exit;
docs/teaching/assignments/Context-Switch-and-Non-Preemptive-Scheduling.rst:-  Stack pointers and activation records should align properly and have
docs/teaching/assignments/DHCP-Implementation.rst:--------
docs/teaching/assignments/DHCP-Implementation.rst:This assignment is part of the :doc:`/teaching/Networking-With-Xinu` track for
docs/teaching/assignments/DHCP-Implementation.rst:A new tar-ball is provided with a solution to the previous assignment.
docs/teaching/assignments/DHCP-Implementation.rst:-----------------------------------
docs/teaching/assignments/DHCP-Implementation.rst:-  implement a functional DHCP client within Embedded Xinu
docs/teaching/assignments/DHCP-Implementation.rst:----------------
docs/teaching/assignments/DHCP-Implementation.rst:--------------------
docs/teaching/assignments/DHCP-Implementation.rst:- :rfc:`2131`
docs/teaching/assignments/DHCP-Implementation.rst:- :wikipedia:`Wikipedia - Dynamic Host Configuration Protocol <Dynamic Host Configuration Protocol>`
docs/teaching/assignments/Delta-Queues.rst:assignment is part of the :doc:`/teaching/Student-Built-Xinu` track for
docs/teaching/assignments/Delta-Queues.rst:-----------
docs/teaching/assignments/Delta-Queues.rst: cp -R
docs/teaching/assignments/Delta-Queues.rst:-----
docs/teaching/assignments/Delta-Queues.rst:-------
docs/teaching/assignments/Delta-Queues.rst:-  Checking your delta queue insert function with a variety of
docs/teaching/assignments/Delta-Queues.rst:-  Checking your sleeping and waking functions independently and in
docs/teaching/assignments/Heap-Memory.rst:is part of the :doc:`/teaching/Student-Built-Xinu` track for professors that are
docs/teaching/assignments/Heap-Memory.rst:-----------
docs/teaching/assignments/Heap-Memory.rst:First, make a fresh copy of your work thus far. cp -R Untar the new
docs/teaching/assignments/Heap-Memory.rst:------------------
docs/teaching/assignments/Heap-Memory.rst:assignment -- get everything else working first.)
docs/teaching/assignments/Heap-Memory.rst:-------
docs/teaching/assignments/Heap-Memory.rst:-  Verifying that your ``getmem()`` and ``freemem()`` functions operate
docs/teaching/assignments/Heap-Memory.rst:-  Checking your memory free list under a wide variety of conditions; if
docs/teaching/assignments/Heap-Memory.rst:-  Allocating and freeing as much memory as possible, (How can you tell
docs/teaching/assignments/Heap-Memory.rst:-  Verifying that your ``freemem()`` compaction works.
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:--------
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:This assignment is part of the :doc:`/teaching/Networking-With-Xinu` track for
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:A new tar-ball is provided with a solution to the previous assignment.
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:--------------
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-------------------------
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-  **arp** prints out the arp table or performs the modification specified
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-  **ping** uses the ICMP protocol's mandatory ECHO\_REQUEST datagram,
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-  **snoop** displays packet information for incoming and outgoing network
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-  **arp**
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:   -  options for: adding entry, removing entry, sending request and
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:   -  add help option that prints usage
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-  **ping**
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:   -  options for: count of pings to be sent and time to live of packets
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:   -  add help option that prints usage
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-  **snoop**
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:   -  option for: dumping a packet in hex
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:   -  add help option that prints usage
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-------------------------
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-  respond to received traceroute packets with the proper ICMP packet
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:to run one or more tests on your implementation at run-time. Optional
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:----------------
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:--------------------
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-  :RFC:`Ethernet Address Resolution Protocol - RFC <826>`
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-  :RFC:`Internet Protocol - RFC <791>`
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-  :RFC:`Internet Control Message Protocol - RFC <792>`
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-  :wikipedia:`Address Resolution Protocol - Wikipedia <Address Resolution Protocol>`
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-  :wikipedia:`Internet Protocol - Wikipedia <Internet Protocol>`
docs/teaching/assignments/IP-ICMP-ARP-Applications.rst:-  :wikipedia:`Internet Control Message Protocol - Wikipedia <Internet Control Message Protocol>`
docs/teaching/assignments/IP-ICMP.rst:--------
docs/teaching/assignments/IP-ICMP.rst:This assignment is part of the :doc:`/teaching/Networking-With-Xinu` track for
docs/teaching/assignments/IP-ICMP.rst:-----------
docs/teaching/assignments/IP-ICMP.rst:A new tar-ball is provided with a solution to the previous assignment.
docs/teaching/assignments/IP-ICMP.rst:-----------------
docs/teaching/assignments/IP-ICMP.rst:-  send and receive packets of with type IP
docs/teaching/assignments/IP-ICMP.rst:-  further demultiplex IP packets to find the underlying type
docs/teaching/assignments/IP-ICMP.rst:-  send and receive ICMP packets
docs/teaching/assignments/IP-ICMP.rst:-  reply to ICMP echo requests properly
docs/teaching/assignments/IP-ICMP.rst:-  shell integration: add a **ping** command to the shell (sending out
docs/teaching/assignments/IP-ICMP.rst:to run one or more tests on your implementation at run-time. Optional
docs/teaching/assignments/IP-ICMP.rst:----------------
docs/teaching/assignments/IP-ICMP.rst:--------------------
docs/teaching/assignments/IP-ICMP.rst:-  :RFC:`Internet Protocol - RFC <791>`
docs/teaching/assignments/IP-ICMP.rst:-  :RFC:`Internet Control Message Protocol - RFC <792>`
docs/teaching/assignments/IP-ICMP.rst:-  :wikipedia:`Internet Protocol - Wikipedia <Internet Protocol>`
docs/teaching/assignments/IP-ICMP.rst:-  :wikipedia:`Internet Control Message Protocol - Wikipedia <Internet Control Message Protocol>`
docs/teaching/assignments/Instruction-Selection.rst:--------
docs/teaching/assignments/Instruction-Selection.rst:-----
docs/teaching/assignments/LL-SC.rst:----------------------------------------------
docs/teaching/assignments/LL-SC.rst:assignment is part of the :doc:`/teaching/Student-Built-Xinu` track for
docs/teaching/assignments/LL-SC.rst:called ``login.pdf``, (with your login name,) in the top-level directory
docs/teaching/assignments/LL-SC.rst:of your xinu-hw6.
docs/teaching/assignments/LL-SC.rst:---------
docs/teaching/assignments/LL-SC.rst:-----------
docs/teaching/assignments/LL-SC.rst:  cp -R
docs/teaching/assignments/LL-SC.rst:----------
docs/teaching/assignments/LL-SC.rst:-------------------
docs/teaching/assignments/LL-SC.rst:consumers that communicate using a Bounded-Buffer. Your textbook
docs/teaching/assignments/LL-SC.rst:provides discussion of the Bounded-Buffer Problem beginning in
docs/teaching/assignments/LL-SC.rst:Programming Project 6.40 - Producer-Consumer Problem.
docs/teaching/assignments/LL-SC.rst:------------------------
docs/teaching/assignments/LL-SC.rst:Disabling all interrupts is an effective but heavy-handed approach for
docs/teaching/assignments/LL-SC.rst:providing mutual exclusion. Multicore systems and complex real-time
docs/teaching/assignments/LL-SC.rst:the MIPS LL/SC (load-linked and store-conditional) opcodes. Much more
docs/teaching/assignments/LL-SC.rst:using the bounded-waiting algorithm presented in Figure 6.8 of your
docs/teaching/assignments/LL-SC.rst:----------
docs/teaching/assignments/LL-SC.rst:   consumer(s)? Vice-versa?
docs/teaching/assignments/LL-SC.rst:For part two of the assignment, use your bounded-wait ``mutexAcquire()``
docs/teaching/assignments/LL-SC.rst:up ``kprintf()`` calls mid-line without additional disabling of
docs/teaching/assignments/LL-SC.rst:#. Can your bounded-wait mutex subsystem replace the semaphore subsystem
docs/teaching/assignments/LL-SC.rst:----------
docs/teaching/assignments/Networking-Applications.rst:--------
docs/teaching/assignments/Networking-Applications.rst:</teaching/Networking-With-Xinu>` track for professors that are :doc:`teaching
docs/teaching/assignments/Networking-Applications.rst:-----------
docs/teaching/assignments/Networking-Applications.rst:A new tar-ball is provided with a solution to the previous assignment.
docs/teaching/assignments/Networking-Applications.rst:--------------
docs/teaching/assignments/Networking-Applications.rst:**tcp-con** and **ftp-receive**.
docs/teaching/assignments/Networking-Applications.rst:-  **tcp-con** establishes a tcp connection with the provided IP address
docs/teaching/assignments/Networking-Applications.rst:-  **ftp-receive** uses a TCP/IP connection to transfer acquire a file
docs/teaching/assignments/Networking-Applications.rst:-  **tcp-con**
docs/teaching/assignments/Networking-Applications.rst:   -  options for: determine whether the connection establishment is
docs/teaching/assignments/Networking-Applications.rst:   -  add help option that prints usage
docs/teaching/assignments/Networking-Applications.rst:-  **ftp-receive**
docs/teaching/assignments/Networking-Applications.rst:   -  options for: determine whether to use passive or active connection
docs/teaching/assignments/Networking-Applications.rst:   -  add help option that prints usage
docs/teaching/assignments/Networking-Applications.rst:----------------
docs/teaching/assignments/Networking-Applications.rst:--------------------
docs/teaching/assignments/Networking-Applications.rst:-  :RFC:`Ethernet Address Resolution Protocol - RFC <826>`
docs/teaching/assignments/Networking-Applications.rst:-  :RFC:`Internet Protocol - RFC <791>`
docs/teaching/assignments/Networking-Applications.rst:-  :RFC:`Internet Control Message Protocol - RFC <792>`
docs/teaching/assignments/Networking-Applications.rst:-  :wikipedia:`Address Resolution Protocol - Wikipedia <Address Resolution Protocol>`
docs/teaching/assignments/Networking-Applications.rst:-  :wikipedia:`Internet Protocol - Wikipedia <Internet Protocol>`
docs/teaching/assignments/Networking-Applications.rst:-  :wikipedia:`Internet Control Message Protocol - Wikipedia <Internet Control Message Protocol>`
docs/teaching/assignments/Networking-Standards.rst:--------------
docs/teaching/assignments/Networking-Standards.rst: -- Andres S. Tannenbaum
docs/teaching/assignments/Networking-Standards.rst:</teaching/Networking-With-Xinu>` track for professors that are :doc:`teaching
docs/teaching/assignments/Networking-Standards.rst:----------------
docs/teaching/assignments/Networking-Standards.rst:-  Implementation of the assignment can vary
docs/teaching/assignments/Networking-Standards.rst:   -  Only reading
docs/teaching/assignments/Networking-Standards.rst:   -  Reading & Questions
docs/teaching/assignments/Networking-Standards.rst:   -  Reading & Quiz/Test
docs/teaching/assignments/Networking-Standards.rst:-  Upon completion of the assignment the student should know how to find
docs/teaching/assignments/Networking-Standards.rst:---------------------------------------------
docs/teaching/assignments/Networking-Standards.rst:-  :rfc:`Internet Official Protocol Standards - RFC 5000 <5000>`
docs/teaching/assignments/Networking-Standards.rst:-  :rfc:`Ethernet Address Resolution Protocol - RFC 826 <826>`
docs/teaching/assignments/Networking-Standards.rst:-  :rfc:`Internet Protocol - RFC 791 <791>`
docs/teaching/assignments/Networking-Standards.rst:-  :rfc:`Internet Control Message Protocol - RFC 792 <792>`
docs/teaching/assignments/Networking-Standards.rst:-  :rfc:`User Datagram Protocol - RFC 768 <768>`
docs/teaching/assignments/Networking-Standards.rst:-  :rfc:`Transmission Control Protocol - RFC 793 <793>`
docs/teaching/assignments/Networking-Standards.rst:-  :rfc:`Trivial File Transfer Protocol - RFC 1350 <1350>`
docs/teaching/assignments/Networking-Standards.rst:-  :rfc:`Dynamic Host Configuration Protocol - RFC 2131 <2131>`
docs/teaching/assignments/Packet-Demultiplexing.rst:--------
docs/teaching/assignments/Packet-Demultiplexing.rst:</teaching/Networking-With-Xinu>` track for professors that are :doc:`teaching
docs/teaching/assignments/Packet-Demultiplexing.rst:together into a single entity, typically called a "tar-ball." (So common
docs/teaching/assignments/Packet-Demultiplexing.rst:before modern standards for command-line options.
docs/teaching/assignments/Packet-Demultiplexing.rst:untars the files into your working directory, if the tar-ball was
docs/teaching/assignments/Packet-Demultiplexing.rst:While the **gcc** command-line options provide a great deal of flexibility
docs/teaching/assignments/Packet-Demultiplexing.rst:assignments. The Makefile is always human-readable, so feel free to open
docs/teaching/assignments/Packet-Demultiplexing.rst:-  Change directory into the top level produced by the tar-ball.
docs/teaching/assignments/Packet-Demultiplexing.rst:-  Change directory into the subdirectory "compile". This directory
docs/teaching/assignments/Packet-Demultiplexing.rst:-  Execute the the following command::
docs/teaching/assignments/Packet-Demultiplexing.rst:-  By standard convention, almost all Makefiles include a target called
docs/teaching/assignments/Packet-Demultiplexing.rst:   "clean" that removes everything except the source code. The tar-ball
docs/teaching/assignments/Packet-Demultiplexing.rst:-  Execute the the following command::
docs/teaching/assignments/Packet-Demultiplexing.rst:it there, we have a special utility called mips-console. Execute
docs/teaching/assignments/Packet-Demultiplexing.rst:mips-console in the compile directory where your xinu.boot file resides.
docs/teaching/assignments/Packet-Demultiplexing.rst:Mips-console will connect your terminal to the first available backend
docs/teaching/assignments/Packet-Demultiplexing.rst:  connection 'xinurouter', class 'mips', host 'xinuserver-hostname'
docs/teaching/assignments/Packet-Demultiplexing.rst:The most important thing to remember about mips-console is that it is
docs/teaching/assignments/Packet-Demultiplexing.rst:console on your backend machine. To get out of mips-console, hit
docs/teaching/assignments/Packet-Demultiplexing.rst:Control-Space, followed by the 'q' key.
docs/teaching/assignments/Packet-Demultiplexing.rst:---------------------
docs/teaching/assignments/Packet-Demultiplexing.rst:-  Implementation can vary based on how the professor intends to grade
docs/teaching/assignments/Packet-Demultiplexing.rst:   -  Have the students insert print outs of what type of packet is
docs/teaching/assignments/Packet-Demultiplexing.rst:   -  Give the students some portion of code so they can pass the packet
docs/teaching/assignments/Parser.rst:--------
docs/teaching/assignments/Parser.rst:-----
docs/teaching/assignments/Preemption-and-Synchronization.rst:assignment is part of the :doc:`/teaching/Student-Built-Xinu` track for
docs/teaching/assignments/Preemption-and-Synchronization.rst:different levels of priority and with both blocking and non-blocking
docs/teaching/assignments/Preemption-and-Synchronization.rst:-----------
docs/teaching/assignments/Preemption-and-Synchronization.rst:  cp -R
docs/teaching/assignments/Preemption-and-Synchronization.rst:----------
docs/teaching/assignments/Preemption-and-Synchronization.rst:``main-preempt.c``, and make sure that it works when copied over
docs/teaching/assignments/Preemption-and-Synchronization.rst:---------
docs/teaching/assignments/Preemption-and-Synchronization.rst:----------
docs/teaching/assignments/Preemption-and-Synchronization.rst:--------
docs/teaching/assignments/Preemption-and-Synchronization.rst:-  Create a main program that spawns multiple producer processes (each
docs/teaching/assignments/Preemption-and-Synchronization.rst:   ``system/README``.) Save this test case as ``system/main-q1.c``.
docs/teaching/assignments/Preemption-and-Synchronization.rst:-  Using the same test case as in the previous question, briefly adjust
docs/teaching/assignments/Preemption-and-Synchronization.rst:-  Create a test case ``system/main-q3.c`` in which the consumer
docs/teaching/assignments/Preemption-and-Synchronization.rst:-  In the comment blocks for ``system/signal.c``, you were directed to
docs/teaching/assignments/Preemption-and-Synchronization.rst:   time? (This is called non-blocking or non-yielding ``signal()``.)
docs/teaching/assignments/Preemption-and-Synchronization.rst:   Repeat the first three questions with non-blocking ``signal()``.
docs/teaching/assignments/Preemption-and-Synchronization.rst:-  One of the interesting things about the classic Producer/Consumer
docs/teaching/assignments/Preemption-and-Synchronization.rst:   variety of simple one-line swaps in either the producer code or the
docs/teaching/assignments/Preemption-and-Synchronization.rst:   ``system/main-q5.c``
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:This assignment is part of the :doc:`/teaching/Student-Built-Xinu` track for
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:-----------
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:    cp -R
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:-------------------
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:-  Add a priority field into PCB structure defined in
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:-  Add an effective priority field "``key``\ " into the process queue
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:-  Add priority parameter to ``create()``, and properly initialize the
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:-  Build a new function in ``system/prioritize.c`` to implement a
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:-  Modify the ``ready()`` and ``resched()`` functions to properly use
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:priority-order execution once your new scheduler is operational. You
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:--------------------
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:``TRUE``. Call your test case function main-starve, and put it in your
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:----------
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:working in your system? Create a main program called ``main-preempt``
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:-----
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:-  To submit your project, please run ``"make clean"`` in your compile
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:-  To complete this assignment, you will have made changes to several
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:-  Your professor may set up groups to allow easier collaboration
docs/teaching/assignments/Priority-Scheduling-and-Preemption.rst:-  When collaborating on a project in a shared directory, good software
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:This assignment is part of the :doc:`/teaching/Student-Built-Xinu` track for
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:-----------
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:    cp -R
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:-------------------
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:-  Add a priority field into PCB structure defined in
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:-  Add an effective priority field into the process queue structure
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:-  Add priority parameter to ``create()``, and properly initialize the
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:-  Complete the new function in ``system/insert.c`` to implement a
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:-  Modify the ``ready()`` and ``resched()`` functions to properly use
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:priority-order execution once your new scheduler is operational. You
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:--------------------
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:-----
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:-  To submit your project, please run ``"make clean"`` in your compile
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:-  To complete this assignment, you will have made changes to several
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:-  Your professor may set up groups to allow easier collaboration
docs/teaching/assignments/Priority-Scheduling-and-Process-Termination.rst:-  When collaborating on a project in a shared directory, good software
docs/teaching/assignments/Scanner.rst:--------
docs/teaching/assignments/Scanner.rst:-----
docs/teaching/assignments/Semantic-Analysis.rst:--------
docs/teaching/assignments/Semantic-Analysis.rst:-----
docs/teaching/assignments/Semantic-Analysis.rst:type-descriptor containing each of the method types in class
docs/teaching/assignments/Semantic-Analysis.rst::doc:`Xinu </teaching/Xinu-Helper-Class>`, and the type environment
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:   -- USPS Unofficial Slogan
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:assignment is part of the :doc:`/teaching/Student-Built-Xinu` track for
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:---------
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:-----------
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:    cp -R
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:----------
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:---------
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:--------
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:-  Create a simple ``main`` program, with function called
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:   ``main-hw6-q1``, that has multiple processes that use a mutex locking
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:   ``system/main-hw6-q1.c`` and should run properly when
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:   ``main-hw6-q1()`` instead of ``main()``.
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:-  Create another ``main`` program called ``main-hw6-q2()``, that uses
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:   should be saved as ``system/main-hw6-q2.c`` and should run properly
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:   ``main-hw6-q2()`` instead of ``main()``.
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:-  Give a situation in which mailboxes could be used to model a
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:   real-world problem; store your answer as Q3 in
docs/teaching/assignments/Synchronization-and-Interprocess-Communication.rst:-  Give a situation that will deadlock the system using your mailbox
docs/teaching/assignments/Synchronous-Serial-Driver.rst:--------
docs/teaching/assignments/Synchronous-Serial-Driver.rst::doc:`/teaching/Student-Built-Xinu` track for professors that are :doc:`teaching
docs/teaching/assignments/Synchronous-Serial-Driver.rst:-----------
docs/teaching/assignments/Synchronous-Serial-Driver.rst:"tar-ball." (So common is the use of **tar** that it has been verbed
docs/teaching/assignments/Synchronous-Serial-Driver.rst:came into existence before modern standards for command-line options.
docs/teaching/assignments/Synchronous-Serial-Driver.rst:untars the files into your working directory, if the tar-ball was
docs/teaching/assignments/Synchronous-Serial-Driver.rst:--------
docs/teaching/assignments/Synchronous-Serial-Driver.rst:While the gcc command-line options provide a great deal of flexibility
docs/teaching/assignments/Synchronous-Serial-Driver.rst:assignments. The Makefile is always human-readable, so feel free to open
docs/teaching/assignments/Synchronous-Serial-Driver.rst:-  Change directory into the top level produced by the tar-ball.
docs/teaching/assignments/Synchronous-Serial-Driver.rst:-  Change directory into the subdirectory "compile". This directory
docs/teaching/assignments/Synchronous-Serial-Driver.rst:-  Execute the the following command::
docs/teaching/assignments/Synchronous-Serial-Driver.rst:-  By standard convention, almost all Makefiles include a target called
docs/teaching/assignments/Synchronous-Serial-Driver.rst:   "clean" that removes everything except the source code. The tar-ball
docs/teaching/assignments/Synchronous-Serial-Driver.rst:-  Execute the the following command::
docs/teaching/assignments/Synchronous-Serial-Driver.rst:-------
docs/teaching/assignments/Synchronous-Serial-Driver.rst:it there, we have a special utility called mips-console. Execute
docs/teaching/assignments/Synchronous-Serial-Driver.rst:mips-console in the compile directory where your xinu.boot file resides.
docs/teaching/assignments/Synchronous-Serial-Driver.rst:Mips-console will connect your terminal to the first available backend
docs/teaching/assignments/Synchronous-Serial-Driver.rst:  connection 'xinurouter', class 'mips', host 'xinuserver-hostname'
docs/teaching/assignments/Synchronous-Serial-Driver.rst:The most important thing to remember about mips-console is that it is
docs/teaching/assignments/Synchronous-Serial-Driver.rst:console on your backend machine. To get out of mips-console, hit
docs/teaching/assignments/Synchronous-Serial-Driver.rst:Control-Space, followed by the 'q' key.
docs/teaching/assignments/Synchronous-Serial-Driver.rst:--------------------
docs/teaching/assignments/Synchronous-Serial-Driver.rst:The source tar-ball we are starting with contains only a few files for
docs/teaching/assignments/Synchronous-Serial-Driver.rst:-  ``compile/`` contains the compilation files for XINU.
docs/teaching/assignments/Synchronous-Serial-Driver.rst:-  ``include/`` contains all of our local .h header files used throughout
docs/teaching/assignments/Synchronous-Serial-Driver.rst:-  ``lib/`` contains a small library of standard C functions we can rely
docs/teaching/assignments/Synchronous-Serial-Driver.rst:   -- the UNIX system libraries are not available to our operating
docs/teaching/assignments/Synchronous-Serial-Driver.rst:-  ``loader/`` contains the files for the Mips Xinu boot loader, which
docs/teaching/assignments/Synchronous-Serial-Driver.rst:-------------------------
docs/teaching/assignments/Synchronous-Serial-Driver.rst:hardware. We will write the interrupt-driven, "asynchronous" version of
docs/teaching/assignments/Synchronous-Serial-Driver.rst:RS-232 serial port interface, like the one found on most modern PC's.
docs/teaching/assignments/Synchronous-Serial-Driver.rst:UART control and status registers are memory-mapped, starting with base
docs/teaching/assignments/Synchronous-Serial-Driver.rst:The file ``system/kprintf.c`` has the skeleton code for four I/O-related
docs/teaching/assignments/TCP-Implementation.rst:--------
docs/teaching/assignments/TCP-Implementation.rst:This assignment is part of the :doc:`/teaching/Networking-With-Xinu` track for
docs/teaching/assignments/TCP-Implementation.rst:-----------
docs/teaching/assignments/TCP-Implementation.rst:A new tar-ball is provided with a solution to the previous assignment.
docs/teaching/assignments/TCP-Implementation.rst:-----------------------------
docs/teaching/assignments/TCP-Implementation.rst:-  send and receive packets of with type TCP
docs/teaching/assignments/TCP-Implementation.rst:-  determine the status of a specific datagram device and place desired
docs/teaching/assignments/TCP-Implementation.rst:-  shell integration: add a **tcp-con** command to the shell (establishes
docs/teaching/assignments/TCP-Implementation.rst:to run one or more tests on your implementation at run-time. Optional
docs/teaching/assignments/TCP-Implementation.rst:----------------
docs/teaching/assignments/TCP-Implementation.rst:--------------------
docs/teaching/assignments/TCP-Implementation.rst:- :rfc:`Transmission Control Protocol - RFC 793 <793>`
docs/teaching/assignments/TCP-Implementation.rst:- :wikipedia:`Transmission Control Protocol - Wikipedia <Transmission Control Protocol>`
docs/teaching/assignments/Translation.rst:--------
docs/teaching/assignments/Translation.rst::doc:`Project 4 <Semantic-Analysis>` and converts it into an
docs/teaching/assignments/Translation.rst:-----
docs/teaching/assignments/Translation.rst:threading functions is self-explanatory, but also at this point we
docs/teaching/assignments/Translation.rst:arrays. In addition, if the compiler is to support Java-like runtime
docs/teaching/assignments/Translation.rst:First :doc:`monitors </teaching/Adding-Monitors-To-Xinu>` must be
docs/teaching/assignments/Translation.rst:``unlock()`` functions added to Xinu.  To achieve Java-like thread
docs/teaching/assignments/Translation.rst:------------------------
docs/teaching/assignments/UDP-Implementation.rst:--------
docs/teaching/assignments/UDP-Implementation.rst:This assignment is part of the :doc:`/teaching/Networking-With-Xinu` track for
docs/teaching/assignments/UDP-Implementation.rst:-----------
docs/teaching/assignments/UDP-Implementation.rst:A new tar-ball is provided with a solution to the previous assignment.
docs/teaching/assignments/UDP-Implementation.rst:----------------------
docs/teaching/assignments/UDP-Implementation.rst:-  send and receive packets of with type UDP
docs/teaching/assignments/UDP-Implementation.rst:-  determine the status of a specific datagram device and place desired
docs/teaching/assignments/UDP-Implementation.rst:-  shell integration: add a **traceroute** command to the shell (sending
docs/teaching/assignments/UDP-Implementation.rst:you to run one or more tests on your implementation at run-time.
docs/teaching/assignments/UDP-Implementation.rst:----------------
docs/teaching/assignments/UDP-Implementation.rst:--------------------
docs/teaching/assignments/UDP-Implementation.rst:- :rfc:`User Datagram Protocol - RFC 768 <768>`
docs/teaching/assignments/UDP-Implementation.rst:- :wikipedia:`User Datagram Protocol - Wiki Page <User Datagram Protocol>`
docs/teaching/assignments/Ultra-Tiny-File-System.rst:Assignment: Ultra-Tiny File System
docs/teaching/assignments/Ultra-Tiny-File-System.rst:part of the :doc:`/teaching/Student-Built-Xinu` track for professors that are
docs/teaching/assignments/Ultra-Tiny-File-System.rst:-----------
docs/teaching/assignments/Ultra-Tiny-File-System.rst:    cp -R
docs/teaching/assignments/Ultra-Tiny-File-System.rst:Non-blocking ttyRead()
docs/teaching/assignments/Ultra-Tiny-File-System.rst:----------------------
docs/teaching/assignments/Ultra-Tiny-File-System.rst:non-blocking read as an option to your TTY driver. Use the ``iflags``
docs/teaching/assignments/Ultra-Tiny-File-System.rst:---------------
docs/teaching/assignments/Ultra-Tiny-File-System.rst:over the second serial port) that speaks to a ``xinu-disk`` program
docs/teaching/assignments/Ultra-Tiny-File-System.rst:running on your computer. The ``xinu-disk`` process maps reading and
docs/teaching/assignments/Ultra-Tiny-File-System.rst:writing requests from the backend to a locally-stored disk file. In this
docs/teaching/assignments/Ultra-Tiny-File-System.rst:See below for additional details on the ``xinu-disk`` command.
docs/teaching/assignments/Ultra-Tiny-File-System.rst:---------------
docs/teaching/assignments/Ultra-Tiny-File-System.rst:-  A pointer to a list of free disk blocks,
docs/teaching/assignments/Ultra-Tiny-File-System.rst:-  A pointer to a master directory index,
docs/teaching/assignments/Ultra-Tiny-File-System.rst:-  Block size, disk size, etc., and
docs/teaching/assignments/Ultra-Tiny-File-System.rst:-  A magic number, so that it can tell the difference between a blank
docs/teaching/assignments/Ultra-Tiny-File-System.rst:-------
docs/teaching/assignments/Ultra-Tiny-File-System.rst:The command **xinu-disk** starts up a disk daemon on the local
docs/teaching/assignments/Ultra-Tiny-File-System.rst:``make xinu-disk`` in your ``compile/`` directory. For example, to
docs/teaching/assignments/Ultra-Tiny-File-System.rst:"foo.dat", I would run the command ``mips-console dask`` in one
docs/teaching/assignments/Ultra-Tiny-File-System.rst:terminal, and then execute ``./xinu-disk foo.dat dask2`` in a second
docs/teaching/assignments/Ultra-Tiny-File-System.rst:Xinu-disk's ability to synchronize with a "moving-target" backend is
docs/teaching/assignments/Ultra-Tiny-File-System.rst:somewhat rudimentary -- you may occasionally see the handshake fail upon
docs/teaching/assignments/Ultra-Tiny-File-System.rst:startup. Just close out the ``mips-console`` session normally, close the
docs/teaching/assignments/Ultra-Tiny-File-System.rst:``xinu-disk`` process with a "Control-C", and try again.
docs/teaching/assignments/Ultra-Tiny-File-System.rst:The command ``xinu-status`` will list the users on each backend, and
docs/teaching/assignments/Ultra-Tiny-File-System.rst:``xinu-status -c uart`` will list the users on each backend's second
docs/teaching/index.rst:------------------------
docs/teaching/index.rst:*Main article:* :doc:`Student-Built-Xinu`
docs/teaching/index.rst:*Main article:* :doc:`Student-Extended-Xinu`
docs/teaching/index.rst:----------
docs/teaching/index.rst:*Main article:* :doc:`Networking-With-Xinu`
docs/teaching/index.rst:---------
docs/teaching/index.rst:*Main article:* :doc:`Compiler-Construction-With-Embedded-Xinu`
docs/teaching/index.rst:-----------------------
docs/teaching/index.rst:---------
docs/teaching/index.rst:Mississippi (Ole Miss campus) shared ready-made curriculum resources
docs/teaching/index.rst:----------------
docs/teaching/index.rst:This work funded in part by NSF grant DUE-CCLI-0737476.
docs/xinusource.py:# See: http://sphinx-doc.org/extensions.html.  Also based partly on
docs/xinusource.py:SOURCE_URI = "https://github.com/xinu-os/xinu/tree/master/%s"
docs/xinusource.py:# See: http://docutils.sourceforge.net/docs/howto/rst-roles.html
docs/xinusource.py:# See: http://sphinx-doc.org/ext/appapi.html
include/arp.h:#define ARP_ADDR_SPA(arp)   (arp->hwalen)
include/arp.h:#define ARP_ADDR_DHA(arp)   (arp->hwalen + arp->pralen)
include/arp.h:#define ARP_ADDR_DPA(arp)   ((2 * arp->hwalen) + arp->pralen)
include/arp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/arp.h: * | Link-Level Header                                             |
include/arp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/arp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/arp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/arp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/bufpool.h: * isbadpool - check validity of reqested buffer pool id and state
include/bufpool.h:/** roundword - round byte sized request to word size
include/clock.h: * here because their implementations are platform-dependent.  */
include/compiler.h: * Compiler-specific definitions.
include/compiler.h: * Provide compiler warnings about bad printf()-like format strings.  */
include/compiler.h:#define STATIC_ASSERT(condition) ((void)sizeof(char[1 - 2*!(condition)]))
include/ctype.h:                        (unsigned char)(c) + ('A' - 'a') : (unsigned char)(c))
include/ctype.h:                            (unsigned char)(c) + ('a' - 'A') : (unsigned char)(c))
include/date.h:    int second;                 /* 0-59 */
include/date.h:    int minute;                 /* 0-59 */
include/date.h:    int hour;                   /* 0-23 */
include/date.h:    int monthday;               /* 1-31 */
include/date.h:    int month;                  /* 0 - Jan, ..., 11 - Dec */
include/date.h:    int weekday;                /* 0 - Sun, ..., 6 - Sat */
include/date.h:#define TZ_HST (-10)
include/date.h:#define TZ_AST (-9)
include/date.h:#define TZ_PST (-8)
include/date.h:#define TZ_MST (-7)
include/date.h:#define TZ_CST (-6)
include/date.h:#define TZ_EST (-5)
include/endianness.h: * Little-to-big and big-to-little endianness conversions.
include/endianness.h:/* Big-endian CPU  */
include/endianness.h:/* big endian to big endian:  no-op  */
include/endianness.h:/* Little-endian CPU  */
include/endianness.h:/* little endian to little endian:  no-op  */
include/ether.h:#define ETH_INVALID  (-1)       /**< Invalid data (virtual devices)     */
include/ether.h: * Do one-time initialization of an Ethernet device.  This performs
include/ethernet.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ethernet.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ethernet.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ethernet.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ethernet.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ethernet.h: * | Data (46 - 1500 octets)                                       |
include/ethernet.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/flash.h:    uint crc;                   /**< 32-bit CRC from flag_vers to EOF    */
include/flash.h:    uint flags_vers;             /**< 0-15 flags, 16-31 version           */
include/flash.h:/* put/get 8-bits commands for CFI */
include/flash.h:/* put/get 8-bits commands for Intel */
include/flash.h:/* put/get 8-bits commands for AMD */
include/flash.h:/* put/get 16-bits commands for Intel */
include/flash.h:/* put/get 16-bits commands for AMD */
include/flash.h:#define INTEL_RESUME   0xD0   /**< write/erase resume (post-suspend) */
include/flash.h:#define INTEL_UNLOCK   0xD0   /**< soft-unlock a block               */
include/flash.h:#define INTEL_LOCK     0x01   /**< soft-lock a block                 */
include/flash.h:#define AMD_LOCK            0x01    /**< soft-lock a block           */
include/flash.h:#define INTEL_SR_ESS   6      /**< Erase-Suspend Status              */
include/flash.h:#define INTEL_ID_DEV   0x02   /**< Device memory-map                 */
include/flash.h:#define INTEL_ID_BLS   0x04   /**< bit: 0 = soft-lock, 1 = hard-lock */
include/flash.h:#define INTEL_H_LOCK   0x02   /**< lock-down (hardward lock)         */
include/flash.h:#define AMD_H_LOCK   0x02   /**< lock-down (hardward lock)         */
include/flash.h:#define FLASH_STATUS   0x0000 /**< return status register (8-bits)   */
include/flash.h:#define FLASH_LOCKED   0x0010 /**< return id register (16-bits)      */
include/gpio.h:#define gpioLEDOn(n) ((struct gpio_csreg *)GPIO_BASE)->enable |= (n); \
include/gpio.h:							((struct gpio_csreg *)GPIO_BASE)->output &= ~(n)
include/gpio.h:#define gpioLEDOff(n) ((struct gpio_csreg *)GPIO_BASE)->enable &= ~(n)
include/http.h:#define HTTP_METHOD_NOALLOW -2
include/icmp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/icmp.h: * | Link-Level Header                                             |
include/icmp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/icmp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/icmp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/icmp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ipv4.h:/* Maximum length of an IPv4 address in dot-decimal notation */
include/ipv4.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ipv4.h: * | Link-Level Header                                             |
include/ipv4.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ipv4.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ipv4.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ipv4.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ipv4.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ipv4.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ipv4.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/ipv4.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/kernel.h:/** Type-independent macro to calculate the minimum of 2 values.  */
include/kernel.h:/** Type-independent macro to calculate the maximum of 2 values.  */
include/kernel.h:#define DIV_ROUND_UP(num, denom) (((num) + (denom) - 1) / (denom))
include/kexec.h: * This is a platform-dependent system call and may not be available on a given
include/limits.h:#define SCHAR_MIN (-128)        /**< minimum value of signed char       */
include/limits.h:#define INT_MIN   (-INT_MAX-1)  /**< minimum value of int               */
include/limits.h:#define LONG_MIN  (-LONG_MAX-1) /**< minimum value of long              */
include/limits.h:#define SHRT_MIN  (-SHRT_MAX-1) /**< minimum value of short             */
include/memory.h:/* roundmb - round address up to size of memblock  */
include/memory.h:/* truncmb - truncate address down to size of memblock */
include/memory.h:                                - (ulong)roundmb(len)       \
include/mips.h:#define AT   $1                /**< asm temp--uppercase due to .set at  */
include/mips.h:#define RA_CON  (CONTEXT - 8)   /**< return address                     */
include/nvram.h:#define NVRAM_MAGIC  0x48534c46 /**< 'FLSH' in little-endian            */
include/pcap.h:     * Zero-copy read buffer -- for zero-copy BPF.  'buffer' above will
include/pcap.h:    int break_loop;                /**< flag set break packet-read loop    */
include/pcap.h:#define PCAP_ERROR                -1 /**< generic error code               */
include/pcap.h:#define PCAP_ERROR_NO_SUCH_DEVICE -2 /**< device does not exist            */
include/pcap.h:#define PCAP_ERROR_NOT_ACTIVATED  -3 /**< capture needs to be activated    */
include/pcap.h:#define PCAP_ERROR_ACTIVATED      -4 /**< can't do action while active     */
include/pcap.h:#define PCAP_ERROR_PERM_DENIED    -8 /**< permissions denied               */
include/platform.h: * null-terminator.  */
include/platform.h: * Various platform-specific parameters filled in at boot time by
include/platform.h:    /** Name of the platform as a null-terminated string.  It is
include/platform.h:     * platform-specific what is considered a "name" and what is considered a
include/platform.h:    /** Family of the platform as a null-terminated string.  It is
include/platform.h:     * platform-specific what is considered a "name" and what is considered a
include/queue.h: * The thread queue system allows a statically-allocated array to
include/queue.h:#define EMPTY (-2)              /**< null pointer for queues            */
include/queue.h:                      (quehead(x) != (quetail(x) - 1)) || \
include/rtp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/rtp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/rtp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/rtp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/rtp.h:    ushort control;                             /**< RTP Control Bits 0-1: Version(2)
include/rtp.h:								2: Padding 3:Extension 4-7: CSRC Count
include/rtp.h:								8: Marker 9-15: Payload Type		*/
include/rtp.h:								(optional) (0-15 Items 32 Bits each)*/
include/rtp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/rtp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/rtp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/safemem.h: * Definitions for memory protection, including region-based memory
include/sbchipc.h: * Copyright 2001-2003, Broadcom Corporation
include/sbchipc.h:    /* gpio - cleared only by power-on-reset */
include/sbchipc.h:#define CAP_MIPSEB     0x00000004       /* MIPS is in big-endian mode */
include/sbchipc.h:                                                                                /* 6-bit fields like */
include/sbchipc.h:#define CC_F5_BIAS  5           /* 5-bit fields get this added */
include/sbchipc.h:#define SFLASH_ST_DP    0x00b9  /* Deep Power-down */
include/sbconfig.h:#define	SB_MAXCORES		((SB_ENUM_LIM - SB_ENUM_BASE)/SB_CORE_SIZE)
include/sbconfig.h:#define	SBTML_FL_MASK		0x3ffc0000      /* core-specific flags */
include/sbconfig.h:#define	SBTMH_FL_MASK		0x1fff0000      /* core-specific flags */
include/semaphore.h:/* isbadsem - check validity of reqested semaphore id and state */
include/shell.h:#define SHELL_BANNER_DEFAULT "\n\033[1;31m--------------------------------------\n      ____  ___.__                    \n      \\  \\/  /|__| ____  __ __       \n       \\     / |  |/    \\|  |  \\      \n       /     \\ |  |   |  \\  |  /      \n      /___/\\  \\|__|___|  /____/       \n            \\_/        \\/       v2.0  \n--------------------------------------\n\033[0;39m\n"
include/shell.h:#define SHELL_BANNER_DEFAULT_NONVT100 "--------------------------------------\n      ____  ___.__                    \n      \\   \\/  /|__| ____  __ __       \n       \\     / |  |/    \\|  |  \\      \n       /     \\ |  |   |  \\  |  /      \n      /___/\\  \\|__|___|  /____/       \n            \\_/        \\/       v3.14 \n--------------------------------------\n\n"
include/shell.h:#define SHELL_BANNER_PI "\n\033[1;31m-----------------------------------------------------\n      ____  ___\033[1;32m.__\033[1;31m                 .___   \033[1;32m.__\033[1;31m\n      \\   \\/  /\033[1;32m|__|\033[1;31m ____  __ __    |  _ \\ \033[1;32m|__|\033[1;31m\n       \\     / |  |/    \\|  |  \\   | |_| ||  |\n       /     \\ |  |   |  \\  |  /   |  __/ |  |\n      /___/\\  \\|__|___|  /____/    | |    |__|\n            \\_/        \\/          |/          v3.14\n-----------------------------------------------------\n\033[0;39m\n"
include/shell.h:#define SHELL_BANNER_PI_NONVT100 "-----------------------------------------------------\n      ____  ___.__                 .___   .__\n      \\   \\/  /|__| ____  __ __    |  _ \\ |__|\n       \\     / |  |/    \\|  |  \\   | |_| ||  |\n       /     \\ |  |   |  \\  |  /   |  __/ |  |\n      /___/\\  \\|__|___|  /____/    | |    |__|\n            \\_/        \\/          |/          v3.14\n-----------------------------------------------------\n\n"
include/shell.h:#define SHELL_BANNER_PI3 "\n\033[1;96m                                                 _______.\n\033[1;31m------------------------------------------------\033[1;96m/_____./|\033[1;31m------\n    ____  ___\033[1;32m.__   \033[1;31m              .___  \033[1;32m .__  \033[1;96m  | ____ | |\033[1;31m\n    \\   \\/  /\033[1;32m|__|\033[1;31m ____  __ __    |  _ \\ \033[1;32m|__| \033[1;96m  |/ /_| | |\033[1;31m\n     \\     / |  |/    \\|  |  \\   | |_| ||  |   \033[1;96m  |__  | |\033[1;31m\n     /     \\ |  |   |  \\  |  /   |  __/ |  |  \033[1;96m  /___| | .\033[1;31m\n    /___/\\  \\|__|___|  /____/    | |    |__| \033[1;96m  | ______/\033[1;31m\n          \\_/        \\/          |/          \033[1;96m  |/   \033[1;32m\n    2018                 			    v3.14 \033[1;31m\n---------------------------------------------------------------\033[0;39m\n"
include/shell.h:#define SHELL_BANNER_PI3_NONVT100 "\n                                                 _______.\n------------------------------------------------/_____./|------\n    ____  ___.__                 .___   .__    | ____ | |\n    \\   \\/  /|__| ____  __ __    |  _ \\ |__|   |/ /_| | |\n     \\     / |  |/    \\|  |  \\   | |_| ||  |     |__  | |\n     /     \\ |  |   |  \\  |  /   |  __/ |  |    /___| | .\n    /___/\\  \\|__|___|  /____/    | |    |__|   | ______/\n          \\_/        \\/          |/            |/   \n    2018                 			    v3.14 \n---------------------------------------------------------------\n"
include/shell.h:    bool builtin;               /**< built-in command?                  */
include/stdarg.h:/* GCC-specific varargs */
include/stddef.h:#define offsetof(type, member) ((size_t)&(((type *)0)->member))
include/stddef.h:#define SYSERR   (-1)           /**< system call failed                 */
include/stddef.h:#define EOF      (-2)           /**< End-of-file (usually from read)    */
include/stddef.h:#define TIMEOUT  (-3)           /**< system call timed out              */
include/stddef.h:#define NOMSG    (-4)           /**< no message to receive              */
include/stdio.h: * C99 doc: http://www.open-std.org/JTC1/SC22/WG14/www/docs/n1256.pdf
include/tcp.h:#define TCP_SYNSENT  2 /**< syn-sent state */
include/tcp.h:#define TCP_SYNRECV  3 /**< syn-recevied state */
include/tcp.h:#define TCP_FINWT1   5 /**< fin-wait-1 state */
include/tcp.h:#define TCP_FINWT2   6 /**< fin-wait-2 state */
include/tcp.h:#define TCP_CLOSEWT  7 /**< close-wait state */
include/tcp.h:#define TCP_LASTACK  9 /**< last-ack state */
include/tcp.h:#define TCP_TIMEWT  10 /**< time-wait state */
include/tcp.h:#define TCP_ERR_RESET   -2  /**< connection reset */
include/tcp.h:#define TCP_ERR_REFUSE  -3  /**< connection refused */
include/tcp.h:#define TCP_ERR_CLOSING -4  /**< connection closing */
include/tcp.h:#define TCP_ERR_NOCONN  -5  /**< no connection exists */
include/tcp.h:#define TCP_ERR_NOSPEC  -6  /**< foreign socket not specified */
include/tcp.h:#define TCP_ERR_MAXRXT  -7  /**< max num of retransmissions exceeded */
include/tcp.h:#define TCP_ERR_READTO  -8  /**< read call timed out */
include/tcp.h:#define TCP_ERR_ESTABTO -9  /**< conenction establishment timed out */
include/tcp.h:#define seqlt(a, b) (((int)(a) - (int)(b)) < 0)
include/tcp.h:#define seqlte(a, b) (((int)(a) - (int)(b)) <= 0)
include/tcp.h:#define tcpSeglen(tcppkt, len) (len - offset2octets(tcppkt->offset))
include/tcp.h:#define TCP_EVT_TIMEWT  1   /**< 2MSL time-wait timeout */
include/tftp.h:/** Maximum number of seconds to wait for the first block before re-sending the
include/tftp.h: * Type of a caller-provided callback function that consumes data downloaded by
include/thread.h:#define BADTID      (-1)        /**< used when invalid tid needed       */
include/thread.h:/* Inter-Thread Communication prototypes */
include/tlb.h:#define TLB_EXC_LENGTH (32 * 4)           /**< 32, 4-byte instructions */
include/uart.h:#define UART_IFLAG_NOBLOCK    0x0001 /**< do non-blocking input         */
include/uart.h:#define UART_OFLAG_NOBLOCK    0x0001 /**< do non-blocking output        */
include/uart.h: * Print hardware-specific statistics about the UART.
include/udp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/udp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/udp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/udp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/udp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/udp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/udp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/udp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/udp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/udp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/usb_core_driver.h: * Type of function called when an asynchronous (interrupt-driven) USB transfer
include/usb_core_driver.h: * (if the transfer was input and was successful), then either free or re-submit
include/usb_core_driver.h: * Specification of an asynchronous (interrupt-driven) USB transfer request.
include/usb_core_driver.h:     * error, or if the transfer was device-to-host (IN) and completed with no
include/usb_core_driver.h:     * successful device-to-host (IN) transfer, since it is valid for such a
include/usb_core_driver.h:     * do any necessary device-specific setup, such as configuring the device
include/usb_core_driver.h:     * with device-specific or class-specific control messages, and allocate any
include/usb_core_driver.h:     * can store per-device, driver-specific data in the @ref
include/usb_core_driver.h:    /** 1-based index of the USB port on the parent hub this device is plugged
include/usb_core_driver.h:    /** Null-terminated product string (ASCII encoded, and in English if
include/usb_core_driver.h:    /** Null-terminated manufacturer string (ASCII encoded, and in English if
include/usb_core_driver.h:/* The following functions are available only in non-embedded builds of the USB
include/usb_core_driver.h:    return req->endpoint_desc == NULL ||
include/usb_core_driver.h:           (req->endpoint_desc->bmAttributes & 0x3) == USB_TRANSFER_TYPE_CONTROL;
include/usb_core_driver.h:    return req->endpoint_desc != NULL &&
include/usb_core_driver.h:           (req->endpoint_desc->bmAttributes & 0x3) == USB_TRANSFER_TYPE_INTERRUPT;
include/usb_core_driver.h:    return dev->parent == NULL;
include/usb_core_driver.h:    return dev->descriptor.bDeviceClass == USB_CLASS_CODE_HUB;
include/usb_hub_defs.h:/** Standard format of USB hub descriptors.  See Table 11-13 in Section 11.23 of
include/usb_hub_defs.h:/** USB port features.  see Table 11-17 in Section 11.24.2 of the USB 2.0
include/usb_hub_defs.h:/** Standard USB hub requests.  See Table 11-16 in Section 11.24.2 of the USB
include/usb_std_defs.h:/** Standard USB descriptor types.  See Table 9-5 in Section 9.4 of the USB 2.0
include/usb_std_defs.h:/** USB request types (bits 6..5 of bmRequestType).  See Table 9-2 of Section
include/usb_std_defs.h:/** USB request recipients (bits 4..0 of bmRequestType).  See Table 9-2 of
include/usb_std_defs.h: * See Table 9-2 of Section 9.3 of the USB 2.0 specification.  */
include/usb_std_defs.h:/** Standard USB device requests.  See Table 9-3 in Section 9.4 of the USB 2.0
include/usb_std_defs.h: * the first 10 bits of the 16-bit language identifier.  */
include/usb_std_defs.h: * upper 6 bits of the 16-bit language identifier.  */
include/usb_std_defs.h:/** Standard SETUP data for a USB control request.  See Table 9-2 in Section 9.3
include/usb_std_defs.h:/** Standard format of USB device descriptors.  See Table 9-8 in 9.6.1 of the
include/usb_std_defs.h:/** Standard format of USB configuration descriptors.  See Table 9-10 in Section
include/usb_std_defs.h:/** Standard format of USB interface descriptors.  See Table 9-12 in Section
include/usb_std_defs.h:/** Standard format of USB endpoint descriptors.  See Table 9-13 in Section
include/usb_std_defs.h:/** Standard format of USB string descriptors.  See Table 9-16 in Section 9.7 of
include/usb_std_defs.h:    uint16_t bString[]; /* UTF-16LE encoded string
include/usb_util.h:    USB_STATUS_DEVICE_DETACHED           = -1,
include/usb_util.h:    USB_STATUS_DEVICE_UNSUPPORTED        = -2,
include/usb_util.h:    USB_STATUS_HARDWARE_ERROR            = -3,
include/usb_util.h:    USB_STATUS_INVALID_DATA              = -4,
include/usb_util.h:    USB_STATUS_INVALID_PARAMETER         = -5,
include/usb_util.h:    USB_STATUS_NOT_PROCESSED             = -6,
include/usb_util.h:    USB_STATUS_OUT_OF_MEMORY             = -7,
include/usb_util.h:    USB_STATUS_TIMEOUT                   = -8,
include/usb_util.h:    USB_STATUS_UNSUPPORTED_REQUEST       = -9,
include/usbkbd.h:#define USBKBD_IFLAG_NOBLOCK    0x0001 /**< do non-blocking input         */
include/usbkbd.h:/* usbkbd driver functions --- only call through device entries  */
include/vlan.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/vlan.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/vlan.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/vlan.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/vlan.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/vlan.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/vlan.h: * | Data (46 - 1500 octets)                                       |
include/vlan.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
include/watchdog.h: * Interface to the system watchdog timer.  This is a platform-dependent feature
include/version.h:#define VERSION "(Embedded Xinu) (arm-rpi3) #71 (pmcgee@traken.mscs.mu.edu) Wed Jul 25 11:32:57 CDT 2018"
lib/Makerules:INCLUDE := -I../../include -I../../system/platforms/$(PLATFORM) -I../..
lib/Makerules:CFILES  := $(filter-out $($(shell echo $(LIBNAME) | tr a-z A-Z)_OVERRIDE_CFILES), $(CFILES))
lib/Makerules:SFILES  := $(filter-out $($(shell echo $(LIBNAME) | tr a-z A-Z)_OVERRIDE_SFILES), $(SFILES))
lib/Makerules:CFLAGS  := $(CFLAGS:-I%=$(INCLUDE))
lib/Makerules:	@echo -e "\tCompiling" $^
lib/Makerules:	$(CC) $(CFLAGS) -c -o$@ $^
lib/Makerules:	@echo -e "\tAssembling" $^
lib/Makerules:	$(AS) $(AFLAGS) -o$@ $^
lib/Makerules:	rm -f $(LIBNAME).a
lib/Makerules:	rm -f $(OBJ) $(LIBNAME).a $(LIBDIR)/$(LIBNAME).a
lib/libdsp/linear2ulaw.c: *     1973, pg. 11.12-11.17
lib/libdsp/linear2ulaw.c: * 3) MIL-STD-188-113,"Interoperability and Performance Standards
lib/libdsp/linear2ulaw.c: *     for Analog-to_Digital Conversion Techniques,"
lib/libdsp/linear2ulaw.c:#define ZEROTRAP                /* turn on the trap as per the MIL-STD */
lib/libdsp/linear2ulaw.c:#define BIAS 0x84               /* define the add-in bias for 16 bit samples */
lib/libdsp/linear2ulaw.c:    /* Get the sample into sign-magnitude. */
lib/libdsp/linear2ulaw.c:        sample = -sample;       /* get magnitude */
lib/libdsp/ulaw2linear.c: * 2) MIL-STD-188-113,"Interoperability and Performance Standards
lib/libdsp/ulaw2linear.c: *     for Analog-to_Digital Conversion Techniques,"
lib/libdsp/ulaw2linear.c:        sample = -sample;
lib/libxc/Makefile:# Make Xinu's C run-time support library
lib/libxc/abs.c: *      the return value will be undefined because @c -INT_MIN cannot be
lib/libxc/abs.c:        j = -j;
lib/libxc/atoi.c: * Converts the initial portion of an ASCII null-terminated string into an
lib/libxc/atoi.c: * <code>-</code> character is allowed to indicate sign.  Parsing otherwise
lib/libxc/atol.c: * Converts the initial portion of an ASCII null-terminated string into a long
lib/libxc/atol.c: * <code>-</code> character is allowed to indicate sign.  Parsing otherwise
lib/libxc/doprnt.c: *     - @c "-" to specify left-justification
lib/libxc/doprnt.c: *     - @c "0" to specify zero padding
lib/libxc/doprnt.c: *    0-1 of the following:
lib/libxc/doprnt.c: *      - A series of decimal digits not beginning with 0 that specifies the
lib/libxc/doprnt.c: *        minimum field width as a non-negative integer
lib/libxc/doprnt.c: *      - @c "*", indicating that the minimum field width is given as an @c int
lib/libxc/doprnt.c: *    0-1 of the following:
lib/libxc/doprnt.c: *      - @c ".PREC", where @c PREC is a series of decimal digits that specifies
lib/libxc/doprnt.c: *        the precision as a non-negative integer
lib/libxc/doprnt.c: *      - @c "*", indicating that the precision is given as an @c int variadic
lib/libxc/doprnt.c: *    0-1 of the following:
lib/libxc/doprnt.c: *      - @c "hh"   for <code>signed char</code>  or <code>unsigned char</code>
lib/libxc/doprnt.c: *      - @c "h"    for <code>signed short</code> or <code>unsigned short</code>
lib/libxc/doprnt.c: *      - @c "l"    for <code>signed long</code>  or <code>unsigned long</code>
lib/libxc/doprnt.c: *      - @c "\%d"  to format a  signed integer   in decimal        (base 10)
lib/libxc/doprnt.c: *      - @c "\%b"  to format an unsigned integer in binary         (base 2)
lib/libxc/doprnt.c: *      - @c "\%o"  to format an unsigned integer in octal          (base 8)
lib/libxc/doprnt.c: *      - @c "\%u"  to format an unsigned integer in decimal        (base 10)
lib/libxc/doprnt.c: *      - @c "\%x"  to format an unsigned integer in lower case hex (base 16)
lib/libxc/doprnt.c: *      - @c "\%X"  to format an unsigned integer in upper case hex (base 16)
lib/libxc/doprnt.c: *      - @c "\%c"  to format a single character
lib/libxc/doprnt.c: *      - @c "\%s"  to format a null-terminated string, or "(null)" for a @c NULL pointer
lib/libxc/doprnt.c: *      - @c "\%\%" to format a literal percent sign
lib/libxc/doprnt.c: *      Variable-length list of values that will be formatted.
lib/libxc/doprnt.c:    bool leftjust;              /* true = left-justified,
lib/libxc/doprnt.c:                                   false = right-justified              */
lib/libxc/doprnt.c:    char sign;                  /* Set to '-' for negative decimals     */
lib/libxc/doprnt.c:    int len_nonpadding;         /* Total No. of non-padding chars to
lib/libxc/doprnt.c:            /* Parsing a conversion specification ---
lib/libxc/doprnt.c:            spec_start = fmt - 1;
lib/libxc/doprnt.c:            leftjust = FALSE;  /* Default: right-justified  */
lib/libxc/doprnt.c:                case '-':
lib/libxc/doprnt.c:                    /* '-' flag: left-justified conversion  */
lib/libxc/doprnt.c:                     * as a '-' flag followed by a positive field width.  */
lib/libxc/doprnt.c:                    fmin = -fmin;
lib/libxc/doprnt.c:                    fmin += (*fmt - '0');
lib/libxc/doprnt.c:            /* C99 7.19.6.1:  If both the '0' and '-' flags appear, the '0'
lib/libxc/doprnt.c:            prec = -1;
lib/libxc/doprnt.c:                        prec += (*fmt - '0');
lib/libxc/doprnt.c:                    sign = '-';
lib/libxc/doprnt.c:                    ularg = -ularg;
lib/libxc/doprnt.c:                        num_zeroes = prec - len_str;
lib/libxc/doprnt.c:                len_padding = fmin - len_nonpadding;
lib/libxc/doprnt.c:             * output is right-justified with zero padding, treat the padding
lib/libxc/doprnt.c:            /* If right-justified, pad on left.  */
lib/libxc/doprnt.c:            /* If left-justified, pad on right.  */
lib/libxc/doprnt.c: * converting numbers to a a string with power-of-two base.  */
lib/libxc/doprnt.c:        unsigned long mask = (1UL << shift) - 1;
lib/libxc/doprnt.c:        *str++ = temp[i--];
lib/libxc/doscan.c:/* Character look-ahead to be implemented as: ch=control(unit,TTY_IOC_NEXTC) */
lib/libxc/doscan.c: * - @c \%s to scan a whitespace-delimited string
lib/libxc/doscan.c: * - @c \%o to scan an octal number (@c \%O for long)
lib/libxc/doscan.c: * - @c \%x to scan a hexideminal number (@c \%X for long)
lib/libxc/doscan.c: * - @c \%c to scan a sequence of characters
lib/libxc/doscan.c: * - @c \%[ to scan a sequence of characters from the specified set
lib/libxc/doscan.c: * - @c \%\% to match a literal percent sign
lib/libxc/doscan.c: * - All other conversion specifiers, including @c \%d and @c \%u, are
lib/libxc/doscan.c: * - Whitespace to match any amount of whitespace in the input.
lib/libxc/doscan.c: * - Maximum length modifier
lib/libxc/doscan.c: * - @c 'l' type modifier to parse a long int rather than a normal int
lib/libxc/doscan.c: * - @c 'h' type modifier to parse a short int rather than a normal int
lib/libxc/doscan.c: * - @c '*' character to suppress assignment
lib/libxc/doscan.c: *      variable-length list of locations to store the scanned data
lib/libxc/doscan.c: *      end-of-file or read error.
lib/libxc/doscan.c:                maxlen += (*ufmt - '0');
lib/libxc/doscan.c: * boolean that indicates whether end-of-file or a read error was encountered or
lib/libxc/doscan.c:    negative = (c == '-');
lib/libxc/doscan.c:    if (c == '-' || c == '+')
lib/libxc/doscan.c:                n += 0xA + (c - 'a');
lib/libxc/doscan.c:                n += (c - '0');
lib/libxc/doscan.c:                n += (c - '0');
lib/libxc/doscan.c:            n = -n;
lib/libxc/doscan.c:            ufmt--;
lib/libxc/fgetc.c: *      cast to an @c int.  On read error, invalid device, or end-of file,
lib/libxc/fgets.c: * Reads a newline-terminated string from a device.
lib/libxc/fgets.c: *      On success, the resulting buffer will contain a null-terminated string
lib/libxc/fgets.c:    while ((--n > 0) && ((c = fgetc(dev)) != EOF))
lib/libxc/fgets.c:    /* Null-terminate the buffer and return a pointer to it.  */
lib/libxc/fputs.c: * Writes a null-terminated string to a device.
lib/libxc/fputs.c: *      A non-negative number on success, or @c EOF on error.
lib/libxc/free.c:    block--;
lib/libxc/free.c:    if (block->next != block)
lib/libxc/free.c:    memfree(block, block->length);
lib/libxc/fscanf.c:    if (buf->ch_avail)
lib/libxc/fscanf.c:        buf->ch_avail = FALSE;
lib/libxc/fscanf.c:        return buf->c;
lib/libxc/fscanf.c:        buf->c = c;
lib/libxc/fscanf.c:    buf->ch_avail = TRUE;
lib/libxc/fscanf.c:    return buf->c;
lib/libxc/labs.c: *      the return value will be undefined because @c -LONG_MIN cannot be
lib/libxc/labs.c:        j = -j;
lib/libxc/malloc.c:    pmem->next = pmem;
lib/libxc/malloc.c:    pmem->length = size;
lib/libxc/memcmp.c:            return (int)p1[i] - (int)p2[i];
lib/libxc/qsort.c: * Sorts an array of data using quicksort.  The average-case running time is O(n
lib/libxc/qsort.c:        qsort(base + (pivot_index + 1) * size, nmemb - (pivot_index + 1),
lib/libxc/qsort.c: * element is taken to be the pivot.  The array is re-arranged so that all
lib/libxc/qsort.c: * resulting 0-based index of the pivot.
lib/libxc/qsort.c:            p2 -= size;
lib/libxc/qsort.c:    p1 -= size;
lib/libxc/qsort.c:    p1_index--;
lib/libxc/rand.c: * Beware: this is not re-entrant.
lib/libxc/rand.c:    /* This uses a linear congruential generator.  The seed retains a 32-bit
lib/libxc/sprintf.c: * Write a formatted message to a null-terminated string.
lib/libxc/sprintf.c:    return s - str;
Binary file lib/libxc/abs.o matches
lib/libxc/sscanf.c:    str--;
lib/libxc/strchr.c: * Returns a pointer to the first location in a null-terminated string at which
lib/libxc/strcmp.c: * Compare two null-terminated strings.
lib/libxc/strcmp.c:    return (int)(unsigned char)*s1 - (int)(unsigned char)*s2;
lib/libxc/strcpy.c: * Copies a a null-terminated string to the specified location.  The source and
lib/libxc/strlcpy.c: * Copy a null-terminated string into a fixed-size buffer.  Unlike strncpy(),
lib/libxc/strlcpy.c: * string is guaranteed to be null-terminated (unless @p destsize was 0).
lib/libxc/strlcpy.c: *      Pointer to the null-terminated string to copy.
lib/libxc/strlcpy.c:        if (destsize - 1 < srclen)
lib/libxc/strlcpy.c:            copylen = destsize - 1;
lib/libxc/strlen.c: * Calculates the length of a null-terminated string.
lib/libxc/strncat.c: * null-terminated string to another null-terminated string, always
lib/libxc/strncat.c: * null-terminating the result.  The strings may not overlap.
lib/libxc/strncat.c: *      Pointer to the null-terminated string to which to concatenate the
lib/libxc/strncmp.c: * Compare two null-terminated strings, examining at most the specified number
lib/libxc/strncmp.c:            return (int)(unsigned char)s1[i] - (int)(unsigned char)s2[i];
lib/libxc/strncpy.c: * may or may not be null-terminated, but if it is and the null terminator is
lib/libxc/strncpy.c: * first @p n bytes, the destination will not be null-terminated.  To correctly
lib/libxc/strncpy.c: * write a null-terminated string into a fixed-size buffer with truncation as
lib/libxc/strnlen.c: * Returns the length of a null-terminated string, but not more than the
lib/libxc/strrchr.c: * Returns a pointer to the last location in a null-terminated string at which a
lib/libxc/strstr.c: * Returns a pointer to the first location in a null-terminated string at which
Binary file lib/libxc/ctype_.o matches
Binary file lib/libxc/doprnt.o matches
Binary file lib/libxc/atoi.o matches
Binary file lib/libxc/atol.o matches
Binary file lib/libxc/bzero.o matches
Binary file lib/libxc/libxc.a matches
Binary file lib/libxc/doscan.o matches
Binary file lib/libxc/fgetc.o matches
Binary file lib/libxc/fgets.o matches
Binary file lib/libxc/fprintf.o matches
Binary file lib/libxc/fputc.o matches
Binary file lib/libxc/fputs.o matches
Binary file lib/libxc/fscanf.o matches
Binary file lib/libxc/labs.o matches
Binary file lib/libxc/memchr.o matches
Binary file lib/libxc/memcmp.o matches
Binary file lib/libxc/memcpy.o matches
Binary file lib/libxc/memset.o matches
Binary file lib/libxc/printf.o matches
Binary file lib/libxc/qsort.o matches
Binary file lib/libxc/rand.o matches
Binary file lib/libxc/sprintf.o matches
Binary file lib/libxc/sscanf.o matches
Binary file lib/libxc/strchr.o matches
Binary file lib/libxc/strcmp.o matches
Binary file lib/libxc/strcpy.o matches
Binary file lib/libxc/strlcpy.o matches
Binary file lib/libxc/strlen.o matches
Binary file lib/libxc/strncat.o matches
Binary file lib/libxc/strncmp.o matches
Binary file lib/libxc/strncpy.o matches
Binary file lib/libxc/strnlen.o matches
Binary file lib/libxc/strrchr.o matches
Binary file lib/libxc/strstr.o matches
Binary file lib/libxc/malloc.o matches
Binary file lib/libxc/free.o matches
Binary file lib/libxc.a matches
loader/arch/README:This directory contains CPU-architecture-specific code.
loader/arch/mips/start.S:	/* Clear tags again--deemed prudent by some */
loader/arch/mips/start.S:	/* Clear tags again--deemed prudent by some */
loader/arch/mips/start.S:	/* Clear Xinu-defined trap and interrupt vectors              */
loader/arch/mips/start.S: * Copy text (code) from source to detination (in word-size chunks).
loader/arch/mips/start.S:	addiu a2, a2, -4
loader/arch/mips/start.S: * Zero memory from dstBegin to dstEnd (non-inclusive).	
loader/platforms/arm-qemu/Makerules:COMP = loader/platforms/arm-qemu
loader/platforms/arm-qemu/start.S: * Initialization code for Embedded Xinu on ARM-QEMU (emulation of an ARM
loader/platforms/arm-qemu/start.S: * Raspberry Pi platform (arm-rpi).  The only relevant difference should be the
loader/platforms/arm-qemu/start.S:	ldmia r1!, {r2-r9}
loader/platforms/arm-qemu/start.S:	stmia r0!, {r2-r9}
loader/platforms/arm-qemu/start.S:	ldmia r1!, {r2-r9}
loader/platforms/arm-qemu/start.S:	stmia r0!, {r2-r9}
loader/platforms/arm-qemu/start.S:	 * - unaligned memory accesses   (bit 22)
loader/platforms/arm-qemu/start.S:	 * pass -mno-unaligned-access to gcc to prevent it from doing so.)  */
loader/platforms/arm-qemu/start.S:	stmia r0!, {r2-r5}
loader/platforms/arm-qemu/start.S:	/* Branch to the platform-independent C startup code, which takes no
loader/platforms/arm-rpi/Makerules:COMP = loader/platforms/arm-rpi
loader/platforms/arm-rpi/start.S:	ldmia r1!, {r2-r9}
loader/platforms/arm-rpi/start.S:	stmia r0!, {r2-r9}
loader/platforms/arm-rpi/start.S:	ldmia r1!, {r2-r9}
loader/platforms/arm-rpi/start.S:	stmia r0!, {r2-r9}
loader/platforms/arm-rpi/start.S:	 * - unaligned memory accesses   (bit 22)
loader/platforms/arm-rpi/start.S:	 * pass -mno-unaligned-access to gcc to prevent it from doing so.)  */
loader/platforms/arm-rpi/start.S:	stmia r0!, {r2-r5}
loader/platforms/arm-rpi/start.S:	/* Branch to the platform-independent C startup code, which takes no
loader/platforms/mipsel-qemu/Makerules:COMP = loader/platforms/mipsel-qemu
loader/platforms/x86/Makerules:	$(CC) $(CFLAGS) -DBRELOC=${IMG_START} -o $@ $<
loader/platforms/x86/start.S:	decl	%eax            # 16-byte align stack pointer
loader/platforms/arm-rpi3/Makerules:COMP = loader/platforms/arm-rpi3
loader/platforms/arm-rpi3/start.S: * -----------------------------------------------------------------------------------------
loader/platforms/arm-rpi3/start.S: * Specific for Raspberry Pi 3 (BCM2837) - Memory Layout (Not to scale)
loader/platforms/arm-rpi3/start.S: * +----------+
loader/platforms/arm-rpi3/start.S: * | IO SPACE | -> 0x3F000000 to 0x3FFFFFFF reserved for IO (GPIO, UART, SYS TIMER, USB CORE)
loader/platforms/arm-rpi3/start.S: * +----------+
loader/platforms/arm-rpi3/start.S: * |   HEAP   | -> getmem allocates from here
loader/platforms/arm-rpi3/start.S: * +----------+
loader/platforms/arm-rpi3/start.S: * | OS STACK | -> becomes the null process' stack
loader/platforms/arm-rpi3/start.S: * +----------+
loader/platforms/arm-rpi3/start.S: * |   BSS    | -> needed for C environment
loader/platforms/arm-rpi3/start.S: * +----------+
loader/platforms/arm-rpi3/start.S: * |   TEXT   | -> XINU code
loader/platforms/arm-rpi3/start.S: * +----------+
loader/platforms/arm-rpi3/start.S: * | RESERVED | -> interrupt handler and vectors go here
loader/platforms/arm-rpi3/start.S: * +----------+
loader/platforms/arm-rpi3/start.S:	/* byte of the kernel image and on the Raspberry Pi 3 (32-bit mode) will be loaded by
loader/platforms/arm-rpi3/start.S:	 * The standard protocol for Aarch32 (ARMv8-A) is to pass the atags pointer
loader/platforms/arm-rpi3/start.S:        * by four to skip a 32-bit word. Upon exception return, the CPSR is changed, and
loader/platforms/arm-rpi3/start.S:/* Vector table has to be 32-byte aligned. */
loader/platforms/arm-rpi3/start.S:	 * - unaligned memory accesses   (bit 22)
loader/platforms/arm-rpi3/start.S:	 * pass -mno-unaligned-access to gcc to prevent it from doing so.)  */
loader/platforms/arm-rpi3/start.S:	stmia r0!, {r2-r5}
loader/platforms/arm-rpi3/start.S:	/* Refer to ARM Cortex-A53 documentation, Section 4.4.1, Table 4-122: */
loader/platforms/arm-rpi3/start.S~:	mov	x0, #(1 << 31)		/* 64-bit EL1 */
loader/platforms/arm-rpi3/start.S~: *  used to implement statically-scoped variables and recursive procedure
loader/platforms/arm-rpi3/start.S~: *  calls in most ALGOL-like languages, including C and all its progeny.
loader/platforms/arm-rpi3/start.S~: * +----------+
loader/platforms/arm-rpi3/start.S~: * |   HEAP   | -> getmem allocates from here
loader/platforms/arm-rpi3/start.S~: * +----------+
loader/platforms/arm-rpi3/start.S~: * | OS STACK | -> becomes the null process' stack
loader/platforms/arm-rpi3/start.S~: * +----------+
loader/platforms/arm-rpi3/start.S~: * |   BSS    | -> needed for C environment
loader/platforms/arm-rpi3/start.S~: * +----------+
loader/platforms/arm-rpi3/start.S~: * |   TEXT   | -> XINU code
loader/platforms/arm-rpi3/start.S~: * +----------+
loader/platforms/arm-rpi3/start.S~: * | RESERVED | -> interrupt handler and vectors go here
loader/platforms/arm-rpi3/start.S~: * +----------+
loader/platforms/arm-rpi3/start.S~:	/* Put non-used cores in busy wait */
Binary file loader/platforms/arm-rpi3/start.o matches
loader/platforms/arm-rpi3/start.d:../loader/platforms/arm-rpi3/start.o: \
loader/platforms/arm-rpi3/start.d: ../loader/platforms/arm-rpi3/start.S ../include/arm.h
mailbox/mailboxAlloc.c:        if (MAILBOX_FREE == mbxptr->state)
mailbox/mailboxAlloc.c:            mbxptr->msgs = memget(sizeof(int) * count);
mailbox/mailboxAlloc.c:            if (SYSERR == (int)mbxptr->msgs)
mailbox/mailboxAlloc.c:            mbxptr->count = 0;
mailbox/mailboxAlloc.c:            mbxptr->start = 0;
mailbox/mailboxAlloc.c:            mbxptr->max = count;
mailbox/mailboxAlloc.c:            mbxptr->sender = semcreate(count);
mailbox/mailboxAlloc.c:            mbxptr->receiver = semcreate(0);
mailbox/mailboxAlloc.c:            if ((SYSERR == (int)mbxptr->sender) ||
mailbox/mailboxAlloc.c:                (SYSERR == (int)mbxptr->receiver))
mailbox/mailboxAlloc.c:                memfree(mbxptr->msgs, sizeof(int) * (mbxptr->max));
mailbox/mailboxAlloc.c:                semfree(mbxptr->sender);
mailbox/mailboxAlloc.c:                semfree(mbxptr->receiver);
mailbox/mailboxAlloc.c:            mbxptr->state = MAILBOX_ALLOC;
mailbox/mailboxCount.c:    if (MAILBOX_ALLOC == mbxptr->state)
mailbox/mailboxCount.c:        retval = mbxptr->count;
mailbox/mailboxFree.c:    if (MAILBOX_ALLOC == mbxptr->state)
mailbox/mailboxFree.c:        mbxptr->state = MAILBOX_FREE;
mailbox/mailboxFree.c:        semfree(mbxptr->sender);
mailbox/mailboxFree.c:        semfree(mbxptr->receiver);
mailbox/mailboxFree.c:        memfree(mbxptr->msgs, sizeof(int) * (mbxptr->max));
mailbox/mailboxReceive.c:    if (MAILBOX_ALLOC == mbxptr->state)
mailbox/mailboxReceive.c:        wait(mbxptr->receiver);
mailbox/mailboxReceive.c:        if (MAILBOX_ALLOC == mbxptr->state)
mailbox/mailboxReceive.c:            retval = mbxptr->msgs[mbxptr->start];
mailbox/mailboxReceive.c:            mbxptr->start = (mbxptr->start + 1) % mbxptr->max;
mailbox/mailboxReceive.c:            mbxptr->count--;
mailbox/mailboxReceive.c:            signal(mbxptr->sender);
mailbox/mailboxSend.c:    if (MAILBOX_ALLOC == mbxptr->state)
mailbox/mailboxSend.c:        wait(mbxptr->sender);
mailbox/mailboxSend.c:        if (MAILBOX_ALLOC == mbxptr->state)
mailbox/mailboxSend.c:            mbxptr->msgs[((mbxptr->start + mbxptr->count) % mbxptr->max)] =
mailbox/mailboxSend.c:            mbxptr->count++;
mailbox/mailboxSend.c:            signal(mbxptr->receiver);
Binary file mailbox/mailboxReceive.o matches
mailbox/mailboxReceive.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
mailbox/mailboxReceive.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/mailbox.h \
mailbox/mailboxReceive.d:../system/platforms/arm-rpi3/interrupt.h:
mailbox/mailboxReceive.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file mailbox/mailboxAlloc.o matches
Binary file mailbox/mailboxCount.o matches
mailbox/mailboxCount.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
mailbox/mailboxCount.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/mailbox.h \
mailbox/mailboxCount.d:../system/platforms/arm-rpi3/interrupt.h:
mailbox/mailboxCount.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file mailbox/mailboxFree.o matches
Binary file mailbox/mailboxInit.o matches
Binary file mailbox/mailboxSend.o matches
mailbox/mailboxSend.d: ../system/platforms/arm-rpi3/interrupt.h \
mailbox/mailboxSend.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/mailbox.h \
mailbox/mailboxSend.d:../system/platforms/arm-rpi3/interrupt.h:
mailbox/mailboxSend.d:../system/platforms/arm-rpi3/bcm2837.h:
mem/free.c:    block--;
mem/free.c:    if (block->next != block)
mem/free.c:    safeUnmapRange(block, block->length);
mem/free.c:    prev = &(thread->memlist);
mem/free.c:    next = thread->memlist.next;
mem/free.c:        next = next->next;
mem/free.c:    if (prev == &(thread->memlist))
mem/free.c:        top = (ulong)prev + prev->length;
mem/free.c:            && ((ulong)block + block->length) > (ulong)next))
mem/free.c:    thread->memlist.length += block->length;
mem/free.c:        prev->length += block->length;
mem/free.c:        block->next = next;
mem/free.c:        prev->next = block;
mem/free.c:    if (((ulong)block + block->length) == (ulong)next)
mem/free.c:        block->length += next->length;
mem/free.c:        block->next = next->next;
mem/malloc.c:    prev = &(thread->memlist);
mem/malloc.c:    curr = thread->memlist.next;
mem/malloc.c:        if (curr->length == nbytes)
mem/malloc.c:            prev->next = curr->next;
mem/malloc.c:            thread->memlist.length -= nbytes;
mem/malloc.c:        else if (curr->length > nbytes)
mem/malloc.c:            prev->next = leftover;
mem/malloc.c:            leftover->next = curr->next;
mem/malloc.c:            leftover->length = curr->length - nbytes;
mem/malloc.c:            thread->memlist.length -= nbytes;
mem/malloc.c:        curr = curr->next;
mem/malloc.c:        curr->next = curr;
mem/malloc.c:        curr->length = nbytes;
mem/malloc.c:    curr = region->start;
mem/malloc.c:    if (region->length > nbytes)
mem/malloc.c:        leftover = (struct memblock *)((uint)region->start + nbytes);
mem/malloc.c:        leftover->next = leftover;
mem/malloc.c:        leftover->length = region->length - nbytes;
mem/malloc.c:    curr->next = curr;
mem/malloc.c:    curr->length = nbytes;
mem/memRegionAlloc.c:        if (region->length > nbytes)
mem/memRegionAlloc.c:        region = region->next;
mem/memRegionAlloc.c:    if (region->length > nbytes)
mem/memRegionAlloc.c:    region->thread_id = gettid();
mem/memRegionClear.c:    region->prev = (struct memregion *)SYSERR;
mem/memRegionClear.c:    region->next = (struct memregion *)SYSERR;
mem/memRegionClear.c:    region->start = NULL;
mem/memRegionClear.c:    region->length = 0;
mem/memRegionClear.c:    region->thread_id = 0;
mem/memRegionInit.c:        - (uint)memory_start;
mem/memRegionInsert.c:    while ((SYSERR != (int)current) && (current->start < region->start))
mem/memRegionInsert.c:        current = current->next;
mem/memRegionInsert.c:        previous->next = region;
mem/memRegionInsert.c:        region->prev = previous;
mem/memRegionInsert.c:        region->next = (struct memregion *)SYSERR;
mem/memRegionInsert.c:        region->prev = current->prev;
mem/memRegionInsert.c:        region->next = current;
mem/memRegionInsert.c:        if ((int)(current->prev) != SYSERR)
mem/memRegionInsert.c:            current->prev->next = region;
mem/memRegionInsert.c:        current->prev = region;
mem/memRegionInsert.c:    /* does region bump with region->next? */
mem/memRegionInsert.c:    adjacent = region->next;
mem/memRegionInsert.c:        && ((uint)(region->start) + region->length)
mem/memRegionInsert.c:        == (uint)(adjacent->start))
mem/memRegionInsert.c:        /* coalesce region with region->next */
mem/memRegionInsert.c:        region->length += adjacent->length;
mem/memRegionInsert.c:        region->next = adjacent->next;
mem/memRegionInsert.c:        if (SYSERR != (int)adjacent->next)
mem/memRegionInsert.c:            adjacent->next->prev = region;
mem/memRegionInsert.c:    adjacent = region->prev;
mem/memRegionInsert.c:        && ((uint)(adjacent->start) + adjacent->length ==
mem/memRegionInsert.c:            (uint)(region->start)))
mem/memRegionInsert.c:        /* coalesce region with region->prev */
mem/memRegionInsert.c:        adjacent->length += region->length;
mem/memRegionInsert.c:        adjacent->next = region->next;
mem/memRegionInsert.c:        if (SYSERR != (int)region->next)
mem/memRegionInsert.c:            region->next->prev = adjacent;
mem/memRegionReclaim.c:        nextregion = region->next;
mem/memRegionReclaim.c:        if (region->thread_id == tid)
mem/memRegionReclaim.c:            safeUnmapRange(region->start, region->length);
mem/memRegionRemove.c:    /* If region has previous, set prev->next to region->next */
mem/memRegionRemove.c:    if ((int)(region->prev) != SYSERR)
mem/memRegionRemove.c:        region->prev->next = region->next;
mem/memRegionRemove.c:        *list = region->next;
mem/memRegionRemove.c:    /* If region has next, set next->prev to region->prev */
mem/memRegionRemove.c:    if ((int)(region->next) != SYSERR)
mem/memRegionRemove.c:        region->next->prev = region->prev;
mem/memRegionRemove.c:    region->prev = (struct memregion *)SYSERR;
mem/memRegionRemove.c:    region->next = (struct memregion *)SYSERR;
mem/memRegionSplit.c:    if (region->length < length)
mem/memRegionSplit.c:    if (region->length == length)
mem/memRegionSplit.c:    rem_start = (void *)((uint)(region->start) + length);
mem/memRegionSplit.c:    remainder->prev = (struct memregion *)SYSERR;
mem/memRegionSplit.c:    remainder->next = (struct memregion *)SYSERR;
mem/memRegionSplit.c:    remainder->start = rem_start;
mem/memRegionSplit.c:    remainder->length = region->length - length;
mem/memRegionSplit.c:    remainder->thread_id = 0;
mem/memRegionSplit.c:    region->length = length;
mem/memRegionSplit.c:    offset = ((addr - start) / PAGE_SIZE);
mem/memRegionTransfer.c:    region->thread_id = tid;
mem/memRegionValid.c:    while (((int)region != SYSERR) && (region->start != start))
mem/memRegionValid.c:        region = region->next;
mem/safeKmapInit.c:    /* setup pre-kernel space pages */
mem/safeKmapInit.c:    length = (uint)&_end - (uint)_start;
mem/safeKmapInit.c:    length = (uint)memheap - (uint)&_end;
mem/safeKmapInit.c:    length = (uint)memheap - (uint)&_end;
mem/safeMap.c: * @return non-zero value on failure.
mem/safeMap.c:    if (entry->entry != NULL)
mem/safeMap.c:    entry->entry = (uint)page >> 6 | attr;
mem/safeMap.c:    entry->asid = gettid();
mem/safeMap.c://    kprintf("Mapped 0x%08x (0x%08x) to pgtbl index %d @ 0x%08x\r\n", page, entry->frame, index, entry);
mem/safeMapRange.c: * @return non-zero value on failure.
mem/safeUnmap.c: * @return non-zero value on failure.
mem/safeUnmap.c:    if ((entry->entry & 0xffffffc0) != ((uint)page >> 6))
mem/safeUnmapRange.c: * @return non-zero value on failure.
mem/tlbMiss.S:	addiu   sp, sp, -TLBREC_SIZE
network/arp/arpAlloc.c: * @pre-condition interrupts are disabled
network/arp/arpAlloc.c: * @post-condition interrupts are still disabled
network/arp/arpAlloc.c:            || (arptab[i].expires < minexpires->expires))
network/arp/arpAlloc.c:                      minexpires->expires);
network/arp/arpAlloc.c:    minexpires->state = ARP_USED;
network/arp/arpFree.c:    if (ARP_UNRESOLVED == entry->state)
network/arp/arpFree.c:    entry->state = ARP_FREE;
network/arp/arpFree.c:              ((int)entry - (int)arptab) / sizeof(struct arpEntry));
network/arp/arpGetEntry.c:        if (entry->expires < clktime)
network/arp/arpGetEntry.c:        if (netaddrequal(&entry->praddr, praddr))
network/arp/arpLookup.c:            entry->state = ARP_UNRESOLVED;
network/arp/arpLookup.c:            entry->nif = netptr;
network/arp/arpLookup.c:            netaddrcpy(&entry->praddr, praddr);
network/arp/arpLookup.c:            entry->expires = clktime + ARP_TTL_UNRESOLVED;
network/arp/arpLookup.c:            entry->count = 0;
network/arp/arpLookup.c:        if (ARP_RESOLVED == entry->state)
network/arp/arpLookup.c:            netaddrcpy(hwaddr, &entry->hwaddr);
network/arp/arpLookup.c:        if (entry->count >= ARP_NTHRWAIT)
network/arp/arpLookup.c:        entry->waiting[entry->count] = gettid();
network/arp/arpLookup.c:        entry->count++;
network/arp/arpLookup.c:        ttl = (entry->expires - clktime) * CLKTICKS_PER_SEC;
network/arp/arpLookup.c:            /* Reply received, address resolved, re-attempt lookup */
network/arp/arpNotify.c:    for (i = 0; i < entry->count; i++)
network/arp/arpNotify.c:        if (SYSERR == send(entry->waiting[i], msg))
network/arp/arpNotify.c:    entry->count = 0;
network/arp/arpNotify.c:    bzero(entry->waiting, sizeof(tid_typ) * ARP_NTHRWAIT);
network/arp/arpRecv.c:    pkt->nethdr = pkt->curr;
network/arp/arpRecv.c:    arp = (struct arpPkt *)pkt->curr;
network/arp/arpRecv.c:    netptr = pkt->nif;
network/arp/arpRecv.c:    if ((ARP_HWTYPE_ETHERNET != net2hs(arp->hwtype))
network/arp/arpRecv.c:        || (ETH_ADDR_LEN != arp->hwalen))
network/arp/arpRecv.c:    if ((ETHER_TYPE_IPv4 != net2hs(arp->prtype))
network/arp/arpRecv.c:        || (IPv4_ADDR_LEN != arp->pralen))
network/arp/arpRecv.c:    sha.type = net2hs(arp->hwtype);
network/arp/arpRecv.c:    sha.len = arp->hwalen;
network/arp/arpRecv.c:    memcpy(sha.addr, &arp->addrs[0], sha.len);
network/arp/arpRecv.c:    spa.type = net2hs(arp->prtype);
network/arp/arpRecv.c:    spa.len = arp->pralen;
network/arp/arpRecv.c:    memcpy(spa.addr, &arp->addrs[arp->hwalen], spa.len);
network/arp/arpRecv.c:        netaddrcpy(&entry->hwaddr, &sha);
network/arp/arpRecv.c:        entry->expires = clktime + ARP_TTL_RESOLVED;
network/arp/arpRecv.c:        if (ARP_UNRESOLVED == entry->state)
network/arp/arpRecv.c:            entry->state = ARP_RESOLVED;
network/arp/arpRecv.c:    dpa.type = net2hs(arp->prtype);
network/arp/arpRecv.c:    dpa.len = arp->pralen;
network/arp/arpRecv.c:    memcpy(dpa.addr, &arp->addrs[arp->hwalen * 2 + arp->pralen], dpa.len);
network/arp/arpRecv.c:    if (netaddrequal(&netptr->ip, &dpa))
network/arp/arpRecv.c:            entry->state = ARP_RESOLVED;
network/arp/arpRecv.c:            entry->nif = pkt->nif;
network/arp/arpRecv.c:            netaddrcpy(&entry->hwaddr, &sha);
network/arp/arpRecv.c:            netaddrcpy(&entry->praddr, &spa);
network/arp/arpRecv.c:            entry->expires = clktime + ARP_TTL_RESOLVED;
network/arp/arpRecv.c:                      ((int)entry -
network/arp/arpRecv.c:                      entry->state);
network/arp/arpRecv.c:        if (ARP_OP_RQST == net2hs(arp->op))
network/arp/arpSendReply.c:    netptr = pkt->nif;
network/arp/arpSendReply.c:    arp = (struct arpPkt *)pkt->curr;
network/arp/arpSendReply.c:    arp->op = hs2net(ARP_OP_REPLY);
network/arp/arpSendReply.c:    memcpy(&arp->addrs[ARP_ADDR_DHA(arp)], &arp->addrs[ARP_ADDR_SHA(arp)],
network/arp/arpSendReply.c:           arp->hwalen);
network/arp/arpSendReply.c:    memcpy(&arp->addrs[ARP_ADDR_DPA(arp)], &arp->addrs[ARP_ADDR_SPA(arp)],
network/arp/arpSendReply.c:           arp->pralen);
network/arp/arpSendReply.c:    memcpy(&arp->addrs[ARP_ADDR_SHA(arp)], netptr->hwaddr.addr,
network/arp/arpSendReply.c:           arp->hwalen);
network/arp/arpSendReply.c:    memcpy(&arp->addrs[ARP_ADDR_SPA(arp)], netptr->ip.addr, arp->pralen);
network/arp/arpSendReply.c:    dst.type = net2hs(arp->hwtype);
network/arp/arpSendReply.c:    dst.len = arp->hwalen;
network/arp/arpSendReply.c:    memcpy(dst.addr, &arp->addrs[ARP_ADDR_DHA(arp)], dst.len);
network/arp/arpSendRqst.c:    netptr = entry->nif;
network/arp/arpSendRqst.c:    pkt->nif = netptr;
network/arp/arpSendRqst.c:    pkt->len =
network/arp/arpSendRqst.c:        ARP_CONST_HDR_LEN + netptr->hwaddr.len * 2 + netptr->ip.len * 2;
network/arp/arpSendRqst.c:    pkt->curr -= pkt->len;
network/arp/arpSendRqst.c:    arp = (struct arpPkt *)pkt->curr;
network/arp/arpSendRqst.c:    arp->hwtype = hs2net(netptr->hwaddr.type);
network/arp/arpSendRqst.c:    arp->prtype = hs2net(netptr->ip.type);
network/arp/arpSendRqst.c:    arp->hwalen = netptr->hwaddr.len;
network/arp/arpSendRqst.c:    arp->pralen = netptr->ip.len;
network/arp/arpSendRqst.c:    arp->op = hs2net(ARP_OP_RQST);
network/arp/arpSendRqst.c:    memcpy(&arp->addrs[ARP_ADDR_SHA(arp)], netptr->hwaddr.addr,
network/arp/arpSendRqst.c:           arp->hwalen);
network/arp/arpSendRqst.c:    memcpy(&arp->addrs[ARP_ADDR_SPA(arp)], netptr->ip.addr, arp->pralen);
network/arp/arpSendRqst.c:    memcpy(&arp->addrs[ARP_ADDR_DPA(arp)], entry->praddr.addr,
network/arp/arpSendRqst.c:           arp->pralen);
network/arp/arpSendRqst.c:    result = netSend(pkt, &netptr->hwbrc, NULL, ETHER_TYPE_ARP);
Binary file network/arp/arpGetEntry.o matches
network/arp/arpGetEntry.d: ../include/clock.h ../system/platforms/arm-rpi3/interrupt.h \
network/arp/arpGetEntry.d: ../system/platforms/arm-rpi3/bcm2837.h
network/arp/arpGetEntry.d:../system/platforms/arm-rpi3/interrupt.h:
network/arp/arpGetEntry.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/arp/arpAlloc.o matches
Binary file network/arp/arpDaemon.o matches
Binary file network/arp/arpSendReply.o matches
Binary file network/arp/arpFree.o matches
network/arp/arpFree.d: ../system/platforms/arm-rpi3/interrupt.h \
network/arp/arpFree.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/stdlib.h
network/arp/arpFree.d:../system/platforms/arm-rpi3/interrupt.h:
network/arp/arpFree.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/arp/arpInit.o matches
network/arp/arpInit.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
network/arp/arpInit.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/arp/arpInit.d:../system/platforms/arm-rpi3/interrupt.h:
network/arp/arpInit.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/arp/arpLookup.o matches
network/arp/arpLookup.d: ../include/clock.h ../system/platforms/arm-rpi3/interrupt.h \
network/arp/arpLookup.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/thread.h \
network/arp/arpLookup.d:../system/platforms/arm-rpi3/interrupt.h:
network/arp/arpLookup.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/arp/arpNotify.o matches
network/arp/arpNotify.d: ../system/platforms/arm-rpi3/interrupt.h \
network/arp/arpNotify.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/stdlib.h \
network/arp/arpNotify.d:../system/platforms/arm-rpi3/interrupt.h:
network/arp/arpNotify.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/arp/arpRecv.o matches
network/arp/arpRecv.d: ../system/platforms/arm-rpi3/interrupt.h \
network/arp/arpRecv.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/ipv4.h \
network/arp/arpRecv.d:../system/platforms/arm-rpi3/interrupt.h:
network/arp/arpRecv.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/arp/arpSendRqst.o matches
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcp.h: * +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
network/dhcpc/dhcpClient.c:    uint delay = 1000;  /* Milliseconds to wait after non-timeout error */
network/dhcpc/dhcpClient.c:    data->state = DHCPC_STATE_INIT;
network/dhcpc/dhcpClient.c:        switch (data->state)
network/dhcpc/dhcpClient.c:            data->cxid = rand();          /* Choose random context ID */
network/dhcpc/dhcpClient.c:            data->starttime = clktime;    /* Set starting time   */
network/dhcpc/dhcpClient.c:            data->clientIpv4Addr = 0;     /* Client IP address is unknown  */
network/dhcpc/dhcpClient.c:            data->serverIpv4Addr = 0;     /* Server IP address is unknown  */
network/dhcpc/dhcpClient.c:                                  (long)data->clientHwAddr, 0))
network/dhcpc/dhcpClient.c:            bzero(data->serverHwAddr, ETH_ADDR_LEN);
network/dhcpc/dhcpClient.c:                data->state = DHCPC_STATE_SELECTING;
network/dhcpc/dhcpClient.c:                data->state = DHCPC_STATE_INIT;
network/dhcpc/dhcpClient.c:                data->state = DHCPC_STATE_REQUESTING;
network/dhcpc/dhcpClient.c:                data->state = DHCPC_STATE_INIT;
network/dhcpc/dhcpClient.c:                data->state = DHCPC_STATE_BOUND;
network/dhcpc/dhcpClient.c:                data->state = DHCPC_STATE_INIT;
network/dhcpc/dhcpRecvReply.c:/* Stress testing--- randomly ignore this percent of valid received data
network/dhcpc/dhcpRecvReply.c: * - If in DHCPC_STATE_SELECTING, the client waits until it gets a DHCPOFFER
network/dhcpc/dhcpRecvReply.c: * - If in DHCPC_STATE_REQUESTING, the client waits until it gets a DHCPACK or
network/dhcpc/dhcpRecvReply.c:        retval = data->recvStatus;
network/dhcpc/dhcpRecvReply.c:        int len = read(descrp, pkt->data, maxlen);
network/dhcpc/dhcpRecvReply.c:            data->recvStatus = SYSERR;
network/dhcpc/dhcpRecvReply.c:        pkt->len = len;
network/dhcpc/dhcpRecvReply.c:        DHCP_TRACE("Received packet (len=%u).", pkt->len);
network/dhcpc/dhcpRecvReply.c:        if (pkt->len < (ETH_HDR_LEN + IPv4_HDR_LEN +
network/dhcpc/dhcpRecvReply.c:        epkt = (const struct etherPkt *)pkt->data;
network/dhcpc/dhcpRecvReply.c:        ipv4 = (const struct ipv4Pkt *)epkt->data;
network/dhcpc/dhcpRecvReply.c:        udp = (const struct udpPkt *)ipv4->opts;
network/dhcpc/dhcpRecvReply.c:        dhcp = (const struct dhcpPkt *)udp->data;
network/dhcpc/dhcpRecvReply.c:        if ((ETHER_TYPE_IPv4 != net2hs(epkt->type))
network/dhcpc/dhcpRecvReply.c:            || (IPv4_PROTO_UDP != ipv4->proto)
network/dhcpc/dhcpRecvReply.c:            || (UDP_PORT_DHCPC != net2hs(udp->dstPort))
network/dhcpc/dhcpRecvReply.c:            || (UDP_PORT_DHCPS != net2hs(udp->srcPort))
network/dhcpc/dhcpRecvReply.c:            || (DHCP_OP_REPLY != dhcp->op)
network/dhcpc/dhcpRecvReply.c:            || (data->cxid != net2hl(dhcp->xid)))
network/dhcpc/dhcpRecvReply.c:        opts = dhcp->opts;
network/dhcpc/dhcpRecvReply.c:        opts_end = opts + (pkt->len - (ETH_HDR_LEN + IPv4_HDR_LEN +
network/dhcpc/dhcpRecvReply.c:        found_msg = -1;
network/dhcpc/dhcpRecvReply.c:                    if ((DHCPC_STATE_SELECTING == data->state &&
network/dhcpc/dhcpRecvReply.c:                        || (DHCPC_STATE_REQUESTING == data->state &&
network/dhcpc/dhcpRecvReply.c:        serverIpv4Addr = net2hl(dhcp->siaddr);
network/dhcpc/dhcpRecvReply.c:        data->serverIpv4Addr = serverIpv4Addr;
network/dhcpc/dhcpRecvReply.c:        data->offeredIpv4Addr = net2hl(dhcp->yiaddr);
network/dhcpc/dhcpRecvReply.c:        memcpy(data->serverHwAddr, epkt->src, ETH_ADDR_LEN);
network/dhcpc/dhcpRecvReply.c:        if (serverIpv4Addr != data->serverIpv4Addr)
network/dhcpc/dhcpRecvReply.c:            data->ip.type = NETADDR_IPv4;
network/dhcpc/dhcpRecvReply.c:            data->ip.len = IPv4_ADDR_LEN;
network/dhcpc/dhcpRecvReply.c:            memcpy(data->ip.addr, &dhcp->yiaddr, IPv4_ADDR_LEN);
network/dhcpc/dhcpRecvReply.c:            data->clientIpv4Addr = net2hl(dhcp->yiaddr);
network/dhcpc/dhcpRecvReply.c:            data->mask.type = NETADDR_IPv4;
network/dhcpc/dhcpRecvReply.c:            data->mask.len = IPv4_ADDR_LEN;
network/dhcpc/dhcpRecvReply.c:            memcpy(data->mask.addr, maskptr, IPv4_ADDR_LEN);
network/dhcpc/dhcpRecvReply.c:                data->gateway.type = NETADDR_IPv4;
network/dhcpc/dhcpRecvReply.c:                data->gateway.len = IPv4_ADDR_LEN;
network/dhcpc/dhcpRecvReply.c:                memcpy(data->gateway.addr, gatewayptr, IPv4_ADDR_LEN);
network/dhcpc/dhcpRecvReply.c:            if (0 != dhcp->siaddr)
network/dhcpc/dhcpRecvReply.c:                data->next_server.type = NETADDR_IPv4;
network/dhcpc/dhcpRecvReply.c:                data->next_server.len = IPv4_ADDR_LEN;
network/dhcpc/dhcpRecvReply.c:                memcpy(data->next_server.addr, &dhcp->siaddr, IPv4_ADDR_LEN);
network/dhcpc/dhcpRecvReply.c:            if ('\0' != dhcp->file[0])
network/dhcpc/dhcpRecvReply.c:                memcpy(data->bootfile, dhcp->file, sizeof(data->bootfile) - 1);
network/dhcpc/dhcpRecvReply.c:                netaddrsprintf(str_addr, &data->ip);
network/dhcpc/dhcpRecvReply.c:                netaddrsprintf(str_addr, &data->mask);
network/dhcpc/dhcpRecvReply.c:                    netaddrsprintf(str_addr, &data->gateway);
network/dhcpc/dhcpRecvReply.c:                netaddrsprintf(str_addr, &data->next_server);
network/dhcpc/dhcpRecvReply.c:                DHCP_TRACE("Bootfile=%s", data->bootfile);
network/dhcpc/dhcpRecvReply.c:    data->recvStatus = retval;
network/dhcpc/dhcpSendRequest.c:    switch (data->state)
network/dhcpc/dhcpSendRequest.c:            tmp_ipv4addr = hl2net(data->offeredIpv4Addr);
network/dhcpc/dhcpSendRequest.c:            tmp_ipv4addr = hl2net(data->serverIpv4Addr);
network/dhcpc/dhcpSendRequest.c:    } while ((optsize = (opts - optarray)) & 3);
network/dhcpc/dhcpSendRequest.c:    pkt->len += pktsize;
network/dhcpc/dhcpSendRequest.c:    pkt->curr -= pktsize;
network/dhcpc/dhcpSendRequest.c:    ether = (struct etherPkt*)pkt->curr;
network/dhcpc/dhcpSendRequest.c:    ipv4 = (struct ipv4Pkt *)ether->data;
network/dhcpc/dhcpSendRequest.c:    udp = (struct udpPkt *)ipv4->opts;
network/dhcpc/dhcpSendRequest.c:    dhcp = (struct dhcpPkt *)udp->data;
network/dhcpc/dhcpSendRequest.c:    dhcp->op = DHCP_OP_REQUEST;
network/dhcpc/dhcpSendRequest.c:    dhcp->htype = DHCP_HTYPE_ETHER;
network/dhcpc/dhcpSendRequest.c:    dhcp->hlen = ETH_ADDR_LEN;
network/dhcpc/dhcpSendRequest.c:    dhcp->hops = 0;
network/dhcpc/dhcpSendRequest.c:    dhcp->xid = hl2net(data->cxid);
network/dhcpc/dhcpSendRequest.c:    if (data->state == DHCPC_STATE_SELECTING)
network/dhcpc/dhcpSendRequest.c:        dhcp->secs = hs2net(data->discoverSecs);
network/dhcpc/dhcpSendRequest.c:        dhcp->secs = hs2net(clktime - data->starttime);
network/dhcpc/dhcpSendRequest.c:        if (data->state == DHCPC_STATE_INIT)
network/dhcpc/dhcpSendRequest.c:            data->discoverSecs = net2hs(dhcp->secs);
network/dhcpc/dhcpSendRequest.c:    dhcp->flags = 0x0000;
network/dhcpc/dhcpSendRequest.c:    dhcp->ciaddr = hl2net(data->clientIpv4Addr);
network/dhcpc/dhcpSendRequest.c:    dhcp->yiaddr = 0; /* RFC 2131:  client must set yiaddr to 0.  */
network/dhcpc/dhcpSendRequest.c:    dhcp->siaddr = 0; /* RFC 2131:  client must set siaddr to 0.  */
network/dhcpc/dhcpSendRequest.c:    dhcp->giaddr = 0; /* RFC 2131:  client must set giaddr to 0.  */
network/dhcpc/dhcpSendRequest.c:    memcpy(dhcp->chaddr, data->clientHwAddr, dhcp->hlen);
network/dhcpc/dhcpSendRequest.c:    dhcp->cookie = hl2net(DHCP_MAGICCOOKIE);
network/dhcpc/dhcpSendRequest.c:    memcpy(dhcp->opts, optarray, optsize);
network/dhcpc/dhcpSendRequest.c:    udp->srcPort = hs2net(UDP_PORT_DHCPC);
network/dhcpc/dhcpSendRequest.c:    udp->dstPort = hs2net(UDP_PORT_DHCPS);
network/dhcpc/dhcpSendRequest.c:    udp->len = hs2net(UDP_HDR_LEN + DHCP_HDR_LEN + optsize);
network/dhcpc/dhcpSendRequest.c:    ipv4->proto = IPv4_PROTO_UDP;
network/dhcpc/dhcpSendRequest.c:    memset(ipv4->src, 0, IPv4_ADDR_LEN);
network/dhcpc/dhcpSendRequest.c:    memset(ipv4->dst, 0xff, IPv4_ADDR_LEN);
network/dhcpc/dhcpSendRequest.c:    ipv4->ttl = 0;
network/dhcpc/dhcpSendRequest.c:    ipv4->chksum = udp->len;
network/dhcpc/dhcpSendRequest.c:    udp->chksum = netChksum((uchar *)&ipv4->ttl,
network/dhcpc/dhcpSendRequest.c:    ipv4->ver_ihl = (IPv4_VERSION << 4) | (IPv4_HDR_LEN / 4);
network/dhcpc/dhcpSendRequest.c:    ipv4->tos = IPv4_TOS_ROUTINE;
network/dhcpc/dhcpSendRequest.c:    ipv4->len = hs2net(pktsize - ETH_HDR_LEN);
network/dhcpc/dhcpSendRequest.c:    ipv4->id = 0;
network/dhcpc/dhcpSendRequest.c:    ipv4->flags_froff = hs2net(IPv4_FLAG_DF | 0x0000);
network/dhcpc/dhcpSendRequest.c:    ipv4->ttl = IPv4_TTL;
network/dhcpc/dhcpSendRequest.c:    ipv4->chksum = 0;
network/dhcpc/dhcpSendRequest.c:    ipv4->chksum = netChksum((uchar *)ipv4, IPv4_HDR_LEN);
network/dhcpc/dhcpSendRequest.c:    memset(ether->dst, 0xff, ETH_ADDR_LEN);
network/dhcpc/dhcpSendRequest.c:    memcpy(ether->src, data->clientHwAddr, ETH_ADDR_LEN);
network/dhcpc/dhcpSendRequest.c:    ether->type = hs2net(ETHER_TYPE_IPv4);
network/dhcpc/dhcpSendRequest.c:    if (pktsize == write(descrp, pkt->curr, pktsize))
Binary file network/dhcpc/dhcpSendRequest.o matches
Binary file network/dhcpc/dhcpClient.o matches
network/dhcpc/dhcpClient.d: ../system/platforms/arm-rpi3/interrupt.h \
network/dhcpc/dhcpClient.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/dhcpc/dhcpClient.d:../system/platforms/arm-rpi3/interrupt.h:
network/dhcpc/dhcpClient.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/dhcpc/dhcpRecvReply.o matches
network/dhcpc/dhcpRecvReply.d: ../system/platforms/arm-rpi3/interrupt.h \
network/dhcpc/dhcpRecvReply.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/dhcpc/dhcpRecvReply.d:../system/platforms/arm-rpi3/interrupt.h:
network/dhcpc/dhcpRecvReply.d:../system/platforms/arm-rpi3/bcm2837.h:
network/emulate/emuDuplicate.c:    return (emuReorder(pkt) | test(pkt, dupes - 1));
Binary file network/emulate/emuCorrupt.o matches
Binary file network/emulate/emuDelay.o matches
network/emulate/emuDelay.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
network/emulate/emuDelay.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
network/emulate/emuDelay.d:../system/platforms/arm-rpi3/interrupt.h:
network/emulate/emuDelay.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/emulate/emuDrop.o matches
network/emulate/emuDrop.d: ../system/platforms/arm-rpi3/interrupt.h \
network/emulate/emuDrop.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/emulate/emuDrop.d:../system/platforms/arm-rpi3/interrupt.h:
network/emulate/emuDrop.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/emulate/emuDuplicate.o matches
Binary file network/emulate/emuReorder.o matches
Binary file network/emulate/netemu.o matches
network/icmp/icmpDaemon.c:                   pkt->len, pkt->len - (pkt->curr - pkt->data));
network/icmp/icmpDaemon.c:        /* Send the ICMP Echo Reply, re-using the packet buffer.  */
network/icmp/icmpDestUnreach.c:    ip = (const struct ipv4Pkt *)unreached->nethdr;
network/icmp/icmpDestUnreach.c:    memcpy(dst.addr, ip->src, dst.len);
network/icmp/icmpDestUnreach.c:    ihl = (ip->ver_ihl & IPv4_IHL) * 4;
network/icmp/icmpDestUnreach.c:    pkt->len = ihl + ICMP_DEF_DATALEN;
network/icmp/icmpDestUnreach.c:    pkt->curr -= pkt->len;
network/icmp/icmpDestUnreach.c:    memcpy(pkt->curr, ip, ihl + ICMP_DEF_DATALEN);
network/icmp/icmpDestUnreach.c:    pkt->curr -= 4;
network/icmp/icmpDestUnreach.c:    pkt->len += 4;
network/icmp/icmpDestUnreach.c:    *((ulong *)pkt->curr) = 0;
network/icmp/icmpDestUnreach.c:    result = icmpSend(pkt, ICMP_UNREACH, code, pkt->len, &src, &dst);
network/icmp/icmpEchoReply.c: *      re-used for sending the reply.  pkt->curr must point to the beginning of
network/icmp/icmpEchoReply.c: *      the the ICMP header, whereas pkt->len must be the length of the entire
network/icmp/icmpEchoReply.c: *      packet including link-level header.  These members will be updated by
network/icmp/icmpEchoReply.c:    ip = (struct ipv4Pkt *)pkt->nethdr;
network/icmp/icmpEchoReply.c:    memcpy(dst.addr, ip->dst, dst.len);
network/icmp/icmpEchoReply.c:    memcpy(src.addr, ip->src, src.len);
network/icmp/icmpEchoReply.c:    /* Set pkt->curr to point to ICMP data and set pkt->len to the length of
network/icmp/icmpEchoReply.c:    pkt->curr += ICMP_HEADER_LEN;
network/icmp/icmpEchoReply.c:    pkt->len -= (pkt->curr - pkt->data);
network/icmp/icmpEchoReply.c:    return icmpSend(pkt, ICMP_ECHOREPLY, 0, pkt->len, &dst, &src);
network/icmp/icmpEchoRequest.c:    pkt->len = sizeof(struct icmpEcho);
network/icmp/icmpEchoRequest.c:    pkt->curr -= pkt->len;
network/icmp/icmpEchoRequest.c:    echo = (struct icmpEcho *)pkt->curr;
network/icmp/icmpEchoRequest.c:    echo->id = hs2net(id);
network/icmp/icmpEchoRequest.c:    echo->seq = hs2net(seq);
network/icmp/icmpEchoRequest.c:    echo->timecyc = hl2net(clkcount());
network/icmp/icmpEchoRequest.c:    echo->timetic = hl2net(clkticks);
network/icmp/icmpEchoRequest.c:    echo->timesec = hl2net(clktime);
network/icmp/icmpEchoRequest.c:    echo->arrivcyc = 0;
network/icmp/icmpEchoRequest.c:    echo->arrivtic = 0;
network/icmp/icmpEchoRequest.c:    echo->arrivsec = 0;
network/icmp/icmpEchoRequest.c:               net2hs(echo->id), net2hs(echo->seq),
network/icmp/icmpEchoRequest.c:               net2hl(echo->timesec), net2hl(echo->timetic));
network/icmp/icmpRecv.c:    icmp = (struct icmpPkt *)pkt->curr;
network/icmp/icmpRecv.c:    switch (icmp->type)
network/icmp/icmpRecv.c:        echo = (struct icmpEcho *)icmp->data;
network/icmp/icmpRecv.c:        id = net2hs(echo->id);
network/icmp/icmpRecv.c:            echo->arrivcyc = clkcount();
network/icmp/icmpRecv.c:            echo->arrivtic = clkticks;
network/icmp/icmpRecv.c:            echo->arrivsec = clktime;
network/icmp/icmpRecv.c:                if (id == eq->tid)
network/icmp/icmpRecv.c:                    if (((eq->head + 1) % NPINGHOLD) == eq->tail)
network/icmp/icmpRecv.c:                    eq->pkts[eq->head] = pkt;
network/icmp/icmpRecv.c:                    eq->head = ((eq->head + 1) % NPINGHOLD);
network/icmp/icmpRecv.c:        ICMP_TRACE("ICMP message type %d not handled", icmp->type);
network/icmp/icmpRecv.c:        ICMP_TRACE("ICMP message type %d unknown", icmp->type);
network/icmp/icmpRedirect.c:    ip = (struct ipv4Pkt *)redir->nethdr;
network/icmp/icmpRedirect.c:    memcpy(dst.addr, ip->src, dst.len);
network/icmp/icmpRedirect.c:    ihl = (ip->ver_ihl & IPv4_IHL) * 4;
network/icmp/icmpRedirect.c:    pkt->len = ihl + ICMP_DEF_DATALEN;
network/icmp/icmpRedirect.c:    pkt->curr -= pkt->len;
network/icmp/icmpRedirect.c:    memcpy(pkt->curr, ip, ihl + ICMP_DEF_DATALEN);
network/icmp/icmpRedirect.c:    pkt->curr -= IPv4_ADDR_LEN;
network/icmp/icmpRedirect.c:    pkt->len += IPv4_ADDR_LEN;
network/icmp/icmpRedirect.c:    memcpy(pkt->curr, route->gateway.addr, IPv4_ADDR_LEN);
network/icmp/icmpRedirect.c:    result = icmpSend(pkt, ICMP_REDIRECT, code, pkt->len, &src, &dst);
network/icmp/icmpSend.c: *      Packet containing the ICMP data.  pkt->curr must be positioned on the
network/icmp/icmpSend.c: *      ICMP data, pkt->len must be the length of the ICMP data, and there must
network/icmp/icmpSend.c: *      be at least enough space between pkt->data and pkt->curr for the ICMP,
network/icmp/icmpSend.c: *      IPv4, and link-level headers to be attached.
network/icmp/icmpSend.c: *      Source network address.  If src->type == 0, then the source is
network/icmp/icmpSend.c:    pkt->curr -= ICMP_HEADER_LEN;
network/icmp/icmpSend.c:    pkt->len += ICMP_HEADER_LEN;
network/icmp/icmpSend.c:    icmp = (struct icmpPkt *)pkt->curr;
network/icmp/icmpSend.c:    icmp->type = type;
network/icmp/icmpSend.c:    icmp->code = code;
network/icmp/icmpSend.c:    icmp->chksum = 0;
network/icmp/icmpSend.c:    icmp->chksum = netChksum((uchar *)icmp, datalen + ICMP_HEADER_LEN);
network/icmp/icmpTimeExceeded.c:    ip = (struct ipv4Pkt *)unreached->nethdr;
network/icmp/icmpTimeExceeded.c:    memcpy(dst.addr, ip->src, dst.len);
network/icmp/icmpTimeExceeded.c:    ihl = (ip->ver_ihl & IPv4_IHL) * 4;
network/icmp/icmpTimeExceeded.c:    pkt->len = ihl + ICMP_DEF_DATALEN;
network/icmp/icmpTimeExceeded.c:    pkt->curr -= pkt->len;
network/icmp/icmpTimeExceeded.c:    memcpy(pkt->curr, ip, ihl + ICMP_DEF_DATALEN);
network/icmp/icmpTimeExceeded.c:    pkt->curr -= 4;
network/icmp/icmpTimeExceeded.c:    pkt->len += 4;
network/icmp/icmpTimeExceeded.c:    *((ulong *)pkt->curr) = 0;
network/icmp/icmpTimeExceeded.c:    result = icmpSend(pkt, ICMP_TIMEEXCD, code, pkt->len, &src, &dst);
Binary file network/icmp/icmpDestUnreach.o matches
Binary file network/icmp/icmpEchoReply.o matches
Binary file network/icmp/icmpEchoRequest.o matches
network/icmp/icmpEchoRequest.d: ../system/platforms/arm-rpi3/interrupt.h \
network/icmp/icmpEchoRequest.d: ../system/platforms/arm-rpi3/bcm2837.h
network/icmp/icmpEchoRequest.d:../system/platforms/arm-rpi3/interrupt.h:
network/icmp/icmpEchoRequest.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/icmp/icmpInit.o matches
network/icmp/icmpInit.d: ../system/platforms/arm-rpi3/interrupt.h \
network/icmp/icmpInit.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/icmp/icmpInit.d:../system/platforms/arm-rpi3/interrupt.h:
network/icmp/icmpInit.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/icmp/icmpRecv.o matches
network/icmp/icmpRecv.d: ../include/clock.h ../system/platforms/arm-rpi3/interrupt.h \
network/icmp/icmpRecv.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/ipv4.h \
network/icmp/icmpRecv.d:../system/platforms/arm-rpi3/interrupt.h:
network/icmp/icmpRecv.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/icmp/icmpRedirect.o matches
Binary file network/icmp/icmpSend.o matches
Binary file network/icmp/icmpTimeExceeded.o matches
Binary file network/icmp/icmpDaemon.o matches
network/ipv4/dot2ipv4.c: * Convert an IPv4 address in dotted-decimal notation into a netaddr.
network/ipv4/dot2ipv4.c: *      The dotted-decimal IPv4 address string to convert.
network/ipv4/dot2ipv4.c:    ip->addr[0] = o0;
network/ipv4/dot2ipv4.c:    ip->addr[1] = o1;
network/ipv4/dot2ipv4.c:    ip->addr[2] = o2;
network/ipv4/dot2ipv4.c:    ip->addr[3] = o3;
network/ipv4/dot2ipv4.c:    ip->type = NETADDR_IPv4;
network/ipv4/dot2ipv4.c:    ip->len = IPv4_ADDR_LEN;
network/ipv4/ipv4Recv.c:    pkt->nethdr = pkt->curr;
network/ipv4/ipv4Recv.c:    ip = (struct ipv4Pkt *)pkt->curr;
network/ipv4/ipv4Recv.c:    memcpy(dst.addr, ip->dst, dst.len);
network/ipv4/ipv4Recv.c:    memcpy(src.addr, ip->src, src.len);
network/ipv4/ipv4Recv.c:    if ((IPv4_FLAG_MF & net2hs(ip->flags_froff))
network/ipv4/ipv4Recv.c:        || (0 != (net2hs(ip->flags_froff) & IPv4_FROFF)))
network/ipv4/ipv4Recv.c:     * If the packet length returned from the Ethernet driver (pkt->len)
network/ipv4/ipv4Recv.c:    iplen = net2hs(ip->len);
network/ipv4/ipv4Recv.c:    if ((pkt->len - pkt->nif->linkhdrlen) > iplen)
network/ipv4/ipv4Recv.c:        pkt->len = pkt->nif->linkhdrlen + iplen;
network/ipv4/ipv4Recv.c:    pkt->curr += ((ip->ver_ihl & IPv4_IHL) << 2);
network/ipv4/ipv4Recv.c:    IPv4_TRACE("IPv4 proto %d", ip->proto);
network/ipv4/ipv4Recv.c:    switch (ip->proto)
network/ipv4/ipv4Recv.c:        rawRecv(pkt, &src, &dst, ip->proto);
network/ipv4/ipv4RecvDemux.c:        if (netptr->state != NET_ALLOC)
network/ipv4/ipv4RecvDemux.c:        if (netaddrequal(dst, &netptr->ip)
network/ipv4/ipv4RecvDemux.c:            || netaddrequal(dst, &netptr->ipbrc))
network/ipv4/ipv4RecvValid.c:	int ip_ihl = ip->ver_ihl & IPv4_IHL;
network/ipv4/ipv4RecvValid.c:    if (((ip->ver_ihl & IPv4_VER) >> 4) != IPv4_VERSION)
network/ipv4/ipv4RecvValid.c:    if (ip->len < (IPv4_MIN_IHL * 4))
network/ipv4/ipv4Send.c:    if (dst->type != NETADDR_IPv4)
network/ipv4/ipv4Send.c:    pkt->nif = rtptr->nif;
network/ipv4/ipv4Send.c:    if (NULL == rtptr->gateway.type)
network/ipv4/ipv4Send.c:        nxthop = &rtptr->gateway;
network/ipv4/ipv4Send.c:    pkt->len += IPv4_HDR_LEN;
network/ipv4/ipv4Send.c:    pkt->curr -= IPv4_HDR_LEN;
network/ipv4/ipv4Send.c:    ip = (struct ipv4Pkt *)pkt->curr;
network/ipv4/ipv4Send.c:    ip->ver_ihl = (uchar)(IPv4_VERSION << 4);
network/ipv4/ipv4Send.c:    ip->ver_ihl += IPv4_HDR_LEN / 4;
network/ipv4/ipv4Send.c:    ip->tos = IPv4_TOS_ROUTINE;
network/ipv4/ipv4Send.c:    ip->len = hs2net(pkt->len);
network/ipv4/ipv4Send.c:    ip->id = 0;
network/ipv4/ipv4Send.c:    ip->flags_froff = 0;
network/ipv4/ipv4Send.c:    ip->ttl = IPv4_TTL;
network/ipv4/ipv4Send.c:    ip->proto = proto;
network/ipv4/ipv4Send.c:    if (NULL == src->type)
network/ipv4/ipv4Send.c:        memcpy(ip->src, pkt->nif->ip.addr, IPv4_ADDR_LEN);
network/ipv4/ipv4Send.c:        memcpy(ip->src, src->addr, IPv4_ADDR_LEN);
network/ipv4/ipv4Send.c:    memcpy(ip->dst, dst->addr, IPv4_ADDR_LEN);
network/ipv4/ipv4Send.c:    ip->chksum = 0;
network/ipv4/ipv4Send.c:    ip->chksum = netChksum((uchar *)ip, IPv4_HDR_LEN);
network/ipv4/ipv4SendFrag.c:    ip = (struct ipv4Pkt *)pkt->curr;
network/ipv4/ipv4SendFrag.c:    if (net2hs(ip->len) <= pkt->nif->mtu)
network/ipv4/ipv4SendFrag.c:        if (netaddrequal(&pkt->nif->ipbrc, nxthop))
network/ipv4/ipv4SendFrag.c:    if (net2hs(ip->flags_froff) & IPv4_FLAG_DF)
network/ipv4/ipv4SendFrag.c:    ihl = (ip->ver_ihl & IPv4_IHL) * 4;
network/ipv4/ipv4SendFrag.c:    dRem = net2hs(ip->len) - ihl;
network/ipv4/ipv4SendFrag.c:    froff = net2hs(ip->flags_froff) & IPv4_FROFF;
network/ipv4/ipv4SendFrag.c:    lastFlag = net2hs(ip->flags_froff) & IPv4_FLAGS;
network/ipv4/ipv4SendFrag.c:    // Length of data in this packet will be MTU - header length,
network/ipv4/ipv4SendFrag.c:    dLen = (pkt->nif->mtu - ihl) & ~0x7;
network/ipv4/ipv4SendFrag.c:    pkt->len = ihl + dLen;
network/ipv4/ipv4SendFrag.c:    ip->len = hs2net(pkt->len);
network/ipv4/ipv4SendFrag.c:    ip->flags_froff = IPv4_FLAG_MF & froff;
network/ipv4/ipv4SendFrag.c:    ip->flags_froff = hs2net(ip->flags_froff);
network/ipv4/ipv4SendFrag.c:    ip->chksum = 0;
network/ipv4/ipv4SendFrag.c:    ip->chksum = netChksum((uchar *)ip, ihl);
network/ipv4/ipv4SendFrag.c:    dRem -= dLen;
network/ipv4/ipv4SendFrag.c:    outpkt->curr -= pkt->nif->mtu;
network/ipv4/ipv4SendFrag.c:    outip = (struct ipv4Pkt *)outpkt->curr;
network/ipv4/ipv4SendFrag.c:    outpkt->nif = pkt->nif;
network/ipv4/ipv4SendFrag.c:        if (((dRem + 7) & ~0x7) > pkt->nif->mtu + IPv4_HDR_LEN)
network/ipv4/ipv4SendFrag.c:            dLen = (pkt->nif->mtu - IPv4_HDR_LEN) & ~0x7;
network/ipv4/ipv4SendFrag.c:        memcpy(outip->opts, data, dLen);
network/ipv4/ipv4SendFrag.c:            outip->flags_froff = lastFlag & froff;
network/ipv4/ipv4SendFrag.c:            outip->flags_froff = IPv4_FLAG_MF & froff;
network/ipv4/ipv4SendFrag.c:        outip->flags_froff = hs2net(outip->flags_froff);
network/ipv4/ipv4SendFrag.c:        outip->len = hs2net(IPv4_HDR_LEN + dLen);
network/ipv4/ipv4SendFrag.c:        outip->chksum = 0;
network/ipv4/ipv4SendFrag.c:        outip->chksum = netChksum((uchar *)outip, IPv4_HDR_LEN);
network/ipv4/ipv4SendFrag.c:        outpkt->len = net2hs(outip->len);
network/ipv4/ipv4SendFrag.c:        dRem -= dLen;
Binary file network/ipv4/ipv4RecvDemux.o matches
Binary file network/ipv4/dot2ipv4.o matches
network/ipv4/dot2ipv4.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
network/ipv4/dot2ipv4.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
network/ipv4/dot2ipv4.d:../system/platforms/arm-rpi3/interrupt.h:
network/ipv4/dot2ipv4.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/ipv4/ipv4Recv.o matches
network/ipv4/ipv4Recv.d: ../system/platforms/arm-rpi3/interrupt.h \
network/ipv4/ipv4Recv.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/ipv4/ipv4Recv.d:../system/platforms/arm-rpi3/interrupt.h:
network/ipv4/ipv4Recv.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/ipv4/ipv4RecvValid.o matches
Binary file network/ipv4/ipv4Send.o matches
Binary file network/ipv4/ipv4SendFrag.o matches
network/net/netChksum.c:        len -= 2;
network/net/netChksum.c:    /* Add left-over byte, if any */
network/net/netChksum.c:    /* Fold 32-bit sum into 16 bits */
network/net/netDown.c:    NET_TRACE("Stopping netif %u on device %d", netptr - netiftab, descrp);
network/net/netDown.c:        kill(netptr->recvthr[i]);
network/net/netDown.c:    netptr->state = NET_FREE;
network/net/netGetbuf.c:    pkt->nif = NULL;
network/net/netGetbuf.c:    pkt->len = 0;
network/net/netGetbuf.c:    pkt->curr = pkt->data + NET_MAX_PKTLEN;
network/net/netRecv.c:    maxlen = netptr->linkhdrlen + netptr->mtu;
network/net/netRecv.c:        len = read(netptr->dev, pkt->data, maxlen);
network/net/netRecv.c:        pkt->len = len;
network/net/netRecv.c:        pkt->curr = pkt->data;
network/net/netRecv.c:        pkt->nif = netptr;
network/net/netRecv.c:        netptr->nin++;
network/net/netRecv.c:        pkt->linkhdr = pkt->curr;
network/net/netRecv.c:        ether = (struct etherPkt *)pkt->curr;
network/net/netRecv.c:        if (netptr->capture != NULL)
network/net/netRecv.c:            snoopCapture(netptr->capture, pkt);
network/net/netRecv.c:        memcpy(dst.addr, ether->dst, ETH_ADDR_LEN);
network/net/netRecv.c:        NET_TRACE("Read packet len %d", pkt->len);
network/net/netRecv.c:        NET_TRACE("\tPacket proto 0x%04X", net2hs(ether->type));
network/net/netRecv.c:        if ((netaddrequal(&dst, &netptr->hwaddr))
network/net/netRecv.c:            || (netaddrequal(&dst, &netptr->hwbrc)))
network/net/netRecv.c:            pkt->curr = pkt->data + netptr->linkhdrlen;
network/net/netRecv.c:            switch (net2hs(ether->type))
network/net/netRecv.c:                netptr->nproc++;
network/net/netRecv.c:                netptr->nproc++;
network/net/netSend.c: * Appends the Link-Level header to a packet and writes to the 
network/net/netSend.c:    netptr = pkt->nif;
network/net/netSend.c:    if ((NULL == netptr) || (netptr->state != NET_ALLOC))
network/net/netSend.c:    /* Make space for Link-Level header */
network/net/netSend.c:    pkt->curr -= netptr->linkhdrlen;
network/net/netSend.c:    pkt->len += netptr->linkhdrlen;
network/net/netSend.c:    ether = (struct etherPkt *)(pkt->curr);
network/net/netSend.c:    ether->type = hs2net(type);
network/net/netSend.c:    memcpy(ether->src, netptr->hwaddr.addr, netptr->hwaddr.len);
network/net/netSend.c:    netaddrsprintf(str, &netptr->hwaddr);
network/net/netSend.c:    /* Copy destination hardware address into link-level header */
network/net/netSend.c:    memcpy(ether->dst, hwaddr->addr, hwaddr->len);
network/net/netSend.c:    if (pkt->len != write(netptr->dev, pkt->curr, pkt->len))
network/net/netSend.c:    if (netptr->capture != NULL)
network/net/netSend.c:        snoopCapture(netptr->capture, pkt);
network/net/netUp.c:    if (ip->len > NET_MAX_ALEN || mask->len > NET_MAX_ALEN ||
network/net/netUp.c:        (NULL != gateway && gateway->len > NET_MAX_ALEN))
network/net/netUp.c:    netptr->dev = descrp;
network/net/netUp.c:    netptr->state = NET_ALLOC;
network/net/netUp.c:    netptr->mtu = control(descrp, NET_GET_MTU, 0, 0);
network/net/netUp.c:    netptr->linkhdrlen = control(descrp, NET_GET_LINKHDRLEN, 0, 0);
network/net/netUp.c:    if (SYSERR == netptr->mtu || SYSERR == netptr->linkhdrlen)
network/net/netUp.c:         control(descrp, NET_GET_HWADDR, (long)&netptr->hwaddr, 0))
network/net/netUp.c:            control(descrp, NET_GET_HWBRC, (long)&netptr->hwbrc, 0)))
network/net/netUp.c:    netaddrcpy(&netptr->ip, ip);
network/net/netUp.c:    netaddrcpy(&netptr->mask, mask);
network/net/netUp.c:        netaddrcpy(&netptr->gateway, gateway);
network/net/netUp.c:    netptr->ipbrc.type = netptr->ip.type;
network/net/netUp.c:    netptr->ipbrc.len = netptr->ip.len;
network/net/netUp.c:    for (i = 0; i < netptr->ip.len; i++)
network/net/netUp.c:        netptr->ipbrc.addr[i] = netptr->ip.addr[i] & netptr->mask.addr[i];
network/net/netUp.c:        netptr->ipbrc.addr[i] |= ~netptr->mask.addr[i];
network/net/netUp.c:    netaddrsprintf(str, &netptr->ip);
network/net/netUp.c:    netaddrsprintf(str, &netptr->mask);
network/net/netUp.c:    netaddrsprintf(str, &netptr->gateway);
network/net/netUp.c:    netaddrsprintf(str, &netptr->hwaddr);
network/net/netUp.c:    netaddrsprintf(str, &netptr->hwbrc);
network/net/netUp.c:              netptr->mtu, netptr->linkhdrlen);
network/net/netUp.c:    rtAdd(&netptr->ip, NULL, &netptr->mask, netptr);
network/net/netUp.c:        rtDefault(&netptr->gateway, netptr);
network/net/netUp.c:        netptr->recvthr[i] = tid;
network/net/netUp.c:        kill(netptr->recvthr[i]);
network/net/netUp.c:    netptr->state = NET_FREE;
Binary file network/net/netFreebuf.o matches
Binary file network/net/netChksum.o matches
Binary file network/net/netDown.o matches
network/net/netDown.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
network/net/netDown.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/network.h \
network/net/netDown.d:../system/platforms/arm-rpi3/interrupt.h:
network/net/netDown.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/net/netGetbuf.o matches
Binary file network/net/netInit.o matches
network/net/netInit.d: ../system/platforms/arm-rpi3/interrupt.h \
network/net/netInit.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/net/netInit.d:../system/platforms/arm-rpi3/interrupt.h:
network/net/netInit.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/net/netLookup.o matches
Binary file network/net/netRecv.o matches
network/net/netRecv.d: ../system/platforms/arm-rpi3/interrupt.h \
network/net/netRecv.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/net/netRecv.d:../system/platforms/arm-rpi3/interrupt.h:
network/net/netRecv.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/net/netSend.o matches
network/net/netSend.d: ../system/platforms/arm-rpi3/interrupt.h \
network/net/netSend.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/net/netSend.d:../system/platforms/arm-rpi3/interrupt.h:
network/net/netSend.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/net/netUp.o matches
network/net/netUp.d: ../system/platforms/arm-rpi3/interrupt.h \
network/net/netUp.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/network.h \
network/net/netUp.d:../system/platforms/arm-rpi3/interrupt.h:
network/net/netUp.d:../system/platforms/arm-rpi3/bcm2837.h:
network/netaddr/netaddrequal.c:    return (a->type == b->type &&
network/netaddr/netaddrequal.c:            a->len == b->len &&
network/netaddr/netaddrequal.c:            0 == memcmp(a->addr, b->addr, a->len));
network/netaddr/netaddrhost.c:    if (a->type != mask->type || a->len != mask->len)
network/netaddr/netaddrhost.c:    for (i = 0; i < a->len; i++)
network/netaddr/netaddrhost.c:        a->addr[i] &= ~mask->addr[i];
network/netaddr/netaddrmask.c:    if (a->type != mask->type || a->len != mask->len)
network/netaddr/netaddrmask.c:    for (i = 0; i < a->len; i++)
network/netaddr/netaddrmask.c:        a->addr[i] &= mask->addr[i];
network/netaddr/netaddrsprintf.c: * Format a network address and place in a null-terminated string.
network/netaddr/netaddrsprintf.c:    switch (addr->type)
network/netaddr/netaddrsprintf.c:                addr->addr[0], addr->addr[1], addr->addr[2],
network/netaddr/netaddrsprintf.c:                addr->addr[3], addr->addr[4], addr->addr[5]);
network/netaddr/netaddrsprintf.c:                addr->addr[0], addr->addr[1], addr->addr[2],
network/netaddr/netaddrsprintf.c:                addr->addr[3]);
Binary file network/netaddr/netaddrsprintf.o matches
network/netaddr/netaddrsprintf.d: ../system/platforms/arm-rpi3/interrupt.h \
network/netaddr/netaddrsprintf.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
network/netaddr/netaddrsprintf.d:../system/platforms/arm-rpi3/interrupt.h:
network/netaddr/netaddrsprintf.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/netaddr/netaddrequal.o matches
Binary file network/netaddr/netaddrhost.o matches
Binary file network/netaddr/netaddrmask.o matches
network/route/rtAdd.c:    RT_TRACE("Dest = %d.%d.%d.%d", dst->addr[0], dst->addr[1],
network/route/rtAdd.c:             dst->addr[2], dst->addr[3]);
network/route/rtAdd.c:    RT_TRACE("Mask = %d.%d.%d.%d", mask->addr[0], mask->addr[1],
network/route/rtAdd.c:             mask->addr[2], mask->addr[3]);
network/route/rtAdd.c:        RT_TRACE("Gate = %d.%d.%d.%d", gate->addr[0], gate->addr[1],
network/route/rtAdd.c:                 gate->addr[2], gate->addr[3]);
network/route/rtAdd.c:    RT_TRACE("nif = %d", nif - netiftab);
network/route/rtAdd.c:    netaddrcpy(&rtptr->dst, dst);
network/route/rtAdd.c:    netaddrmask(&rtptr->dst, mask);
network/route/rtAdd.c:        rtptr->gateway.type = NULL;
network/route/rtAdd.c:        netaddrcpy(&rtptr->gateway, gate);
network/route/rtAdd.c:    netaddrcpy(&rtptr->mask, mask);
network/route/rtAdd.c:    rtptr->nif = nif;
network/route/rtAdd.c:    for (i = 0; i < mask->len; i++)
network/route/rtAdd.c:        octet = mask->addr[i];
network/route/rtAdd.c:        // This totals non-zero bits
network/route/rtAdd.c:    rtptr->masklen = length;
network/route/rtAdd.c:    rtptr->state = RT_USED;
network/route/rtDefault.c:    if ((NULL == gate) || (NULL == nif) || (gate->len > NET_MAX_ALEN))
network/route/rtDefault.c:    mask.type = gate->type;
network/route/rtDefault.c:    mask.len = gate->len;
network/route/rtDefault.c:    netaddrcpy(&rtptr->dst, &mask);
network/route/rtDefault.c:    netaddrcpy(&rtptr->gateway, gate);
network/route/rtDefault.c:    netaddrcpy(&rtptr->mask, &mask);
network/route/rtDefault.c:    rtptr->nif = nif;
network/route/rtDefault.c:    rtptr->masklen = 0;
network/route/rtDefault.c:    rtptr->state = RT_USED;
network/route/rtLookup.c:    RT_TRACE("Addr = %d.%d.%d.%d", addr->addr[0], addr->addr[1],
network/route/rtLookup.c:             addr->addr[2], addr->addr[3]);
network/route/rtLookup.c:                    || (rtptr->masklen < rttab[i].masklen))
network/route/rtSend.c:    ip = (struct ipv4Pkt *)pkt->nethdr;
network/route/rtSend.c:    memcpy(dst.addr, ip->dst, dst.len);
network/route/rtSend.c:    if (route->nif == pkt->nif)
network/route/rtSend.c:        if (NULL == route->gateway.type)
network/route/rtSend.c:    ip->ttl--;
network/route/rtSend.c:    if (0 == ip->ttl)
network/route/rtSend.c:        // 11 - Time Exceeded
network/route/rtSend.c:    ip->chksum = 0;
network/route/rtSend.c:    ip->chksum = netChksum((uchar *)ip, IPv4_HDR_LEN);
network/route/rtSend.c:    pkt->nif = route->nif;
network/route/rtSend.c:    if (NULL == route->gateway.type)
network/route/rtSend.c:        nxthop = &route->gateway;
Binary file network/route/rtAlloc.o matches
network/route/rtAlloc.d: ../include/stddef.h ../system/platforms/arm-rpi3/interrupt.h \
network/route/rtAlloc.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/route.h \
network/route/rtAlloc.d:../system/platforms/arm-rpi3/interrupt.h:
network/route/rtAlloc.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/route/rtAdd.o matches
Binary file network/route/rtClear.o matches
network/route/rtClear.d: ../include/stddef.h ../system/platforms/arm-rpi3/interrupt.h \
network/route/rtClear.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/network.h \
network/route/rtClear.d:../system/platforms/arm-rpi3/interrupt.h:
network/route/rtClear.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/route/rtDaemon.o matches
network/route/rtDaemon.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
network/route/rtDaemon.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/route/rtDaemon.d:../system/platforms/arm-rpi3/interrupt.h:
network/route/rtDaemon.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/route/rtDefault.o matches
Binary file network/route/rtInit.o matches
network/route/rtInit.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
network/route/rtInit.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/route/rtInit.d:../system/platforms/arm-rpi3/interrupt.h:
network/route/rtInit.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/route/rtLookup.o matches
network/route/rtLookup.d: ../include/stddef.h ../system/platforms/arm-rpi3/interrupt.h \
network/route/rtLookup.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/network.h \
network/route/rtLookup.d:../system/platforms/arm-rpi3/interrupt.h:
network/route/rtLookup.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/route/rtRecv.o matches
network/route/rtRecv.d: ../system/platforms/arm-rpi3/interrupt.h \
network/route/rtRecv.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/mailbox.h \
network/route/rtRecv.d:../system/platforms/arm-rpi3/interrupt.h:
network/route/rtRecv.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/route/rtRemove.o matches
network/route/rtRemove.d: ../include/stddef.h ../system/platforms/arm-rpi3/interrupt.h \
network/route/rtRemove.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/network.h \
network/route/rtRemove.d:../system/platforms/arm-rpi3/interrupt.h:
network/route/rtRemove.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/route/rtSend.o matches
network/snoop/snoopCapture.c:    cap->ncap++;
network/snoop/snoopCapture.c:    cap->nmatch++;
network/snoop/snoopCapture.c:    len = pkt->len;
network/snoop/snoopCapture.c:    if (len > cap->caplen)
network/snoop/snoopCapture.c:        len = cap->caplen;
network/snoop/snoopCapture.c:    memcpy(buf->data, pkt->curr, len);
network/snoop/snoopCapture.c:    buf->curr = buf->data;
network/snoop/snoopCapture.c:    if (mailboxCount(cap->queue) >= SNOOP_QLEN)
network/snoop/snoopCapture.c:        cap->novrn++;
network/snoop/snoopCapture.c:    if (SYSERR == mailboxSend(cap->queue, (int)buf))
network/snoop/snoopClose.c:    while (mailboxCount(cap->queue) > 0)
network/snoop/snoopClose.c:        pkt = (struct packet *)mailboxReceive(cap->queue);
network/snoop/snoopClose.c:    if (SYSERR == mailboxFree(cap->queue))
network/snoop/snoopFilter.c:    if ((NULL == s->type)
network/snoop/snoopFilter.c:        && (NULL == s->srcaddr.type) && (NULL == s->srcport)
network/snoop/snoopFilter.c:        && (NULL == s->dstaddr.type) && (NULL == s->dstport))
network/snoop/snoopFilter.c:    if (pkt->len < ETH_HDR_LEN)
network/snoop/snoopFilter.c:        ether = (struct etherPkt *)pkt->curr;
network/snoop/snoopFilter.c:        switch (net2hs(ether->type))
network/snoop/snoopFilter.c:            if (pkt->len < (ETH_HDR_LEN + ARP_CONST_HDR_LEN))
network/snoop/snoopFilter.c:            arp = (struct arpPkt *)ether->data;
network/snoop/snoopFilter.c:            if (pkt->len < (ETH_HDR_LEN + ARP_CONST_HDR_LEN +
network/snoop/snoopFilter.c:                            (2 * arp->hwalen) + (2 * arp->pralen)))
network/snoop/snoopFilter.c:            if (pkt->len < (ETH_HDR_LEN + IPv4_HDR_LEN))
network/snoop/snoopFilter.c:            ip = (struct ipv4Pkt *)ether->data;
network/snoop/snoopFilter.c:    if (s->type != NULL)
network/snoop/snoopFilter.c:        switch (net2hs(ether->type))
network/snoop/snoopFilter.c:            if (s->type != SNOOP_FILTER_ARP)
network/snoop/snoopFilter.c:            if (s->type != SNOOP_FILTER_IPv4)
network/snoop/snoopFilter.c:                switch (ip->proto)
network/snoop/snoopFilter.c:                    if (s->type != SNOOP_FILTER_UDP)
network/snoop/snoopFilter.c:                    if (s->type != SNOOP_FILTER_TCP)
network/snoop/snoopFilter.c:                    if (s->type != SNOOP_FILTER_ICMP)
network/snoop/snoopFilter.c:    if (s->srcaddr.type != NULL)
network/snoop/snoopFilter.c:            if ((s->srcaddr.len != arp->pralen)
network/snoop/snoopFilter.c:                || (0 != memcmp(&arp->addrs[ARP_ADDR_SPA(arp)],
network/snoop/snoopFilter.c:                                s->srcaddr.addr, arp->pralen)))
network/snoop/snoopFilter.c:            if ((s->srcaddr.len != IPv4_ADDR_LEN)
network/snoop/snoopFilter.c:                || (0 != memcmp(ip->src, s->srcaddr.addr, IPv4_ADDR_LEN)))
network/snoop/snoopFilter.c:    if (s->dstaddr.type != NULL)
network/snoop/snoopFilter.c:            if ((s->dstaddr.len != arp->pralen)
network/snoop/snoopFilter.c:                || (0 != memcmp(&arp->addrs[ARP_ADDR_DPA(arp)],
network/snoop/snoopFilter.c:                                s->dstaddr.addr, arp->pralen)))
network/snoop/snoopFilter.c:            if ((s->dstaddr.len != IPv4_ADDR_LEN)
network/snoop/snoopFilter.c:                || (0 != memcmp(ip->dst, s->dstaddr.addr, IPv4_ADDR_LEN)))
network/snoop/snoopFilter.c:    if ((s->srcport != NULL) || (s->dstport != NULL))
network/snoop/snoopFilter.c:        switch (ip->proto)
network/snoop/snoopOpen.c: * @pre-condition filter settings should already be setup in cap
network/snoop/snoopOpen.c:    cap->ncap = 0;
network/snoop/snoopOpen.c:    cap->nmatch = 0;
network/snoop/snoopOpen.c:    cap->novrn = 0;
network/snoop/snoopOpen.c:    cap->queue = mailboxAlloc(SNOOP_QLEN);
network/snoop/snoopOpen.c:    if (SYSERR == (int)cap->queue)
network/snoop/snoopOpen.c:            mailboxFree(cap->queue);
network/snoop/snoopOpen.c:        mailboxFree(cap->queue);
network/snoop/snoopOpen.c:    mailboxFree(cap->queue);
network/snoop/snoopPrint.c:    ether = (struct etherPkt *)pkt->curr;
network/snoop/snoopPrint.c:    switch (net2hs(ether->type))
network/snoop/snoopPrint.c:        arp = (struct arpPkt *)ether->data;
network/snoop/snoopPrint.c:        addr.type = net2hs(arp->prtype);
network/snoop/snoopPrint.c:        addr.len = arp->pralen;
network/snoop/snoopPrint.c:        memcpy(addr.addr, &arp->addrs[ARP_ADDR_DPA(arp)], addr.len);
network/snoop/snoopPrint.c:        memcpy(addr.addr, &arp->addrs[ARP_ADDR_SPA(arp)], addr.len);
network/snoop/snoopPrint.c:        addr.type = net2hs(arp->hwtype);
network/snoop/snoopPrint.c:        addr.len = arp->hwalen;
network/snoop/snoopPrint.c:        memcpy(addr.addr, &arp->addrs[ARP_ADDR_SHA(arp)], addr.len);
network/snoop/snoopPrint.c:        switch (net2hs(arp->op))
network/snoop/snoopPrint.c:            printf("arp who-has %s tell %s", strA, strB);
network/snoop/snoopPrint.c:            printf("arp reply %s is-at %s", strA, strC);
network/snoop/snoopPrint.c:        ip = (struct ipv4Pkt *)ether->data;
network/snoop/snoopPrint.c:        memcpy(addr.addr, ip->dst, addr.len);
network/snoop/snoopPrint.c:        memcpy(addr.addr, ip->src, addr.len);
network/snoop/snoopPrint.c:        switch (ip->proto)
network/snoop/snoopPrint.c:        switch (net2hs(ether->type))
network/snoop/snoopPrint.c:            appHdr = (uchar *)ip + ((ip->ver_ihl & IPv4_IHL) * 4);
network/snoop/snoopPrint.c:            switch (ip->proto)
network/snoop/snoopPrint.c:        for (i = 0; i < pkt->len; i += 16)
network/snoop/snoopPrint.c:                if (j >= pkt->len)
network/snoop/snoopPrint.c:                printf("%02X", pkt->data[j]);
network/snoop/snoopPrint.c:                for (j = i; (j < i + 16 && j < pkt->len); j++)
network/snoop/snoopPrint.c:                    ch = pkt->data[j];
network/snoop/snoopPrintArp.c:        printf(" ----- ARP Header -----\n");
network/snoop/snoopPrintArp.c:            switch (net2hs(arp->hwtype))
network/snoop/snoopPrintArp.c:                sprintf(output, "0x%04X", net2hs(arp->hwtype));
network/snoop/snoopPrintArp.c:            printf("  Hw type: %-14s ", output);
network/snoop/snoopPrintArp.c:            switch (net2hs(arp->prtype))
network/snoop/snoopPrintArp.c:                sprintf(output, "0x%04X", net2hs(arp->prtype));
network/snoop/snoopPrintArp.c:            printf("Proto type: %-11s\n", output);
network/snoop/snoopPrintArp.c:            sprintf(output, "%d bytes", arp->hwalen);
network/snoop/snoopPrintArp.c:            printf("  Hw len: %-15s ", output);
network/snoop/snoopPrintArp.c:            sprintf(output, "%d bytes", arp->pralen);
network/snoop/snoopPrintArp.c:            printf("Proto len: %-12s ", output);
network/snoop/snoopPrintArp.c:        switch (net2hs(arp->op))
network/snoop/snoopPrintArp.c:            sprintf(output, "0x%04X", net2hs(arp->op));
network/snoop/snoopPrintArp.c:        printf("Operation: %-12s\n", output);
network/snoop/snoopPrintArp.c:        hwaddr.type = net2hs(arp->hwtype);
network/snoop/snoopPrintArp.c:        hwaddr.len = arp->hwalen;
network/snoop/snoopPrintArp.c:        memcpy(hwaddr.addr, &arp->addrs[ARP_ADDR_SHA(arp)], hwaddr.len);
network/snoop/snoopPrintArp.c:        printf("  Src hw addr: %-22s ", output);
network/snoop/snoopPrintArp.c:        praddr.type = net2hs(arp->prtype);
network/snoop/snoopPrintArp.c:        praddr.len = arp->pralen;
network/snoop/snoopPrintArp.c:        memcpy(praddr.addr, &arp->addrs[ARP_ADDR_SPA(arp)], praddr.len);
network/snoop/snoopPrintArp.c:        printf("Src proto addr: %-19s\n", output);
network/snoop/snoopPrintArp.c:        memcpy(hwaddr.addr, &arp->addrs[ARP_ADDR_DHA(arp)], hwaddr.len);
network/snoop/snoopPrintArp.c:        printf("  Dst hw addr: %-22s ", output);
network/snoop/snoopPrintArp.c:        memcpy(praddr.addr, &arp->addrs[ARP_ADDR_DPA(arp)], praddr.len);
network/snoop/snoopPrintArp.c:        printf("Dst proto addr: %-19s\n", output);
network/snoop/snoopPrintEthernet.c:        printf(" ----- Ethernet Header -----\n");
network/snoop/snoopPrintEthernet.c:        memcpy(hwaddr.addr, ether->dst, hwaddr.len);
network/snoop/snoopPrintEthernet.c:        printf("  Dst: %-25s ", output);
network/snoop/snoopPrintEthernet.c:        memcpy(hwaddr.addr, ether->src, hwaddr.len);
network/snoop/snoopPrintEthernet.c:        printf("Src: %-25s ", output);
network/snoop/snoopPrintEthernet.c:        switch (net2hs(ether->type))
network/snoop/snoopPrintEthernet.c:            sprintf(output, "0x%04X", net2hs(ether->type));
network/snoop/snoopPrintEthernet.c:        printf("Type: %-5s\n", output);
network/snoop/snoopPrintIpv4.c:        printf(" ----- IPv4 Header -----\n");
network/snoop/snoopPrintIpv4.c:            printf("  Version: %-14d ", (ip->ver_ihl & IPv4_VER) >> 4);
network/snoop/snoopPrintIpv4.c:        sprintf(output, "%d bytes", ((ip->ver_ihl & IPv4_IHL) * 4));
network/snoop/snoopPrintIpv4.c:        printf("Header len: %-11s ", output);
network/snoop/snoopPrintIpv4.c:            switch (ip->tos)
network/snoop/snoopPrintIpv4.c:                sprintf(output, "0x%08X", ip->tos);
network/snoop/snoopPrintIpv4.c:            printf("Service: %-14s\n", output);
network/snoop/snoopPrintIpv4.c:        sprintf(output, "%u bytes", net2hs(ip->len));
network/snoop/snoopPrintIpv4.c:        printf("  Total len: %-12s ", output);
network/snoop/snoopPrintIpv4.c:            printf("Identification: %-7u ", net2hs(ip->id));
network/snoop/snoopPrintIpv4.c:            sprintf(output, "0x%03X", net2hs(ip->flags_froff) >> 13);
network/snoop/snoopPrintIpv4.c:            printf("Flags: %-16s\n", output);
network/snoop/snoopPrintIpv4.c:                    (net2hs(ip->flags_froff) & IPv4_FROFF));
network/snoop/snoopPrintIpv4.c:            printf("  Frag offset: %-10s ", output);
network/snoop/snoopPrintIpv4.c:            sprintf(output, "%d hops", ip->ttl);
network/snoop/snoopPrintIpv4.c:            printf("Time to Live: %-9s ", output);
network/snoop/snoopPrintIpv4.c:        switch (ip->proto)
network/snoop/snoopPrintIpv4.c:            sprintf(output, "%d", ip->proto);
network/snoop/snoopPrintIpv4.c:        printf("Protocol: %-13s\n", output);
network/snoop/snoopPrintIpv4.c:            /*      printf("  Header checksum: 0x%04X ", net2hs(ip->chksm));
network/snoop/snoopPrintIpv4.c:               temp = ip->chksm;
network/snoop/snoopPrintIpv4.c:               ip->chksm = 0;
network/snoop/snoopPrintIpv4.c:               ip->chksm = ipChecksum((uchar *)ip, (4 * (ip->ver_ihl & IPv4_IHL)));
network/snoop/snoopPrintIpv4.c:               if (ip->chksm == temp)
network/snoop/snoopPrintIpv4.c:               printf("(incorrect, correct: 0x%04X)\n", net2hs(ip->chksm));
network/snoop/snoopPrintIpv4.c:        memcpy(praddr.addr, ip->src, praddr.len);
network/snoop/snoopPrintIpv4.c:        printf("  Src addr: %-25s ", output);
network/snoop/snoopPrintIpv4.c:        memcpy(praddr.addr, ip->dst, praddr.len);
network/snoop/snoopPrintIpv4.c:        printf("Dst addr: %-25s\n", output);
network/snoop/snoopPrintTcp.c:        printf(" ----- TCP Header -----\n");
network/snoop/snoopPrintTcp.c:            snoopPrintTcpPort(net2hs(tcp->srcpt), descrp);
network/snoop/snoopPrintTcp.c:        sprintf(output, "%d %s", net2hs(tcp->srcpt), descrp);
network/snoop/snoopPrintTcp.c:        printf("  Src Port: %-25s ", output);
network/snoop/snoopPrintTcp.c:            snoopPrintTcpPort(net2hs(tcp->dstpt), descrp);
network/snoop/snoopPrintTcp.c:        sprintf(output, "%d %s", net2hs(tcp->dstpt), descrp);
network/snoop/snoopPrintTcp.c:        printf("Dst Port: %-25s\n", output);
network/snoop/snoopPrintTcp.c:        printf("  Seq Num: %-14u ", net2hl(tcp->seqnum));
network/snoop/snoopPrintTcp.c:        printf("Ack Num: %-14u ", net2hl(tcp->acknum));
network/snoop/snoopPrintTcp.c:        if (tcp->control & TCP_CTRL_URG)
network/snoop/snoopPrintTcp.c:        if (tcp->control & TCP_CTRL_ACK)
network/snoop/snoopPrintTcp.c:        if (tcp->control & TCP_CTRL_PSH)
network/snoop/snoopPrintTcp.c:        if (tcp->control & TCP_CTRL_RST)
network/snoop/snoopPrintTcp.c:        if (tcp->control & TCP_CTRL_SYN)
network/snoop/snoopPrintTcp.c:        if (tcp->control & TCP_CTRL_FIN)
network/snoop/snoopPrintTcp.c:            sprintf(output, "%d bytes", offset2octets(tcp->offset));
network/snoop/snoopPrintTcp.c:            printf("  Offset: %-15s ", output);
network/snoop/snoopPrintTcp.c:            sprintf(output, "%d bytes", net2hs(tcp->window));
network/snoop/snoopPrintTcp.c:            printf("Window: %-15s ", output);
network/snoop/snoopPrintTcp.c:            printf("Chksum: 0x%04X\n", net2hs(tcp->chksum));
network/snoop/snoopPrintUdp.c:        printf(" ----- UDP Header -----\n");
network/snoop/snoopPrintUdp.c:            snoopPrintUdpPort(net2hs(udp->srcPort), descrp);
network/snoop/snoopPrintUdp.c:        sprintf(output, "%d %s", net2hs(udp->srcPort), descrp);
network/snoop/snoopPrintUdp.c:        printf("  Src Port: %-25s ", output);
network/snoop/snoopPrintUdp.c:            snoopPrintUdpPort(net2hs(udp->dstPort), descrp);
network/snoop/snoopPrintUdp.c:        sprintf(output, "%d %s", net2hs(udp->dstPort), descrp);
network/snoop/snoopPrintUdp.c:        printf("Dst Port: %-25s\n", output);
network/snoop/snoopPrintUdp.c:            sprintf(output, "%d bytes", net2hs(udp->len));
network/snoop/snoopPrintUdp.c:            printf("  Message length: %-19s ", output);
network/snoop/snoopPrintUdp.c:            printf("Checksum: 0x%04X\n", net2hs(udp->chksum));
network/snoop/snoopPrintUdp.c:               pseudohdr[2] = net2hs(udp->len);
network/snoop/snoopRead.c:    pkt = (struct packet *)mailboxReceive(cap->queue);
network/snoop/snoopdhcp.c:	fprintf(stdout,"DHCP:\t----- DHCP Header -----\n");
network/snoop/snoopdhcp.c:	fprintf(stdout,"DHCP:\tOperation = %d ", dhcp->op);
network/snoop/snoopdhcp.c:	switch(dhcp->op)
network/snoop/snoopdhcp.c:	fprintf(stdout,"DHCP:\tHardware type = 0x%04x ", dhcp->htype);
network/snoop/snoopdhcp.c:	switch(dhcp->htype)
network/snoop/snoopdhcp.c:	fprintf(stdout,"DHCP:\tHardware length = %d bytes\n", dhcp->hlen);
network/snoop/snoopdhcp.c:	fprintf(stdout,"DHCP:\tHops = %d\n", dhcp->hops);
network/snoop/snoopdhcp.c:	fprintf(stdout,"DHCP:\tTransfer id = %d\n", net2hl(dhcp->xid));
network/snoop/snoopdhcp.c:	fprintf(stdout,"DHCP:\tSeconds = %d\n", net2hs(dhcp->secs));
network/snoop/snoopdhcp.c:	fprintf(stdout,"DHCP:\tFlags = 0x%04x ", net2hs(dhcp->flags));
network/snoop/snoopdhcp.c:	switch(net2hs(dhcp->flags))
network/snoop/snoopdhcp.c:	fprint_iplong(net2hl(dhcp->ciaddr));
network/snoop/snoopdhcp.c:	fprint_iplong(net2hl(dhcp->yiaddr));
network/snoop/snoopdhcp.c:	fprint_iplong(net2hl(dhcp->siaddr));
network/snoop/snoopdhcp.c:	fprint_iplong(net2hl(dhcp->giaddr));
network/snoop/snoopdhcp.c:	fprint_mac(dhcp->chaddr);
network/snoop/snoopdhcp.c:	while (NULL != dhcp->sname[i])
network/snoop/snoopdhcp.c:		fprintf(stdout,"%c", dhcp->sname[i]);
network/snoop/snoopdhcp.c:	fprintf(stdout,"DHCP:\tFile = 0x%x\n", dhcp->file);
network/snoop/snoopdhcp.c:	opts = dhcp->opts;
network/snoop/snoopdhcp.c:			len--;
network/snoop/snoopdhcp.c:				len--;
network/snoop/snoopdhcp.c:			len--;
network/snoop/snoopdhcp.c:					len--;
network/snoop/snoopdhcp.c:				len--;
network/snoop/snoopdhcp.c:			len--;
network/snoop/snoopdhcp.c:					len--;
network/snoop/snoopdhcp.c:				len--;
network/snoop/snoopdhcp.c:			len--;
network/snoop/snoopdhcp.c:				len--;
network/snoop/snoopdhcp.c:			len--;
network/snoop/snoopdhcp.c:				len--;
network/snoop/snoopdhcp.c:			len--;
network/snoop/snoopdhcp.c:				len--;
network/snoop/snoopdhcp.c:			len--;
network/snoop/snoopdhcp.c:				len--;
network/snoop/snoopdhcp.c:				len--;
network/snoop/snoopdns.c:	fprintf(stdout,"DNS:\t----- DNS Header -----\n");
network/snoop/snoopdns.c:	fprintf(stdout,"DNS\tID = %d\n", net2hs(dns->id));
network/snoop/snoopdns.c:	fprintf(stdout,"DNS:\tQR = %d ", (dns->opts1 & DNS_QR) >> 7);
network/snoop/snoopdns.c:	switch((dns->opts1 & DNS_QR) >> 7)
network/snoop/snoopdns.c:	fprintf(stdout,"DNS:\tOpcode = %d ", (dns->opts1 & DNS_OPCODE) >> 3);
network/snoop/snoopdns.c:	switch((dns->opts1 & DNS_OPCODE) >> 3)
network/snoop/snoopdns.c:				(dns->opts1 & DNS_AA) >> 2);
network/snoop/snoopdns.c:	fprintf(stdout,"DNS:\tTruncation = %d\n", (dns->opts1 & DNS_TC) >> 1);
network/snoop/snoopdns.c:	fprintf(stdout,"DNS:\tRecursion Desired = %d\n", (dns->opts1 & DNS_RD));
network/snoop/snoopdns.c:				(dns->opts2 & DNS_RA) >> 7);
network/snoop/snoopdns.c:	fprintf(stdout,"DNS:\tResponse Code = %d ", dns->opts2 & DNS_RCODE);
network/snoop/snoopdns.c:	switch(dns->opts2 & DNS_RCODE)
network/snoop/snoopdns.c:				net2hs(dns->qdcount));
network/snoop/snoopdns.c:				net2hs(dns->ancount));
network/snoop/snoopdns.c:				net2hs(dns->nscount));
network/snoop/snoopdns.c:				net2hs(dns->arcount));
network/snoop/snoopdns.c:	ptr = dns->data;
network/snoop/snoopdns.c:	numbofsect = net2hs(dns->qdcount);
network/snoop/snoopdns.c:		fprintf(stdout,"DNS:\t----- DNS Question Section %d -----\n", 
network/snoop/snoopdns.c:				count--;
network/snoop/snoopdns.c:		numbofsect--;
network/snoop/snoopdns.c:	numbofsect = net2hs(dns->ancount);
network/snoop/snoopdns.c:		fprintf(stdout,"DNS:\t----- DNS Answer Section %d -----\n", 
network/snoop/snoopdns.c:				count--;
network/snoop/snoopdns.c:					count--;
network/snoop/snoopdns.c:					count--;
network/snoop/snoopdns.c:		numbofsect--;
network/snoop/snoopdns.c:	numbofsect = net2hs(dns->nscount);
network/snoop/snoopdns.c:		fprintf(stdout,"DNS:\t----- DNS Name Server Section %d -----\n", 
network/snoop/snoopdns.c:				count--;
network/snoop/snoopdns.c:					count--;
network/snoop/snoopdns.c:					count--;
network/snoop/snoopdns.c:		numbofsect--;
network/snoop/snoopdns.c:	numbofsect = net2hs(dns->arcount);
network/snoop/snoopdns.c:		numbofsect--;
network/snoop/snoopicmp.c:	fprintf(stdout,"ICMP:\t----- ICMP Header -----\n");
network/snoop/snoopicmp.c:	fprintf(stdout,"ICMP:\ttype = 0x%04X ", icmp->type);
network/snoop/snoopicmp.c:	switch(icmp->type)
network/snoop/snoopicmp.c:		fprintf(stdout, "ICMP:\tcode = 0x%04X\n", icmp->code);
network/snoop/snoopicmp.c:		fprintf(stdout,"ICMP:\tchecksum = 0x%04X ", net2hs(icmp->chksm));
network/snoop/snoopicmp.c:		temp = icmp->chksm;
network/snoop/snoopicmp.c:		icmp->chksm = 0;
network/snoop/snoopicmp.c:		icmp->chksm = ipChecksum((uchar *)icmp, len);
network/snoop/snoopicmp.c:		if(icmp->chksm == temp)
network/snoop/snoopicmp.c:											net2hs(icmp->chksm)); }
network/snoop/snoopicmp.c:					net2hs(icmp->id));
network/snoop/snoopicmp.c:					net2hs(icmp->sequence));
network/snoop/snoopicmp.c:		fprintf(stdout, "ICMP:\tcode = 0x%04X ", icmp->code);
network/snoop/snoopicmp.c:		switch(icmp->code)
network/snoop/snoopicmp.c:		fprintf(stdout,"ICMP:\tchecksum = 0x%04X ", net2hs(icmp->chksm));
network/snoop/snoopicmp.c:		temp = icmp->chksm;
network/snoop/snoopicmp.c:		icmp->chksm = 0;
network/snoop/snoopicmp.c:		icmp->chksm = ipChecksum((uchar *)icmp, len);
network/snoop/snoopicmp.c:		if(icmp->chksm == temp)
network/snoop/snoopicmp.c:											net2hs(icmp->chksm)); }
network/snoop/snoopicmp.c:		fprintf(stdout, "ICMP:\tcode = 0x%04X\n", icmp->code);
network/snoop/snoopicmp.c:		fprintf(stdout,"ICMP:\tchecksum = 0x%04X ", net2hs(icmp->chksm));
network/snoop/snoopicmp.c:		temp = icmp->chksm;
network/snoop/snoopicmp.c:		icmp->chksm = 0;
network/snoop/snoopicmp.c:		icmp->chksm = ipChecksum((uchar *)icmp, len);
network/snoop/snoopicmp.c:		if(icmp->chksm == temp)
network/snoop/snoopicmp.c:											net2hs(icmp->chksm)); }
network/snoop/snoopicmp.c:		fprintf(stdout, "ICMP:\tcode = 0x%04X ", icmp->code);
network/snoop/snoopicmp.c:		switch(icmp->code)
network/snoop/snoopicmp.c:		fprintf(stdout,"ICMP:\tchecksum = 0x%04X ", net2hs(icmp->chksm));
network/snoop/snoopicmp.c:		temp = icmp->chksm;
network/snoop/snoopicmp.c:		icmp->chksm = 0;
network/snoop/snoopicmp.c:		icmp->chksm = ipChecksum((uchar *)icmp, len);
network/snoop/snoopicmp.c:		if(icmp->chksm == temp)
network/snoop/snoopicmp.c:											net2hs(icmp->chksm)); }
network/snoop/snoopicmp.c:		gateway = (net2hs(icmp->id) << 16) 
network/snoop/snoopicmp.c:					+ net2hs(icmp->sequence);
network/snoop/snoopicmp.c:		fprintf(stdout, "ICMP:\tcode = 0x%04X\n", icmp->code);
network/snoop/snoopicmp.c:		fprintf(stdout,"ICMP:\tchecksum = 0x%04X ", net2hs(icmp->chksm));
network/snoop/snoopicmp.c:		temp = icmp->chksm;
network/snoop/snoopicmp.c:		icmp->chksm = 0;
network/snoop/snoopicmp.c:		icmp->chksm = ipChecksum((uchar *)icmp, len);
network/snoop/snoopicmp.c:		if(icmp->chksm == temp)
network/snoop/snoopicmp.c:											net2hs(icmp->chksm)); }
network/snoop/snoopicmp.c:					net2hs(icmp->id));
network/snoop/snoopicmp.c:					net2hs(icmp->sequence));
network/snoop/snoopicmp.c:		fprintf(stdout, "ICMP:\tcode = 0x%04X ", icmp->code);
network/snoop/snoopicmp.c:		switch(icmp->code)
network/snoop/snoopicmp.c:		fprintf(stdout,"ICMP:\tchecksum = 0x%04X ", net2hs(icmp->chksm));
network/snoop/snoopicmp.c:		temp = icmp->chksm;
network/snoop/snoopicmp.c:		icmp->chksm = 0;
network/snoop/snoopicmp.c:		icmp->chksm = ipChecksum((uchar *)icmp, len);
network/snoop/snoopicmp.c:		if(icmp->chksm == temp)
network/snoop/snoopicmp.c:											net2hs(icmp->chksm)); }
network/snoop/snoopicmp.c:		fprintf(stdout, "ICMP:\tcode = 0x%04X ", icmp->code);
network/snoop/snoopicmp.c:		switch(icmp->code)
network/snoop/snoopicmp.c:		fprintf(stdout,"ICMP:\tchecksum = 0x%04X ", net2hs(icmp->chksm));
network/snoop/snoopicmp.c:		temp = icmp->chksm;
network/snoop/snoopicmp.c:		icmp->chksm = 0;
network/snoop/snoopicmp.c:		icmp->chksm = ipChecksum((uchar *)icmp, len);
network/snoop/snoopicmp.c:		if(icmp->chksm == temp)
network/snoop/snoopicmp.c:											net2hs(icmp->chksm)); }
network/snoop/snoopicmp.c:		fprintf(stdout, "ICMP:\tcode = 0x%04X\n", icmp->code);
network/snoop/snoopicmp.c:		fprintf(stdout,"ICMP:\tchecksum = 0x%04X ", net2hs(icmp->chksm));
network/snoop/snoopicmp.c:		temp = icmp->chksm;
network/snoop/snoopicmp.c:		icmp->chksm = 0;
network/snoop/snoopicmp.c:		icmp->chksm = ipChecksum((uchar *)icmp, len);
network/snoop/snoopicmp.c:		if(icmp->chksm == temp)
network/snoop/snoopicmp.c:											net2hs(icmp->chksm)); }
network/snoop/snoopicmp.c:					net2hs(icmp->id));
network/snoop/snoopicmp.c:					net2hs(icmp->sequence));
network/snoop/snoopicmp.c:					(icmp->data + count));
network/snoop/snoopicmp.c:					(icmp->data + count));
network/snoop/snoopicmp.c:					(icmp->data + count));
network/snoop/snoopicmp.c:		fprintf(stdout, "ICMP:\tcode = 0x%04X\n", icmp->code);
network/snoop/snoopicmp.c:		fprintf(stdout,"ICMP:\tchecksum = 0x%04X ", net2hs(icmp->chksm));
network/snoop/snoopicmp.c:		temp = icmp->chksm;
network/snoop/snoopicmp.c:		icmp->chksm = 0;
network/snoop/snoopicmp.c:		icmp->chksm = ipChecksum((uchar *)icmp, len);
network/snoop/snoopicmp.c:		if(icmp->chksm == temp)
network/snoop/snoopicmp.c:											net2hs(icmp->chksm)); }
network/snoop/snoopicmp.c:		fprintf(stdout, "ICMP:\tcode = 0x%04X\n", icmp->code);
network/snoop/snoopicmp.c:		fprintf(stdout,"ICMP:\tchecksum = 0x%04X ", net2hs(icmp->chksm));
network/snoop/snoopicmp.c:		temp = icmp->chksm;
network/snoop/snoopicmp.c:		icmp->chksm = 0;
network/snoop/snoopicmp.c:		icmp->chksm = ipChecksum((uchar *)icmp, len);
network/snoop/snoopicmp.c:		if(icmp->chksm == temp)
network/snoop/snoopicmp.c:											net2hs(icmp->chksm)); }
network/snoop/snoopicmp.c:					net2hs(icmp->id));
network/snoop/snoopicmp.c:					net2hs(icmp->sequence));
network/snoop/snoopicmp.c:		fprintf(stdout, "ICMP:\tcode = 0x%04X\n", icmp->code);
network/snoop/snoopicmp.c:		fprintf(stdout,"ICMP:\tchecksum = 0x%04X ", net2hs(icmp->chksm));
network/snoop/snoopicmp.c:		temp = icmp->chksm;
network/snoop/snoopicmp.c:		icmp->chksm = 0;
network/snoop/snoopicmp.c:		icmp->chksm = ipChecksum((uchar *)icmp, len);
network/snoop/snoopicmp.c:		if(icmp->chksm == temp)
network/snoop/snoopicmp.c:											net2hs(icmp->chksm)); }
network/snoop/snoopicmp.c:					net2hs(icmp->id));
network/snoop/snoopicmp.c:					net2hs(icmp->sequence));
network/snoop/snoopicmp.c:		fprintf(stdout, "ICMP:\tcode = 0x%04X ", icmp->code);
network/snoop/snoopicmp.c:		switch(icmp->code)
network/snoop/snoopicmp.c:		fprintf(stdout,"ICMP:\tchecksum = 0x%04X ", net2hs(icmp->chksm));
network/snoop/snoopicmp.c:		temp = icmp->chksm;
network/snoop/snoopicmp.c:		icmp->chksm = 0;
network/snoop/snoopicmp.c:		icmp->chksm = ipChecksum((uchar *)icmp, len);
network/snoop/snoopicmp.c:		if(icmp->chksm == temp)
network/snoop/snoopicmp.c:											net2hs(icmp->chksm)); }
Binary file network/snoop/snoopPrintEthernet.o matches
Binary file network/snoop/snoopPrintTcp.o matches
Binary file network/snoop/snoopCapture.o matches
network/snoop/snoopCapture.d: ../system/platforms/arm-rpi3/interrupt.h \
network/snoop/snoopCapture.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/snoop/snoopCapture.d:../system/platforms/arm-rpi3/interrupt.h:
network/snoop/snoopCapture.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/snoop/snoopClose.o matches
network/snoop/snoopClose.d: ../include/stddef.h ../system/platforms/arm-rpi3/interrupt.h \
network/snoop/snoopClose.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/network.h \
network/snoop/snoopClose.d:../system/platforms/arm-rpi3/interrupt.h:
network/snoop/snoopClose.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/snoop/snoopFilter.o matches
network/snoop/snoopFilter.d: ../system/platforms/arm-rpi3/interrupt.h \
network/snoop/snoopFilter.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/snoop/snoopFilter.d:../system/platforms/arm-rpi3/interrupt.h:
network/snoop/snoopFilter.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/snoop/snoopOpen.o matches
network/snoop/snoopOpen.d: ../system/platforms/arm-rpi3/interrupt.h \
network/snoop/snoopOpen.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/network.h \
network/snoop/snoopOpen.d:../system/platforms/arm-rpi3/interrupt.h:
network/snoop/snoopOpen.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/snoop/snoopPrint.o matches
network/snoop/snoopPrint.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
network/snoop/snoopPrint.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/snoop/snoopPrint.d:../system/platforms/arm-rpi3/interrupt.h:
network/snoop/snoopPrint.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/snoop/snoopPrintArp.o matches
network/snoop/snoopPrintArp.d: ../system/platforms/arm-rpi3/interrupt.h \
network/snoop/snoopPrintArp.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/snoop/snoopPrintArp.d:../system/platforms/arm-rpi3/interrupt.h:
network/snoop/snoopPrintArp.d:../system/platforms/arm-rpi3/bcm2837.h:
network/snoop/snoopPrintEthernet.d: ../system/platforms/arm-rpi3/interrupt.h \
network/snoop/snoopPrintEthernet.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/snoop/snoopPrintEthernet.d:../system/platforms/arm-rpi3/interrupt.h:
network/snoop/snoopPrintEthernet.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/snoop/snoopPrintIpv4.o matches
network/snoop/snoopPrintIpv4.d: ../system/platforms/arm-rpi3/interrupt.h \
network/snoop/snoopPrintIpv4.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/snoop/snoopPrintIpv4.d:../system/platforms/arm-rpi3/interrupt.h:
network/snoop/snoopPrintIpv4.d:../system/platforms/arm-rpi3/bcm2837.h:
network/snoop/snoopPrintTcp.d: ../system/platforms/arm-rpi3/interrupt.h \
network/snoop/snoopPrintTcp.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/snoop/snoopPrintTcp.d:../system/platforms/arm-rpi3/interrupt.h:
network/snoop/snoopPrintTcp.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/snoop/snoopPrintUdp.o matches
network/snoop/snoopPrintUdp.d: ../system/platforms/arm-rpi3/interrupt.h \
network/snoop/snoopPrintUdp.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/snoop/snoopPrintUdp.d:../system/platforms/arm-rpi3/interrupt.h:
network/snoop/snoopPrintUdp.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/snoop/snoopRead.o matches
network/snoop/snoopRead.d: ../system/platforms/arm-rpi3/interrupt.h \
network/snoop/snoopRead.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
network/snoop/snoopRead.d:../system/platforms/arm-rpi3/interrupt.h:
network/snoop/snoopRead.d:../system/platforms/arm-rpi3/bcm2837.h:
network/tftp/tftpGet.c:/* Stress testing--- randomly ignore this percent of valid received data
network/tftp/tftpGet.c: * block-by-block, to a callback function.  This callback function can do
network/tftp/tftpGet.c: *      Callback function that will be passed the file data block-by-block.  For
network/tftp/tftpGet.c:     * port.  The remote port is always initially the well-known TFTP port (69),
network/tftp/tftpGet.c:        udptab[udpdev - UDP0].state = UDP_FREE;
network/tftp/tftpGet.c:    localpt = udptab[udpdev - UDP0].localpt;
network/tftp/tftpGet.c:        udptab[udpdev2 - UDP0].state = UDP_FREE;
network/tftp/tftpGet.c:               send_udpdev - UDP0, recv_udpdev - UDP0, localpt);
network/tftp/tftpGet.c:     * basic idea is that the client receives DATA packets one-by-one, each of
network/tftp/tftpGet.c:            retval = recvtime(1000 * (block_max_end_time -
network/tftp/tftpGet.c:             * client has had the chance to re-send the RRQ a few times.  */
network/tftp/tftpGet.c:         * What we're looking for is a well-formed TFTP DATA packet from the
network/tftp/tftpGet.c:        remote_address = &udptab[recv_udpdev - UDP0].remoteip;
network/tftp/tftpGet.c:              recv_block_number != (ushort)next_block_number - 1)))
network/tftp/tftpGet.c:                           "re-setting bind flag.");
network/tftp/tftpGet.c:                       udptab[recv_udpdev - UDP0].remotept);
network/tftp/tftpGet.c:            block_nbytes = retval - 4;
network/tftp/tftpGet.c:         * however, the server would like to know so it doesn't keep re-sending
network/tftp/tftpGetIntoBuffer.c:    uchar data[TFTP_FILE_DATA_BLOCK_SIZE - sizeof(ulong) - sizeof(void*)];
network/tftp/tftpGetIntoBuffer.c: * in-memory buffer containing the file contents.
network/tftp/tftpGetIntoBuffer.c: *      memget() and therefore can be freed using memfree().  On out-of-memory,
network/tftp/tftpGetIntoBuffer.c:     * size of the resulting file.  Therefore, we allocate space block-by-block
network/tftp/tftpGetIntoBuffer.c:    head->bytes_filled = 0;
network/tftp/tftpGetIntoBuffer.c:    head->next = NULL;
network/tftp/tftpGetIntoBuffer.c:            totallen += ptr->bytes_filled;
network/tftp/tftpGetIntoBuffer.c:            ptr = ptr->next;
network/tftp/tftpGetIntoBuffer.c:        next = ptr->next;
network/tftp/tftpGetIntoBuffer.c:            memcpy(&finalbuf[totallen], ptr->data, ptr->bytes_filled);
network/tftp/tftpGetIntoBuffer.c:        totallen += ptr->bytes_filled;
network/tftp/tftpGetIntoBuffer.c:    /* If successful, save the file length in the caller-provided location.  */
network/tftp/tftpGetIntoBuffer.c:        if (tail->bytes_filled == sizeof(tail->data))
network/tftp/tftpGetIntoBuffer.c:            newtail->bytes_filled = 0;
network/tftp/tftpGetIntoBuffer.c:            newtail->next = NULL;
network/tftp/tftpGetIntoBuffer.c:            tail->next = newtail;
network/tftp/tftpGetIntoBuffer.c:        if (len > sizeof(tail->data) - tail->bytes_filled)
network/tftp/tftpGetIntoBuffer.c:            copylen = sizeof(tail->data) - tail->bytes_filled;
network/tftp/tftpGetIntoBuffer.c:        memcpy(&tail->data[tail->bytes_filled], data, copylen);
network/tftp/tftpGetIntoBuffer.c:        tail->bytes_filled += copylen;
network/tftp/tftpGetIntoBuffer.c:        len -= copylen;
network/tftp/tftpSendRRQ.c:    pktlen = p - (char*)&pkt;
Binary file network/tftp/tftpGetIntoBuffer.o matches
Binary file network/tftp/tftpSendACK.o matches
Binary file network/tftp/tftpGet.o matches
network/tftp/tftpGet.d: ../system/platforms/arm-rpi3/interrupt.h \
network/tftp/tftpGet.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
network/tftp/tftpGet.d:../system/platforms/arm-rpi3/interrupt.h:
network/tftp/tftpGet.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/tftp/tftpRecvPackets.o matches
network/tftp/tftpRecvPackets.d: ../system/platforms/arm-rpi3/interrupt.h \
network/tftp/tftpRecvPackets.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
network/tftp/tftpRecvPackets.d:../system/platforms/arm-rpi3/interrupt.h:
network/tftp/tftpRecvPackets.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file network/tftp/tftpSendRRQ.o matches
README.md:Xinu ("Xinu is not unix", a recursive acronym) is a UNIX-like operating
README.md:-   `AUTHORS`  a brief history of contributors to the Xinu operating system
README.md:-   `compile/` contains the Makefile and other necessities for building the
README.md:               Xinu system once you have a cross-compiler.
README.md:-   `device/`  contains directories with source for all device drivers in Xinu.
README.md:-   `include/` contains all the header files used by Xinu.
README.md:-   `lib/`     contains library folders (e.g., `libxc/`) with a Makefile and
README.md:-   `LICENSE`  the license under which this project falls.
README.md:-   `loader/`  contains assembly files and is where the bootloader will begin
README.md:-   `mailbox/` contains source for the mailbox message queuing system.
README.md:-   `mem/`     contains source for page-based memory protection.
README.md:-   `network/` contains code for the TCP/IP networking stack.
README.md:-   `README`   this document.
README.md:-   `RELEASE`  release notes for the current version.
README.md:-   `shell/`   contains the source for all Xinu shell related functions.
README.md:-   `system/`  contains the source for all Xinu system functions such as the
README.md:-   `test/`    contains a number of testcases (which can be run using the shell
README.md:and the Qemu-mipsel virtual machine.  For an updated list
README.md:### 3.2 Cross-compiler
README.md:To build Embedded Xinu you will need a cross-compiler from your host
README.md:<http://xinu.mscs.mu.edu/Build_Xinu#Cross-Compiler>
README.md:a program called tty-connect which can serve the purpose for a UNIX
README.md:correctly point to the cross-compiler on your machine.
README.md:-   8 data bits, no parity bit, and 1 stop bit (8N1)
README.md:-   115200 bps
README.md:sending breaks (Control-C) to the device, if your luck holds you will be
README.md:    ifconfig eth0 -auto                      if you are using a DHCP server
README.md:    ifconfig eth0 -addr=*.*.*.*              for a static IP address
README.md:    CFE> boot -elf [TFTP server IP]:xinu.boot
README.md:| -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
README.md:| [mipsel-qemu](http://www.qemu.org/)                                                                                                                                  | Supported          | Full O/S teaching core functioning, network support in progress.                                                                                                                                  |
README.md:http://embedded-xinu.readthedocs.io/en/latest/
shell/Doxygroup.c: * @brief Embedded Xinu's interactive command-line interface.
shell/getopt.c: * @return -1 when no more args are found, option character otherwise
shell/getopt.c:    if (TRUE == opts->optreset)
shell/getopt.c:        opts->argc = argc;
shell/getopt.c:        opts->argv = argv;
shell/getopt.c:        opts->optstring = optstring;
shell/getopt.c:        opts->optarg = "";
shell/getopt.c:        opts->optind = 1;
shell/getopt.c:        opts->optopt = 0;
shell/getopt.c:        opts->opterr = 0;
shell/getopt.c:        opts->optreset = FALSE;
shell/getopt.c:    if (opts->argc <= opts->optind)
shell/getopt.c:        return -1;
shell/getopt.c:    currarg = opts->argv[opts->optind];
shell/getopt.c:    if ('-' == currarg[0])
shell/getopt.c:        opts->optind++;
shell/getopt.c:        optpos = strchr(opts->optstring, currarg[1]);
shell/getopt.c:            if (':' == optpos[1] && opts->argc > opts->optind)
shell/getopt.c:                opts->optarg = opts->argv[opts->optind];
shell/getopt.c:                opts->optind++;
shell/getopt.c:        return -1;
shell/lexan.c:            if (!isOtherSpecial(line[i - 1]))
shell/shell.c:        buflen = read(stdin, buf, SHELL_BUFLEN - 1);
shell/shell.c:        if ('&' == *tok[ntok - 1])
shell/shell.c:            ntok--;
shell/shell.c:                ntok = -1;
shell/shell.c:                if (outname != NULL || i >= ntok - 1)
shell/shell.c:                    ntok = -1;
shell/shell.c:                ntok -= 2;
shell/shell.c:                if (inname != NULL || i >= ntok - 1)
shell/shell.c:                    ntok = -1;
shell/shell.c:                ntok -= 2;
shell/shell.c:        /* Handle command if it is built-in */
shell/shell.c:        /* Spawn child thread for non-built-in commands */
shell/xsh_arp.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_arp.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_arp.c:        printf("\t--help\tdisplay this help and exit\n");
shell/xsh_arp.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_arp.c:            printf("%-24s", c);
shell/xsh_arp.c:            printf("%-24s", c);
shell/xsh_arp.c:            pdev = (device *)&devtab[netptr->dev];
shell/xsh_arp.c:            printf("%s\r\n", pdev->name);
shell/xsh_clear.c: * @return non-zero value on error
shell/xsh_clear.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_clear.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_clear.c:        printf("\t--help\t display this help and exit\n");
shell/xsh_clear.c:        fprintf(stderr, "Try '%s --help' for more information.\n",
shell/xsh_date.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_date.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_date.c:        printf("\t--help\tdisplay this help and exit\n");
shell/xsh_date.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_date.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_dumptlb.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_dumptlb.c:        printf("\t--help\tdisplays this help message then exits\n");
shell/xsh_dumptlb.c:        fprintf(stderr, "Try '%s --help' for usage\n", args[0]);
shell/xsh_dumptlb.c:        fprintf(stderr, "Try '%s --help' for usage\n", args[0]);
shell/xsh_ethstat.c: * @return non-zero value on error
shell/xsh_ethstat.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_ethstat.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_ethstat.c:            ("\t-t\t\tdisplay throughput statistics for ethernet <ETHNUM> ");
shell/xsh_ethstat.c:        printf("\t--help\t\tdisplay this help and exit\n");
shell/xsh_ethstat.c:        if (strcmp(args[1], "-t") != 0)
shell/xsh_ethstat.c:            fprintf(stderr, "Invalid argument '%s', try %s --help\n",
shell/xsh_ethstat.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_exit.c: * @return non-zero value on error
shell/xsh_exit.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_exit.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_exit.c:        printf("\t--help\t display this help and exit\n");
shell/xsh_exit.c:        fprintf(stderr, "Try '%s --help' for more information.\n",
shell/xsh_flashstat.c: * @return non-zero value on error
shell/xsh_flashstat.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_flashstat.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_flashstat.c:        printf("\t--help\t display this help and exit\n");
shell/xsh_flashstat.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_flashstat.c:    printf("%s:\n", (flash->device)->name);
shell/xsh_flashstat.c:    printf("\tFound CFI (Flash) device at 0x%08lx\r\n", flash->base);
shell/xsh_flashstat.c:    if (FLASH_INTEL_SCS == flash->commands)
shell/xsh_flashstat.c:    else if (FLASH_AMD_SCS == flash->commands)
shell/xsh_flashstat.c:    printf("Command Set (0x%04x)\r\n", flash->commands);
shell/xsh_flashstat.c:           flash->size, flash->nlog_blocks, flash->log_size);
shell/xsh_flashstat.c:    printf("\tPhysically split into %d erase-regions\r\n",
shell/xsh_flashstat.c:           flash->nregions);
shell/xsh_flashstat.c:    for (n = 0; n < flash->nregions; n++)
shell/xsh_flashstat.c:        r = flash->regions[n];
shell/xsh_gpiostat.c: * @return non-zero value on error
shell/xsh_gpiostat.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_gpiostat.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_gpiostat.c:        printf("\t--help\t display this help and exit\n");
shell/xsh_gpiostat.c:        fprintf(stderr, "Try '%s --help' for more information.\n",
shell/xsh_gpiostat.c:        return -1;
shell/xsh_gpiostat.c:    printf("--- ------ ------- ------- -------\n");
shell/xsh_gpiostat.c:        if (pgcsr->enable & offset)
shell/xsh_gpiostat.c:        printf("   %1lu    ", (pgcsr->input & offset) >> p);
shell/xsh_gpiostat.c:        printf("   %1lu    ", (pgcsr->output & offset) >> p);
shell/xsh_gpiostat.c:        printf("   %1lu    ", (pgcsr->control & offset) >> p);
shell/xsh_help.c: * @return non-zero value on error
shell/xsh_help.c:    char *command_args[2];      /* temporary storage for [command] --help */
shell/xsh_help.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_help.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_help.c:        printf("\tto entering 'command --help' into the shell.\n");
shell/xsh_help.c:        printf("\t--help\tdisplay this help and exit\n");
shell/xsh_help.c:        fprintf(stderr, "Try '%s --help' for more information.\n",
shell/xsh_help.c:                command_args[1] = "--help";
shell/xsh_help.c:        printf("  Try '%s --help' for more information.\n", args[0]);
shell/xsh_kexec.c: * Kernel execute- Transfer control to a new kernel.
shell/xsh_kexec.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_kexec.c:    if (2 == nargs && 0 == strcmp(args[1], "--help"))
shell/xsh_kexec.c:    if (0 == strcmp(args[1], "-n"))
shell/xsh_kexec.c:    else if (0 == strcmp(args[1], "-u"))
shell/xsh_kexec.c:"\t-n <NETDEV>    Load the new kernel over the specified network device.\n"
shell/xsh_kexec.c:"\t-u <UARTDEV>   Load the new kernel over the specified UART device.\n"
shell/xsh_kexec.c:"\t               This is currently a Raspberry-Pi specific feature\n"
shell/xsh_kexec.c:"\t--help         display this help and exit\n"
shell/xsh_kexec.c:    kernel = (void*)tftpGetIntoBuffer(data.bootfile, &nif->ip,
shell/xsh_kexec.c:        /* Tell raspbootcom to re-send the size.  */
shell/xsh_kexec.c:    while (n--)
shell/xsh_kill.c: * @return non-zero value on error
shell/xsh_kill.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_kill.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_kill.c:        printf("\t--help\tdisplay this help and exit\n");
shell/xsh_kill.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_kill.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_kill.c:        return -1;
shell/xsh_led.c: * @return non-zero value on error
shell/xsh_led.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_led.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_led.c:        printf("\t--help\t\tdisplay this help and exit\n");
shell/xsh_led.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_led.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_led.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_led.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_memdump.c: * @return non-zero value on error
shell/xsh_memdump.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_memdump.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_memdump.c:        printf("Usage: %s [-C] [-f] <START> <LENGTH>\n\n", args[0]);
shell/xsh_memdump.c:        printf("\t-C\t\tdisplay in canonical mode (hex+ASCII)\n");
shell/xsh_memdump.c:        printf("\t-f\t\tignore sanity checks for addresses\n");
shell/xsh_memdump.c:        printf("\t--help\t\tdisplay this help and exit\n");
shell/xsh_memdump.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_memdump.c:        if (0 == strcmp(args[arg], "-C"))
shell/xsh_memdump.c:        else if (0 == strcmp(args[arg], "-f"))
shell/xsh_memdump.c:        nargs--;
shell/xsh_memdump.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_memdump.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_memdump.c:        printf("Your values seem insane. Use -f to force.\n");
shell/xsh_memstat.c:    printf("Usage: %s [-r] [-k] [-q] [-t <TID>]\n\n", command);
shell/xsh_memstat.c:    printf("\t-r\t\tprint region allocated and free lists\n");
shell/xsh_memstat.c:    printf("\t-k\t\tprint kernel free list\n");
shell/xsh_memstat.c:    printf("\t-q\t\tsuppress current system memory usage screen\n");
shell/xsh_memstat.c:    printf("\t-t <TID>\tprint user free list of thread id tid\n");
shell/xsh_memstat.c:    printf("\t--help\t\tdisplay this help and exit\n");
shell/xsh_memstat.c: * @return non-zero value on error
shell/xsh_memstat.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_memstat.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_memstat.c:        if (0 == strcmp(args[i], "-t"))
shell/xsh_memstat.c:        else if (0 == strcmp(args[i], "-r"))
shell/xsh_memstat.c:        else if (0 == strcmp(args[i], "-k"))
shell/xsh_memstat.c:        else if (0 == strcmp(args[i], "-q"))
shell/xsh_memstat.c:    phys = (ulong)platform.maxaddr - (ulong)KSEG0_BASE;
shell/xsh_memstat.c:    resrv = (ulong)_start - (ulong)KSEG0_BASE;
shell/xsh_memstat.c:    phys = (ulong)platform.maxaddr - (ulong)platform.minaddr;
shell/xsh_memstat.c:    resrv = (ulong)_start - (ulong)platform.minaddr;
shell/xsh_memstat.c:    code = (ulong)&_end - (ulong)_start;
shell/xsh_memstat.c:    for (block = memlist.next; block != NULL; block = block->next)
shell/xsh_memstat.c:        kfree += block->length;
shell/xsh_memstat.c:    kheap = phys - resrv - code - stack;
shell/xsh_memstat.c:    kused = kheap - kfree;
shell/xsh_memstat.c:         regptr = regptr->next)
shell/xsh_memstat.c:        uused += regptr->length;
shell/xsh_memstat.c:         regptr = regptr->next)
shell/xsh_memstat.c:        uheap += regptr->length;
shell/xsh_memstat.c:    kheap -= uheap;
shell/xsh_memstat.c:    kused -= uheap;
shell/xsh_memstat.c:    printf("----------------------------\n");
shell/xsh_memstat.c:    printf("----------------------------\n");
shell/xsh_memstat.c:    printf("-----  ----------  --------  ---\n");
shell/xsh_memstat.c:         regptr = regptr->next)
shell/xsh_memstat.c:        index = ((uint)regptr - (uint)regtab) / sizeof(struct memregion);
shell/xsh_memstat.c:        printf("%5d  0x%08x  %8d  %3d\n", index, regptr->start,
shell/xsh_memstat.c:               regptr->length, regptr->thread_id);
shell/xsh_memstat.c:    printf("-----  ----------  --------\n");
shell/xsh_memstat.c:         regptr = regptr->next)
shell/xsh_memstat.c:        index = ((uint)regptr - (uint)regtab) / sizeof(struct memregion);
shell/xsh_memstat.c:        printf("%5d  0x%08x  %8d\n", index, regptr->start,
shell/xsh_memstat.c:               regptr->length);
shell/xsh_memstat.c:    printf("-----------  --------\n");
shell/xsh_memstat.c:    for (block = base->next; block != NULL; block = block->next)
shell/xsh_memstat.c:        printf("0x%08lX   %8u\n", (ulong)block, block->length);
shell/xsh_nc.c:    fprintf(stderr, "Invalid argument '%s', try nc --help\n", arg);
shell/xsh_nc.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_nc.c:    if (nargs == 2 && 0 == strcmp(args[1], "--help"))
shell/xsh_nc.c:        if (args[a][0] != '-')
shell/xsh_nc.c:                    return argError(args[a - 1]);
shell/xsh_nc.c:    printf("\t%s -s <LOCAL_IP> <REMOTE_IP> <PORT>\n", command);
shell/xsh_nc.c:    printf("\t%s -l <LISTEN_IP> <PORT>\n", command);
shell/xsh_nc.c:    printf("\t-l\t\tlisten for an incoming connection\n");
shell/xsh_nc.c:        ("\t-s\t\tpackets are sent on the interface with IP local_ip\n");
shell/xsh_nc.c:    printf("\t--help\t\tdisplay this help and exit\n");
shell/xsh_netdown.c:    if ((2 == nargs) && (0 == strcmp(args[1], "--help")))
shell/xsh_netdown.c:        printf("\t--help\t\tdisplay this help and exit\n");
shell/xsh_netemu.c: * @return non-zero value on error
shell/xsh_netstat.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_netstat.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_netstat.c:        printf("\t--help\tdisplay this help and exit\n");
shell/xsh_netstat.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_netstat.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_netstat.c:    if ((NULL == netptr) || (netptr->state != NET_ALLOC))
shell/xsh_netstat.c:    pdev = (device *)&devtab[netptr->dev];
shell/xsh_netstat.c:    printf("%s:\n", pdev->name);
shell/xsh_netstat.c:    netaddrsprintf(strA, &netptr->hwaddr);
shell/xsh_netstat.c:    netaddrsprintf(strA, &netptr->ip);
shell/xsh_netstat.c:    netaddrsprintf(strB, &netptr->mask);
shell/xsh_netstat.c:    printf("IP Addr: %-15s   Mask: %-15s\n", strA, strB);
shell/xsh_netstat.c:    netaddrsprintf(strA, &netptr->gateway);
shell/xsh_netstat.c:    netaddrsprintf(strB, &netptr->ipbrc);
shell/xsh_netstat.c:    printf("Gateway: %-15s   Bcast IP: %-15s\n", strA, strB);
shell/xsh_netstat.c:    printf("MTU: %-19d   Link Hdr Len: %d\n", netptr->mtu,
shell/xsh_netstat.c:           netptr->linkhdrlen);
shell/xsh_netstat.c:    printf("Num Rcv: %-15d   Num Proc: %d\n", netptr->nin, netptr->nproc);
shell/xsh_netup.c:    if ((2 == nargs) && (0 == strcmp(args[1], "--help")))
shell/xsh_netup.c:        descrp = (ethertab[0].dev)->num;
shell/xsh_netup.c:        devname = (ethertab[0].dev)->name;
shell/xsh_netup.c:        /* Use default mask if it was not specified--- this happens if it was
shell/xsh_netup.c:"\t--help\t\tdisplay this help and exit\n"
shell/xsh_nvram.c: * @return non-zero vaule on error
shell/xsh_nvram.c:    printf("Usage: %s [--help] [get <NAME> | ", command);
shell/xsh_nvram.c:    printf("\t--help\t\t\tdisplay this help and exit\n");
shell/xsh_nvram.c:    printf("\t\t\t\tcreate if non-existent\n");
shell/xsh_nvram.c:            printf("%s\n", tuple->pair);
shell/xsh_nvram.c:        while ((tuple = tuple->next) != NULL);
shell/xsh_nvram.c:           count, nvram_header->length,
shell/xsh_nvram.c:           NVRAM_SIZE - nvram_header->length);
shell/xsh_nvram.c: * @return OK (creates a variable if non-existent)
shell/xsh_nvram.c:    *(pair - 1) = '\0';
shell/xsh_ping.c:    /* Output help if '--help' argument was supplied.  */
shell/xsh_ping.c:    if (2 == nargs && 0 == strcmp(args[1], "--help"))
shell/xsh_ping.c:        printf("\t-c count\tstop after sending count packets\n");
shell/xsh_ping.c:        printf("\t-i interval\tsleep interval milliseconds between pings\n");
shell/xsh_ping.c:        printf("\t--help\t\tdisplay this help and exit\n");
shell/xsh_ping.c:        if (0 == strcmp(args[i], "-c"))
shell/xsh_ping.c:                fprintf(stderr, "ping: -c requires positive integer argument\n");
shell/xsh_ping.c:        else if (0 == strcmp(args[i], "-i"))
shell/xsh_ping.c:                fprintf(stderr, "ping: -i requires integer argument\n");
shell/xsh_ping.c:    if (i < nargs - 1)
shell/xsh_ping.c:            if (i < count - 1)
shell/xsh_ping.c:                    sleep((intervalticks - elapsedticks) * 1000 / CLKTICKS_PER_SEC);
shell/xsh_ping.c:    printf("--- %s ping statistics ---\n", target_str);
shell/xsh_ping.c:    printf(" %u%% packet loss,", (count - num_recv) * 100 / count);
shell/xsh_ping.c:        printf("-/");
shell/xsh_ping.c:    eq->tid = BADTID;
shell/xsh_ping.c:    while (eq->tail != eq->head)
shell/xsh_ping.c:        pkt = eq->pkts[eq->tail];
shell/xsh_ping.c:        eq->tail = (eq->tail + 1) % NPINGHOLD;
shell/xsh_ping.c:    if (eq->head != eq->tail)
shell/xsh_ping.c:        pkt = eq->pkts[eq->tail];
shell/xsh_ping.c:        eq->tail = (eq->tail + 1) % NPINGHOLD;
shell/xsh_ping.c:    ip = (const struct ipv4Pkt *)pkt->nethdr;
shell/xsh_ping.c:    icmp = (const struct icmpPkt *)pkt->curr;
shell/xsh_ping.c:    echo = (const struct icmpEcho *)icmp->data;
shell/xsh_ping.c:    memcpy(src.addr, ip->src, src.len);
shell/xsh_ping.c:    printf("%d bytes from %s: ", net2hs(ip->len), src_str);
shell/xsh_ping.c:    printf("icmp_seq=%d ttl=%d ", net2hs(echo->seq), ip->ttl);
shell/xsh_ping.c:    icmp = (const struct icmpPkt *)pkt->curr;
shell/xsh_ping.c:    echo = (const struct icmpEcho *)icmp->data;
shell/xsh_ping.c:    elapsedticks = tickDiff(net2hl(echo->timesec), net2hl(echo->timetic),
shell/xsh_ping.c:                            echo->arrivsec, echo->arrivtic);
shell/xsh_ping.c:    elapsedcyc += (echo->arrivcyc - net2hl(echo->timecyc)) % cycPerTick;
shell/xsh_ping.c:    elapsedticks = (endsec - startsec) * CLKTICKS_PER_SEC;
shell/xsh_ping.c:        elapsedticks += (endticks - startticks);
shell/xsh_ping.c:        elapsedticks -= (startticks - endticks);
shell/xsh_pktgen.c:    printf("usage: %s [options] <iface> <dst-mac>\n", prog);
shell/xsh_pktgen.c:    printf("\t<dst-mac>      MAC address to send packets to\n");
shell/xsh_pktgen.c:    printf("\t-c <count>     number of packets to send [%d]\n",
shell/xsh_pktgen.c:    printf("\t-i <interval>  milliseconds between packet sends [%d]\n",
shell/xsh_pktgen.c:    printf("\t-h <dst-ip>    destination IP for header [%s]\n",
shell/xsh_pktgen.c:    printf("\t-H <src-ip>    source IP for header [%s]\n", DEF_SRCIP);
shell/xsh_pktgen.c:    printf("\t-p <dst-port>  destination port for header [%d]\n",
shell/xsh_pktgen.c:    printf("\t-P <src-port>  source port for header [%d]\n", DEF_SRCPT);
shell/xsh_pktgen.c:    printf("\t-l <min-length> minimum packet size [%d]\n", DEF_MINLEN);
shell/xsh_pktgen.c:    printf("\t-L <max-length> maximum packet size [%d]\n", DEF_MAXLEN);
shell/xsh_pktgen.c: * @return non-zero value on error
shell/xsh_pktgen.c:    while ((arg = getopt(nargs, args, "c:i:h:H:p:P:l:L:", &opts)) != -1)
shell/xsh_pktgen.c:    nargs -= opts.optind;
shell/xsh_pktgen.c:           info.tries, info.errors, info.stop - info.start);
shell/xsh_pktgen.c:    info->start = clktime;
shell/xsh_pktgen.c:    info->stop = 0;
shell/xsh_pktgen.c:    info->tries = 0;
shell/xsh_pktgen.c:    info->errors = 0;
shell/xsh_pktgen.c:    while (info->pktcount == 0 || info->tries < info->pktcount)
shell/xsh_pktgen.c:        info->tries += 1;
shell/xsh_pktgen.c:            info->errors += 1;
shell/xsh_pktgen.c:        pkt->len =
shell/xsh_pktgen.c:            info->minsize +
shell/xsh_pktgen.c:            ((info->tries - 1) % (info->maxsize - info->minsize));
shell/xsh_pktgen.c:        pkt->curr -= (pkt->len + 03) & ~03;
shell/xsh_pktgen.c:        /* push on headers one-by-one */
shell/xsh_pktgen.c:        data = pkt->curr;
shell/xsh_pktgen.c:        memcpy(ethhdr->dst, info->dstmac, ETH_ADDR_LEN);
shell/xsh_pktgen.c:        control(info->dev_id, ETH_CTRL_GET_MAC, (long)ethhdr->src, NULL);
shell/xsh_pktgen.c:        ethhdr->type = ETHER_TYPE_IPv4;
shell/xsh_pktgen.c:        iphdr->ver_ihl = (IPv4_VERSION << 4) | (sizeof(*iphdr) >> 2);;
shell/xsh_pktgen.c:        iphdr->tos = IPv4_TOS_ROUTINE;
shell/xsh_pktgen.c:        iphdr->len = hs2net(pkt->len - sizeof(*ethhdr));
shell/xsh_pktgen.c:        iphdr->id = 0;
shell/xsh_pktgen.c:        iphdr->flags_froff = 0;
shell/xsh_pktgen.c:        iphdr->ttl = IPv4_TTL;
shell/xsh_pktgen.c:        iphdr->proto = info->l3_proto;
shell/xsh_pktgen.c:        iphdr->chksum = 0;
shell/xsh_pktgen.c:        memcpy(iphdr->src, info->srcip.addr, IPv4_ADDR_LEN);
shell/xsh_pktgen.c:        memcpy(iphdr->dst, info->dstip.addr, IPv4_ADDR_LEN);
shell/xsh_pktgen.c:        iphdr->chksum = netChksum(iphdr, IPv4_HDR_LEN);
shell/xsh_pktgen.c:        if (IPv4_PROTO_UDP == info->l3_proto)
shell/xsh_pktgen.c:            udphdr->srcPort = hs2net(info->srcpt);
shell/xsh_pktgen.c:            udphdr->dstPort = hs2net(info->dstpt);
shell/xsh_pktgen.c:            udphdr->len =
shell/xsh_pktgen.c:                hs2net(pkt->len - sizeof(*ethhdr) - sizeof(*iphdr));
shell/xsh_pktgen.c:            udphdr->chksum = 0;
shell/xsh_pktgen.c:        /* send the packet -- don't care about routing, right to the ether! */
shell/xsh_pktgen.c:        if (SYSERR == write(info->dev_id, pkt->curr, pkt->len))
shell/xsh_pktgen.c:            info->errors += 1;
shell/xsh_pktgen.c:        sleep(info->interval);
shell/xsh_pktgen.c:    info->stop = clktime;
shell/xsh_ps.c: * @return non-zero value on error
shell/xsh_ps.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_ps.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_ps.c:        printf("\t--help\t display this help and exit\n");
shell/xsh_ps.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_ps.c:            "--- ------------ ----- ---- ---- ---------- ---------- ----------\n");
shell/xsh_ps.c:    printf("%3s %-16s %5s %4s %4s %10s %-10s %10s\n",
shell/xsh_ps.c:    printf("%3s %-16s %5s %4s %4s %10s %-10s %10s\n",
shell/xsh_ps.c:           "---", "----------------", "-----", "----", "----",
shell/xsh_ps.c:           "----------", "----------", " ---------");
shell/xsh_ps.c:        if (thrptr->state == THRFREE)
shell/xsh_ps.c:        printf("%3d %-16s %s %4d %4d 0x%08lX 0x%08lX %10lu\n",
shell/xsh_ps.c:               i, thrptr->name,
shell/xsh_ps.c:               pstnams[(int)thrptr->state - 1],
shell/xsh_ps.c:               thrptr->prio, thrptr->parent,
shell/xsh_ps.c:               (ulong)thrptr->stkbase,
shell/xsh_ps.c:               (ulong)thrptr->stkptr,
shell/xsh_ps.c:               thrptr->stklen);
shell/xsh_rdate.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_rdate.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_rdate.c:        printf("\t--help\tdisplay this help and exit\n");
shell/xsh_rdate.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_reset.c: * @return non-zero value on error
shell/xsh_reset.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_reset.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_reset.c:        printf("\t--help\t display this help and exit\n");
shell/xsh_reset.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_reset.c:    pgcsr->input |= GPIO_BUT_RESET;
shell/xsh_route.c: * @return non-zero value on error
shell/xsh_route.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_route.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_route.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_route.c:        printf("\t--help\t\t\tdisplay this help and exit\n");
shell/xsh_route.c:                pdev = (device *)&devtab[netptr->dev];
shell/xsh_route.c:                if (strcmp(pdev->name, args[5]) == 0)
shell/xsh_route.c:            printf("%-16s", c);
shell/xsh_route.c:            printf("%-16s", c);
shell/xsh_route.c:            printf("%-16s", c);
shell/xsh_route.c:            pdev = (device *)&devtab[netptr->dev];
shell/xsh_route.c:            printf("%s\r\n", pdev->name);
shell/xsh_rtpstat.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_rtpstat.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_rtpstat.c:        printf("\t--help\tdisplay this help and exit\n");
shell/xsh_rtpstat.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_rtpstat.c:    if (rtpptr->state != RTP_OPEN)
shell/xsh_rtpstat.c:    pdev = rtpptr->dev;
shell/xsh_rtpstat.c:    printf("%-10s ", pdev->name);
shell/xsh_rtpstat.c:    printf("Local  Port: %-5d\n", rtpptr->localpt);
shell/xsh_rtpstat.c:    printf("Remote Port: %-5d\n", rtpptr->remotept);
shell/xsh_sleep.c: * @return non-zero value on error
shell/xsh_sleep.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_sleep.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_sleep.c:        printf("\t--help\t display this help and exit\n");
shell/xsh_sleep.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_sleep.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_snoop.c:    printf("\t%s [--help]\n", command);
shell/xsh_snoop.c:    printf("\t%s [-c COUNT] [-i NETIF] [-s CAPLEN]\n", command);
shell/xsh_snoop.c:    printf("\t      [-d] [-dd] [-v] [-vv] [-t TYPE]\n");
shell/xsh_snoop.c:    printf("\t      [-da ADDR] [-dp PORT] [-sa ADDR] [-sp PORT]\n");
shell/xsh_snoop.c:    printf("\t-d\tDump the packet in hex.\n");
shell/xsh_snoop.c:    printf("\t-dd\tDump the packet in hex and ASCII.\n");
shell/xsh_snoop.c:    printf("\t--help\tDisplay this help and exit.\n");
shell/xsh_snoop.c:    printf("\t-v\tPrint details on the network and transport layer\n");
shell/xsh_snoop.c:    printf("\t-vv\tPrint details on the link layer header and more\n");
shell/xsh_snoop.c:    printf("\t-c\tExit after capturing COUNT packets.\n");
shell/xsh_snoop.c:    printf("\t-i\tCapture only from the network interface NETIF\n");
shell/xsh_snoop.c:    printf("\t-s\tCapture only CAPLEN bytes of each packet. Default\n");
shell/xsh_snoop.c:        ("\t-da\tCapture only packets whose destination IPv4 address\n");
shell/xsh_snoop.c:        ("\t-dp\tCapture only packets whose destination port is PORT.\n");
shell/xsh_snoop.c:    printf("\t\tThis is ignored if -t UDP or TCP is not specified.\n");
shell/xsh_snoop.c:    printf("\t-sa\tCapture only packets whose source IPv4 address\n");
shell/xsh_snoop.c:    printf("\t-sp\tCapture only packets whose source port is PORT.\n");
shell/xsh_snoop.c:    printf("\t\tThis is ignored if -t UDP or TCP is not specified.\n");
shell/xsh_snoop.c:        ("\t-t\tCapture only packets of type TYPE.  Valid values for\n");
shell/xsh_snoop.c:    fprintf(stderr, "Invalid argument '%s', try snoop --help\n", arg);
shell/xsh_snoop.c:        cap->nprint++;
shell/xsh_snoop.c:        count--;
shell/xsh_snoop.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_snoop.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_snoop.c:        if (args[a][0] != '-')
shell/xsh_snoop.c:                error(args[a - 1]);
shell/xsh_snoop.c:                    error(args[a - 1]);
shell/xsh_snoop.c:                    error(args[a - 1]);
shell/xsh_snoop.c:                error(args[a - 1]);
shell/xsh_snoop.c:                    error(args[a - 1]);
shell/xsh_snoop.c:                    error(args[a - 1]);
shell/xsh_snoop.c:                    error(args[a - 1]);
shell/xsh_snoop.c:                error(args[a - 1]);
shell/xsh_snoop.c:            fprintf(stderr, "Invalid type '%s', try usage --help\n",
shell/xsh_tar.c: * @return non-zero value on error
shell/xsh_tar.c:    if (0 == strcmp(args[1], "--help"))
shell/xsh_tar.c:        tarGetData(file, data, BUFFERSIZE - 1);
shell/xsh_tar.c:        data[BUFFERSIZE - 1] = '\0';
shell/xsh_tar.c:    printf("\t--help\t\tdisplay this help screen\n");
shell/xsh_tcpstat.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_tcpstat.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_tcpstat.c:        printf("\t--help\tdisplay this help and exit\n");
shell/xsh_tcpstat.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_telnet.c:        if (0 == strcmp(args[i], "--help"))
shell/xsh_telnet.c:    interface = netLookup((ethertab[0].dev)->num);
shell/xsh_telnet.c:    localhost = &(interface->ip);
shell/xsh_telnet.c:    printf("\t--help\t\tdisplay this help and exit\n");
shell/xsh_telnetserver.c:    fprintf(stderr, "Try %s --help for usage\n", command);
shell/xsh_telnetserver.c:    if ((2 == nargs) && (strcmp(args[1], "--help") == 0))
shell/xsh_telnetserver.c:        printf("Usage: %s [-d device] [-p port] [-h]\n\n", args[0]);
shell/xsh_telnetserver.c:            ("\t-d device\tdevice to listen for traffic. (default: ETH0)\n");
shell/xsh_telnetserver.c:            ("\t-p port\t\tport on which the server listens. (default: 23)\n");
shell/xsh_telnetserver.c:        printf("\t-h \t\thalt server.\n");
shell/xsh_telnetserver.c:        printf("\t--help\t\tdisplay this help information and exit\n");
shell/xsh_telnetserver.c:    if ((2 == nargs) && (0 == strcmp(args[1], "-h")))
shell/xsh_telnetserver.c:            if (thrptr->state == THRFREE)
shell/xsh_telnetserver.c:            if (0 == strncmp(thrptr->name, "telnetServ_", 11))
shell/xsh_telnetserver.c:        fprintf(stderr, "Try %s --help for usage\n", args[0]);
shell/xsh_telnetserver.c:    descrp = (ethertab[0].dev)->num;
shell/xsh_telnetserver.c:        if (strcmp(args[i], "-d") == 0)
shell/xsh_telnetserver.c:        else if (strcmp(args[i], "-p") == 0)
shell/xsh_telnetserver.c:        fprintf(stderr, "Try %s --help for usage\n", args[0]);
shell/xsh_telnetserver.c:        fprintf(stderr, "Try %s --help for usage\n", args[0]);
shell/xsh_telnetserver.c:        sprintf(thrname, "telnetServ_%d", (spawntelnet - TELNET0));
shell/xsh_telnetserver.c:        TELNET_TRACE("Spawning %s on %d", thrname, spawntelnet - TELNET0);
shell/xsh_test.c: * @return non-zero value on error
shell/xsh_test.c:	int dev = peth->dev->num;
shell/xsh_test.c:	memsize = sizeof(struct etherGram) + MAX_PAYLOAD - 1;
shell/xsh_test.c:	payload = &(outpkt->payload[0]);
shell/xsh_test.c:	memcpy(outpkt->dst, mymac, ETH_ADDR_LEN);
shell/xsh_test.c:	memcpy(outpkt->src, mymac, ETH_ADDR_LEN);
shell/xsh_test.c:	outpkt->type_len = hs2net(ETH_TYPE_ARP);
shell/xsh_test.c:	while (peth->icount > 0)
shell/xsh_test.c:	sprintf(str, "%s 1516 OVERSIZED byte packet (write)", peth->dev->name);
shell/xsh_test.c:	sprintf(str, "%s 1514 MAX byte packet (write)", peth->dev->name);
shell/xsh_test.c:	sprintf(str, "%s 700 NORMAL byte packet (write)", peth->dev->name);
shell/xsh_test.c:	sprintf(str, "%s 12 MICRO byte packet (write)", peth->dev->name);
shell/xsh_test.c:	sprintf(str, "%s 512 random-sized packets (write)", peth->dev->name);
shell/xsh_test.c:	   sprintf(str, "%s  700 byte packet (read)", peth->dev->name);
shell/xsh_testsuite.c: * @return non-zero value on error
shell/xsh_testsuite.c:        if (0 == strcmp(args[i], "--help"))
shell/xsh_testsuite.c:        else if (0 == strcmp(args[i], "-v"))
shell/xsh_testsuite.c:            testnum = atoi(args[i]) - 1;
shell/xsh_testsuite.c:    printf("\t--help\t\tdisplay this help and exit\n");
shell/xsh_testsuite.c:    printf("\t-v\t\tverbose information\n");
shell/xsh_timeserver.c:    fprintf(stderr, "Try %s --help for usage\n", command);
shell/xsh_timeserver.c:    if ((2 == nargs) && (strcmp(args[1], "--help") == 0))
shell/xsh_timeserver.c:        printf("Usage: %s [-d device] [-p port]\n\n", args[0]);
shell/xsh_timeserver.c:            ("\t-d device\tdevice to listen for traffic. (default: ETH0)\n");
shell/xsh_timeserver.c:            ("\t-p port\t\tport on which the server listens. (default: %d)\n",
shell/xsh_timeserver.c:        printf("\t--help\t\tdisplay this help information and exit\n");
shell/xsh_timeserver.c:        fprintf(stderr, "Try %s --help for usage\n", args[0]);
shell/xsh_timeserver.c:    descrp = (ethertab[0].dev)->num;
shell/xsh_timeserver.c:        if (strcmp(args[i], "-d") == 0)
shell/xsh_timeserver.c:        else if (strcmp(args[i], "-p") == 0)
shell/xsh_timeserver.c:        fprintf(stderr, "Try %s --help for usage\n", args[0]);
shell/xsh_timeserver.c:        fprintf(stderr, "Try %s --help for usage\n", args[0]);
shell/xsh_turtle.c: * Shell command (turtle). Runs a mini-shell of its own until 
shell/xsh_turtle.c:int orientation; //angle in degrees; limited from -359 to +359 for simplicity.
shell/xsh_turtle.c:#define MAXY (DEFAULT_HEIGHT - MINISHELLMINROW * CHAR_HEIGHT - 2)
shell/xsh_turtle.c:/* The built-in turtle commands. Can be used in loops and new commands.
shell/xsh_turtle.c: * Not included: 1 arg commands -- end, reset, status, help, home */
shell/xsh_turtle.c:        buflen = read(stdin, buf, SHELL_BUFLEN - 1);
shell/xsh_turtle.c:        //built-in tests
shell/xsh_turtle.c:            } else if (newcommandfinder(nargs - i, args + i) == OK) {
shell/xsh_turtle.c:        num--;
shell/xsh_turtle.c:                    ntok -= 2;
shell/xsh_turtle.c:                    ntok--;
shell/xsh_turtle.c:    turn(-1 * atoi(arg));    
shell/xsh_turtle.c:    move(-1 * atoi(arg));
shell/xsh_turtle.c:    if ((newx > 5000) || (newx < -5000)) {
shell/xsh_turtle.c:    if ((newy > 5000) || (newy < -5000)) {
shell/xsh_turtle.c:        newy = STARTY - newy; //adjust for abstracted coordinates 
shell/xsh_turtle.c:    if ( (num >= 5000) || (num <= -5000) ) {
shell/xsh_turtle.c:    if (newx >= 5000 || newx <= -5000 || newy >= 5000 || newy <= -5000) {
shell/xsh_turtle.c:                    drawSegment(x, y - i, newx, newy - i, color);
shell/xsh_turtle.c:                    drawSegment(x - i, y, newx - i, newy, color);
shell/xsh_turtle.c:                    ((orientation < 0) && (orientation > -270)) ||
shell/xsh_turtle.c:                    ((orientation < -90) && (orientation > -180)) ||
shell/xsh_turtle.c:                    drawSegment(x - i, y - i, newx - i, newy - i, color);
shell/xsh_turtle.c:                    drawSegment(x + i, y - i, newx + i, newy - i, color);
shell/xsh_turtle.c:                    drawSegment(x - i, y + i, newx - i, newy + i, color);
shell/xsh_turtle.c:    drawSegment(0, 0, DEFAULT_WIDTH-1, 0, RASPBERRY);
shell/xsh_turtle.c:    drawSegment(0, MAXY, DEFAULT_WIDTH-1, MAXY, RASPBERRY);
shell/xsh_turtle.c:    drawSegment(DEFAULT_WIDTH-1, 0, DEFAULT_WIDTH-1, MAXY, RASPBERRY);
shell/xsh_turtle.c:    cursor_row = rows - MINISHELLMINROW;
shell/xsh_turtle.c:    printf("STATUS: Current coordinates: (%d, %d). Current width: %d. Current angle: %d. Current color: %s. Pen is %s.", x - STARTX, STARTY - y, width, orientation, colorfinder(color), str);
shell/xsh_turtle.c:    if (y0 > (MAXY - HEAD_RADIUS - BODY_RADIUS)) return;
shell/xsh_turtle.c:    if (y0 > (MAXY - HEAD_RADIUS - BODY_RADIUS)) return;
shell/xsh_turtle.c:    cursor_row = rows - MINISHELLMINROW - 1;
shell/xsh_uartstat.c: * @return non-zero value on error
shell/xsh_uartstat.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_uartstat.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_uartstat.c:        printf("Usage: %s [-t] <UARTNUM>\n\n", args[0]);
shell/xsh_uartstat.c:            ("\t-t\t\tdisplay throughput statistics for uart <UARTNUM> ");
shell/xsh_uartstat.c:        printf("\t--help\t\tdisplay this help and exit\n");
shell/xsh_uartstat.c:        if (strcmp(args[1], "-t") != 0)
shell/xsh_uartstat.c:            fprintf(stderr, "Invalid argument '%s', try %s --help\n",
shell/xsh_uartstat.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_uartstat.c:        cout = uptr->cout;
shell/xsh_uartstat.c:        cin = uptr->cin;
shell/xsh_uartstat.c:        printf("Tx: %4d bytes/sec, ", uptr->cout - cout);
shell/xsh_uartstat.c:        printf("Rx: %4d bytes/sec\n", uptr->cin - cin);
shell/xsh_udpstat.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_udpstat.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_udpstat.c:        printf("\t--help\tdisplay this help and exit\n");
shell/xsh_udpstat.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_udpstat.c:    if (udpptr->state != UDP_OPEN)
shell/xsh_udpstat.c:    pdev = udpptr->dev;
shell/xsh_udpstat.c:    printf("%-10s ", pdev->name);
shell/xsh_udpstat.c:    netaddrsprintf(strA, &udpptr->localip);
shell/xsh_udpstat.c:    printf("Local  Port: %-5d IP: %-15s\n", udpptr->localpt, strA);
shell/xsh_udpstat.c:    netaddrsprintf(strA, &udpptr->remoteip);
shell/xsh_udpstat.c:    printf("Remote Port: %-5d IP: %-15s\n", udpptr->remotept, strA);
shell/xsh_usbinfo.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_usbinfo.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_usbinfo.c:        printf("\t--help\tdisplay this help and exit\n");
shell/xsh_usbinfo.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_user.c: * This file is only intended to demonstrate proof-of-concept that a system
shell/xsh_user.c: * kernel mode and using these functions will NOT result in user->kernel
shell/xsh_user.c: *  -> user_*: loads the system call number and generates a syscall exception
shell/xsh_user.c: *   -> dispatch: jumps to sc_* handler for user_* and passed pointer to args
shell/xsh_user.c: *    -> sc_*: re-musters args from pointer and calls proper kernel function
shell/xsh_user.c: *    <- sc_*: gets return value of kernel function, or OK/SYSERR
shell/xsh_user.c: *   <- dispatch: gets return value of sc_*, SYSERR if no syscall executed
shell/xsh_user.c: *  <- user_*: gets return status from handler, returns status to caller
shell/xsh_user.c: * The change from user->kernel mode would occur implicitly when the
shell/xsh_user.c: * Currently, no method exists for building user-address/user-mode
shell/xsh_user.c: *                                                        -mjs (2009-Sep-24)
shell/xsh_user.c:#define LOOP0 (-1)
shell/xsh_user.c: * @return non-zero value on error
shell/xsh_vlanstat.c: * @return non-zero value on error
shell/xsh_vlanstat.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_vlanstat.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_vlanstat.c:        printf("\t--help\t display this help and exit\n");
shell/xsh_vlanstat.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_voip.c:#define T_NAME_SEND   "voip-send"
shell/xsh_voip.c:#define T_NAME_RECV   "voip-receive"
shell/xsh_voip.c:    ((curtime * CLKTICKS_PER_SEC + curticks) - \
shell/xsh_voip.c:        fprintf(stderr, "Try '%s --help' for more information\n",
shell/xsh_voip.c:    else if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_voip.c:            ("\nUsage: %s [-p <rx port> <tx port>] [-s] [serial] [localhost] [IP address]\n",
shell/xsh_voip.c:        printf("\t-t\t\tToggle external sampling device on/off.\n");
shell/xsh_voip.c:            ("\t-p\t\tSpecify UDP receive and transmit port numbers.\n");
shell/xsh_voip.c:        printf("\t-s\t\tEmbed sequence information in each packet.\n");
shell/xsh_voip.c:            if (strcmp(args[i], "-s") == 0)
shell/xsh_voip.c:            else if (strcmp(args[i], "-t") == 0)
shell/xsh_voip.c:                    if (THRFREE == thrptr->state)
shell/xsh_voip.c:                    if (strcmp(thrptr->name, T_NAME_SEND) == 0)
shell/xsh_voip.c:            else if (strcmp(args[i], "-p") == 0)
shell/xsh_voip.c:        if (thrptr->state == THRFREE)
shell/xsh_voip.c:        if (0 == strcmp(thrptr->name, "SHELL1"))
shell/xsh_voip.c:              ((void *)serial_loop, INITSTK, 20, "voip-serial", 1, uart),
shell/xsh_voip.c:        netptr = netLookup((ethertab[0].dev)->num);
shell/xsh_voip.c:        localhost = &(netptr->ip);
shell/xsh_voip.c:        srand(localhost->addr[3]);      /* Seed the random number generator */
shell/xsh_voip.c:            fprintf(CONSOLE, "Invalid message sent to voip-send.\n");
shell/xsh_voip.c:                buf[i] = linear2ulaw((value[j] - 512) * 64);
shell/xsh_voip.c:    voip->seq = 0;
shell/xsh_voip.c:        voip->len = read(uart, voip->buf, SEQ_BUF_SIZE);
shell/xsh_voip.c:        if (voip->len > 0)
shell/xsh_voip.c:                kprintf("d%d ", voip->seq);
shell/xsh_voip.c:            voip->seq++;
shell/xsh_voip.c:    voip->len = 0;
shell/xsh_voip.c:            if (seq < voip->seq)
shell/xsh_voip.c:                kprintf("l%d ", seq);   //voip->seq + 1);
shell/xsh_voip.c:                seq = voip->seq;
shell/xsh_voip.c:            else if (voip->seq < seq)
shell/xsh_voip.c:                kprintf("dup%d", voip->seq);
shell/xsh_voip.c:            write(uart, voip->buf, voip->len);
shell/xsh_voip.c:            write(uart, voip->buf, voip->len);
shell/xsh_voip.c:            kprintf("- ");
shell/xsh_xweb.c:    /* Output help, if '--help' argument was supplied */
shell/xsh_xweb.c:    if (nargs == 2 && strcmp(args[1], "--help") == 0)
shell/xsh_xweb.c:        printf("Usage: %s [<DEVICE>|-h]\n\n", args[0]);
shell/xsh_xweb.c:               (ethertab[0].dev)->name);
shell/xsh_xweb.c:        printf("\t-h\t\tHalt all XWeb threads and terminate Xweb.\n");
shell/xsh_xweb.c:        printf("\t--help\t\tdisplay this help information\n\n");
shell/xsh_xweb.c:    if (nargs == 2 && strcmp(args[1], "-h") == 0)
shell/xsh_xweb.c:            if (thrptr->state == THRFREE)
shell/xsh_xweb.c:            if (0 == strncmp(thrptr->name, "XWeb_", 5))
shell/xsh_xweb.c:        descrp = (ethertab[0].dev)->num;
shell/xsh_random.c:	if (2 == nargs && 0 == strcmp(args[1], "--help"))
shell/xsh_random.c:	rand = random() % (max - min) + min;
Binary file shell/getopt.o matches
Binary file shell/shell.o matches
shell/shell.d: ../system/platforms/arm-rpi3/interrupt.h \
shell/shell.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/shell.h \
shell/shell.d:../system/platforms/arm-rpi3/interrupt.h:
shell/shell.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/lexan.o matches
Binary file shell/xsh_memdump.o matches
shell/xsh_memdump.d: ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_memdump.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_memdump.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_memdump.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_clear.o matches
shell/xsh_clear.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_clear.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_clear.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_clear.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_date.o matches
shell/xsh_date.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_date.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_date.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_date.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_exit.o matches
shell/xsh_exit.d: ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_exit.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_exit.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_exit.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_help.o matches
shell/xsh_help.d: ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_help.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_help.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_help.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_reset.o matches
shell/xsh_reset.d: ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_reset.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_reset.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_reset.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_sleep.o matches
shell/xsh_sleep.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_sleep.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_sleep.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_sleep.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_kill.o matches
shell/xsh_kill.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_kill.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_kill.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_kill.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_ps.o matches
shell/xsh_ps.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_ps.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_ps.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_ps.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_test.o matches
Binary file shell/xsh_memstat.o matches
shell/xsh_memstat.d: ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_memstat.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_memstat.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_memstat.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_dumptlb.o matches
shell/xsh_dumptlb.d: ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_dumptlb.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_dumptlb.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_dumptlb.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_user.o matches
shell/xsh_user.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
shell/xsh_user.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_user.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_user.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_uartstat.o matches
shell/xsh_uartstat.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_uartstat.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
shell/xsh_uartstat.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_uartstat.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_gpiostat.o matches
shell/xsh_gpiostat.d: ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_gpiostat.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_gpiostat.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_gpiostat.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_led.o matches
shell/xsh_led.d: ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_led.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_led.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_led.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_tar.o matches
shell/xsh_tar.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_tar.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_tar.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_tar.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_turtle.o matches
shell/xsh_turtle.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_turtle.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_turtle.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_turtle.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_flashstat.o matches
shell/xsh_flashstat.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_flashstat.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
shell/xsh_flashstat.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_flashstat.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_nvram.o matches
shell/xsh_nvram.d: ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_nvram.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
shell/xsh_nvram.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_nvram.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_kexec.o matches
shell/xsh_kexec.d: ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_kexec.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_kexec.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_kexec.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_random.o matches
shell/xsh_random.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
shell/xsh_random.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_random.d: ../system/platforms/arm-rpi3/random.h \
shell/xsh_random.d: ../system/platforms/arm-rpi3/bcm2837.h
shell/xsh_random.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_random.d:../system/platforms/arm-rpi3/bcm2837.h:
shell/xsh_random.d:../system/platforms/arm-rpi3/random.h:
shell/xsh_random.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_usbinfo.o matches
shell/xsh_usbinfo.d: ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_usbinfo.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_usbinfo.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_usbinfo.d:../system/platforms/arm-rpi3/bcm2837.h:
shell/xsh_test.d: ../system/platforms/arm-rpi3/interrupt.h \
shell/xsh_test.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
shell/xsh_test.d:../system/platforms/arm-rpi3/interrupt.h:
shell/xsh_test.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file shell/xsh_testsuite.o matches
system/arch/README:This directory contains CPU-architecture-specific code.
system/arch/arm/ctxsw.S:/*------------------------------------------------------------------------
system/arch/arm/ctxsw.S: *  ctxsw  -  Switch from one thread context to another.
system/arch/arm/ctxsw.S: *------------------------------------------------------------------------
system/arch/arm/ctxsw.S: * This is the ARM version.  How it works: we have to save r4-r11 and lr, since
system/arch/arm/ctxsw.S: * r4-r11 are callee-save and lr needs to be loaded into the pc when this
system/arch/arm/ctxsw.S: * context is switched to again.  Registers r0-r3 are caller-save so they do
system/arch/arm/ctxsw.S: * have an appropriate value for pc--- namely, the lr, a.k.a. the address
system/arch/arm/ctxsw.S: * this is irrelevant because the lr is caller-save, and we can simply push a
system/arch/arm/ctxsw.S: *   - We do all our context switches to/from the same mode (namely, SYS mode).
system/arch/arm/ctxsw.S: *   - The ARM ABI does not expect comparison flags in the CPSR to be preserved
system/arch/arm/ctxsw.S: *   - resched() takes care of saving/restoring whether interrupts are enabled
system/arch/arm/ctxsw.S: *   - Xinu never makes changes to the CPSR not already covered above, such as
system/arch/arm/ctxsw.S: *------------------------------------------------------------------------*/
system/arch/arm/ctxsw.S:	push {r0-r14}
system/arch/arm/ctxsw.S:	pop {r0-r12}
system/arch/arm/intutils.S: * See http://xinu-os.org/Interrupt_handling_(ARM) for more information.
system/arch/arm/irq_handler.S:	 * namely the SYS mode LR and all other caller-save general purpose
system/arch/arm/irq_handler.S:	 * decremented the stack pointer by to align it to an 8-byte boundary
system/arch/arm/irq_handler.S:	push {r0-r4, r12, lr}
system/arch/arm/irq_handler.S:	 * Architecture", the stack pointer is 4-byte aligned at all times, but
system/arch/arm/irq_handler.S:	 * it must be 8-byte aligned when calling an externally visible
system/arch/arm/irq_handler.S:	 * and therefore the stack currently may only be 4-byte aligned.  If
system/arch/arm/irq_handler.S:	 * this is the case, the stack must be padded to an 8-byte boundary
system/arch/arm/irq_handler.S:	/* Restore the original stack alignment (see note about 8-byte alignment
system/arch/arm/irq_handler.S:	/* Restore the above-mentioned registers from the SYS mode stack. */
system/arch/arm/irq_handler.S:	pop {r0-r4, r12, lr}
system/arch/arm/irq_handler.S:	/* Load the original SYS-mode CPSR and PC that were saved on the SYS
system/arch/arm/pause.S: * Platform-dependent code for idling the processor.
system/arch/arm/setupStack.c:/* Length of ARM context record in words (includes r0-r11, cpsr, lr, pc).  */
system/arch/arm/setupStack.c:/* The standard ARM calling convention passes first four arguments in r0-r3; the
system/arch/arm/setupStack.c:        spilled_nargs = nargs - MAX_REG_ARGS;
system/arch/arm/setupStack.c:        saddr -= spilled_nargs;
system/arch/arm/setupStack.c:    /* Possibly skip a word to ensure the stack is aligned on 8-byte boundary
system/arch/arm/setupStack.c:        --saddr;
system/arch/arm/setupStack.c:    saddr -= CONTEXT_WORDS;
system/arch/arm/setupStack.c:    for (; i < CONTEXT_WORDS - 3; i++)
system/arch/arm/setupStack.c:    saddr[CONTEXT_WORDS - 3] = ARM_MODE_SYS | ARM_F_BIT;
system/arch/arm/setupStack.c:    saddr[CONTEXT_WORDS - 2] = (ulong)retaddr;
system/arch/arm/setupStack.c:    saddr[CONTEXT_WORDS - 1] = (ulong)procaddr;
Binary file system/arch/arm/.ctxsw.S.swp matches
system/arch/mips/clkupdate.S: * Platform-dependent code for clock interrupt maintenance.
system/arch/mips/clkupdate.S:  * Return free-running clock count.
system/arch/mips/ctxsw.S:/*------------------------------------------------------------------------
system/arch/mips/ctxsw.S: *  ctxsw  -  Switch from one thread context to another.
system/arch/mips/ctxsw.S: *------------------------------------------------------------------------
system/arch/mips/ctxsw.S:	addiu	sp, sp, -CONTEXT
system/arch/mips/ctxsw.S:	sw	ra, CONTEXT-4(sp)
system/arch/mips/ctxsw.S:	sw	ra, CONTEXT-8(sp)
system/arch/mips/ctxsw.S:	/* save callee-save ("non-volatile") registers                 */
system/arch/mips/ctxsw.S:	/* restore callee-save ("non-volatile") registers              */
system/arch/mips/ctxsw.S:	lw	v0, CONTEXT-4(sp)
system/arch/mips/ctxsw.S:	lw	ra, CONTEXT-8(sp)
system/arch/mips/debugret.S: * no-op at beginning for GDB
system/arch/mips/debugret.S: * prefixed no-op for GDB compatibility
system/arch/mips/debugret.S:	.mask	0xc0000000,-4
system/arch/mips/debugret.S:	addiu	$sp,$sp,-24
system/arch/mips/debugret.S:	.size	debugret, .-debugret
system/arch/mips/intdispatch.S:	addiu	sp, sp, -IRQREC_SIZE
system/arch/mips/intdispatch.S:	/* Call high-level trap handler.                          */
system/arch/mips/interrupt.h:#define EXC_MOD        1   /**< Store on Read-Only Page            */
system/arch/mips/pause.S: * Platform-dependent code for idling the processor
system/arch/mips/setupStack.c:    saddr -= max(nargs, 4);
system/arch/mips/setupStack.c:    /* The MIPS stack should be 8-byte aligned on entry to all procedures.  */
system/arch/mips/setupStack.c:        --saddr;
system/arch/mips/setupStack.c:    saddr -= CONTEXT_WORDS;
system/arch/mips/setupStack.c:    for (i = 0; i < CONTEXT_WORDS - 2; i++)
system/arch/mips/setupStack.c:    saddr[CONTEXT_WORDS - 2] = (ulong)retaddr;
system/arch/mips/setupStack.c:    saddr[CONTEXT_WORDS - 1] = (ulong)procaddr;
system/arch/mips/syscall_dispatch.c:/* quick and dirty macro to make user->kernel syscalls */
system/arch/mips/syscall_entry.S:	addiu   sp, sp, -64      /* increase stack */
system/bfpalloc.c:        if (BFPFREE == bfpptr->state)
system/bfpalloc.c:    bfpptr->state = BFPUSED;
system/bfpalloc.c:    bfpptr->freebuf = semcreate(0);
system/bfpalloc.c:    if (SYSERR == (int)bfpptr->freebuf)
system/bfpalloc.c:        bfpptr->state = BFPFREE;
system/bfpalloc.c:    bfpptr->nbuf = nbuf;
system/bfpalloc.c:    bfpptr->bufsize = bufsize;
system/bfpalloc.c:        semfree(bfpptr->freebuf);
system/bfpalloc.c:        bfpptr->state = BFPFREE;
system/bfpalloc.c:    bfpptr->next = bufptr;
system/bfpalloc.c:    bfpptr->head = bufptr;
system/bfpalloc.c:        bufptr->poolid = id;
system/bfpalloc.c:        bufptr->next = (struct poolbuf *)((ulong)bufptr + bufsize);
system/bfpalloc.c:        bufptr = bufptr->next;
system/bfpalloc.c:    signaln(bfpptr->freebuf, nbuf);
system/bfpfree.c:    bfpptr->state = BFPFREE;
system/bfpfree.c:    if (SYSERR == memfree(bfpptr->head, bfpptr->nbuf * bfpptr->bufsize))
system/bfpfree.c:    if (SYSERR == semfree(bfpptr->freebuf))
system/buffree.c:    bufptr = ((struct poolbuf *)buffer) - 1;
system/buffree.c:    if (isbadpool(bufptr->poolid))
system/buffree.c:    if (bufptr->next != bufptr)
system/buffree.c:    bfpptr = &bfptab[bufptr->poolid];
system/buffree.c:    bufptr->next = bfpptr->next;
system/buffree.c:    bfpptr->next = bufptr;
system/buffree.c:    signaln(bfpptr->freebuf, 1);
system/bufget.c:    wait(bfpptr->freebuf);
system/bufget.c:    bufptr = bfpptr->next;
system/bufget.c:    bfpptr->next = bufptr->next;
system/bufget.c:    bufptr->next = bufptr;
system/chprio.c:    oldprio = thrptr->prio;
system/chprio.c:    thrptr->prio = newprio;
system/clkhandler.c:    if (nonempty(sleepq) && (--firstkey(sleepq) <= 0))
system/close.c:    return ((*devptr->close) (devptr));
system/control.c: *      Device-specific specific control "function".
system/control.c: *      Additional argument for the device-specific control function.
system/control.c: *      Additional argument for the device-specific control function.
system/control.c: *      otherwise returns a request-specific value that is typically ::SYSERR on
system/control.c: *      failure, but may be either ::OK or request-specific data on success.
system/control.c:    return ((*devptr->control) (devptr, func, arg1, arg2));
system/create.c:    thrptr->state = THRSUSP;
system/create.c:    thrptr->prio = priority;
system/create.c:    thrptr->stkbase = saddr;
system/create.c:    thrptr->stklen = ssize;
system/create.c:    strlcpy(thrptr->name, name, TNMLEN);
system/create.c:    thrptr->parent = gettid();
system/create.c:    thrptr->hasmsg = FALSE;
system/create.c:    thrptr->memlist.next = NULL;
system/create.c:    thrptr->memlist.length = 0;
system/create.c:    thrptr->fdesc[0] = CONSOLE; /* stdin  is console */
system/create.c:    thrptr->fdesc[1] = CONSOLE; /* stdout is console */
system/create.c:    thrptr->fdesc[2] = CONSOLE; /* stderr is console */
system/create.c:     * Architecture-specific.  */
system/create.c:    thrptr->stkptr = setupStack(saddr, procaddr, INITRET, nargs, ap);
system/debug.c:        remain = length - n;
system/debug.c:            for (m = 0; m < 0x10 - remain; m++)
system/getc.c:    return ((*devptr->getc) (devptr));
system/initialize.c:	/* Platform-specific initialization */		
system/initialize.c:	memlist.length = (uint)(platform.maxaddr - memheap);
system/initialize.c:	pmblock->next = NULL;
system/initialize.c:	pmblock->length = (uint)(platform.maxaddr - memheap);
system/initialize.c:	thrptr->state = THRCURR;
system/initialize.c:	thrptr->prio = 0;
system/initialize.c:	strlcpy(thrptr->name, "prnull", TNMLEN);
system/initialize.c:	thrptr->stkbase = (void *)&_end;
system/initialize.c:	thrptr->stklen = (ulong)memheap - (ulong)&_end;
system/initialize.c:	thrptr->stkptr = 0;
system/initialize.c:	thrptr->memlist.next = NULL;
system/initialize.c:	thrptr->memlist.length = 0;
system/initialize.c:			userheap = (void *)((uint)userheap - UHEAP_SIZE + sizeof(int));
system/insertd.c:        key -= quetab[next].key;
system/insertd.c:        quetab[next].key -= key;
system/kill.c:    if (--thrcount <= 1)
system/kill.c:    send(thrptr->parent, tid);
system/kill.c:    stkfree(thrptr->stkbase, thrptr->stklen);
system/kill.c:    switch (thrptr->state)
system/kill.c:        thrptr->state = THRFREE;
system/kill.c:        thrptr->state = THRFREE;        /* suicide */
system/kill.c:        semtab[thrptr->sem].count++;
system/kill.c:        thrptr->state = THRFREE;
system/lock.c:    if (NOOWNER == monptr->owner)
system/lock.c:        monptr->owner = thrcurrent;     /* current thread now owns the lock  */
system/lock.c:        (monptr->count)++;      /* add 1 "lock" to the monitor's count */
system/lock.c:        wait(monptr->sem);      /* this thread owns the semaphore      */
system/lock.c:        if (thrcurrent == monptr->owner)
system/lock.c:            (monptr->count)++;
system/lock.c:            wait(monptr->sem);
system/lock.c:            monptr->owner = thrcurrent;
system/lock.c:            (monptr->count)++;
system/main.c:			ethptr = &ethertab[ethertab[i].dev->minor];
system/main.c:			if (SYSERR == open(ethertab[i].dev->num))
system/main.c:						ethertab[i].dev->name);
system/main.c:			else if(ETH_STATE_UP == ethptr->state)
system/main.c:						ethertab[i].dev->name);
system/main.c:			(ulong)platform.maxaddr - (ulong)platform.minaddr);
system/main.c:			(ulong)platform.minaddr, (ulong)(platform.maxaddr - 1));
system/main.c:			(ulong)_start - (ulong)platform.minaddr);
system/main.c:			(ulong)platform.minaddr, (ulong)_start - 1);
system/main.c:	kprintf("%10d bytes Xinu code.\r\n", (ulong)&_end - (ulong)_start);
system/main.c:			(ulong)_start, (ulong)&_end - 1);
system/main.c:	kprintf("%10d bytes stack space.\r\n", (ulong)memheap - (ulong)&_end);
system/main.c:			(ulong)&_end, (ulong)memheap - 1);
system/main.c:			(ulong)platform.maxaddr - (ulong)memheap);
system/main.c:			(ulong)memheap, (ulong)platform.maxaddr - 1);
system/mdelay.c: * Busy-waits for a number of milliseconds.
system/mdelay.c:    while (ms--)
system/memfree.c: * Frees a block of heap-allocated memory.
system/memfree.c:        next = next->next;
system/memfree.c:        top = (ulong)prev + prev->length;
system/memfree.c:        prev->length += nbytes;
system/memfree.c:        block->next = next;
system/memfree.c:        block->length = nbytes;
system/memfree.c:        prev->next = block;
system/memfree.c:    if (((ulong)block + block->length) == (ulong)next)
system/memfree.c:        block->length += next->length;
system/memfree.c:        block->next = next->next;
system/memget.c: *      The returned pointer is guaranteed to be 8-byte aligned.  Free the block
system/memget.c:        if (curr->length == nbytes)
system/memget.c:            prev->next = curr->next;
system/memget.c:            memlist.length -= nbytes;
system/memget.c:        else if (curr->length > nbytes)
system/memget.c:            prev->next = leftover;
system/memget.c:            leftover->next = curr->next;
system/memget.c:            leftover->length = curr->length - nbytes;
system/memget.c:            memlist.length -= nbytes;
system/memget.c:        curr = curr->next;
system/minijava.c:            i = i * 10 + c - '0';
system/minijava.c:    int *A = objAdder - 2;
system/minijava.c:    int *A = objAdder - 2;
system/minijava.c:    int *A = threadObjAdder - 1;
system/moncount.c: * Retrieve the count of a monitor --- that is, the number of times it has been
system/moncreate.c:        monptr->owner = NOOWNER;
system/moncreate.c:        monptr->count = 0;
system/moncreate.c:        monptr->sem = semcreate(1);
system/moncreate.c:        if (SYSERR == monptr->sem)
system/moncreate.c:            monptr->state = MFREE;
system/monfree.c: * A monitor must only be freed when no thread has it locked -- that is, either
system/monfree.c:    semfree(monptr->sem);
system/monfree.c:    monptr->state = MFREE;
system/open.c: *      device-specific open function.
system/open.c: *      or for device-specific errors.
system/open.c:	result = ((*devptr->open) (devptr, ap));
system/platforms/arm-qemu/Makerules:COMP = system/platforms/arm-qemu
system/platforms/arm-qemu/pl190.c:    regs->VICINTENABLE = 1U << irq;
system/platforms/arm-qemu/pl190.c:    regs->VICINTENCLEAR = 1U << irq;
system/platforms/arm-qemu/pl190.c:    uint32_t status = regs->VICIRQSTATUS;
system/platforms/arm-qemu/pl190.c:        uint irq = 31 - __builtin_clz(status);
system/platforms/arm-qemu/platforminit.c:const struct atag *atags_ptr = (void*)-1;
system/platforms/arm-qemu/platforminit.c:             atag->hdr.size > 2 && atag->hdr.tag != ATAG_NONE;
system/platforms/arm-qemu/platforminit.c:             atag = (const struct atag*)((const uint*)atag + atag->hdr.size))
system/platforms/arm-qemu/platforminit.c:            switch (atag->hdr.tag)
system/platforms/arm-qemu/platforminit.c:                    if (maxaddr == atag->mem.start && atag->mem.size != 0)
system/platforms/arm-qemu/platforminit.c:                        maxaddr += atag->mem.size;
system/platforms/arm-qemu/platforminit.c:                    platform.serial_low = atag->serialnr.low;
system/platforms/arm-qemu/platforminit.c:                    platform.serial_high = atag->serialnr.high;
system/platforms/arm-qemu/sp804.c: * clkupdate() and the second timer in the duo as a free-running counter for
system/platforms/arm-qemu/sp804.c:    /* Enable the second timer (free-running, no IRQ)  */
system/platforms/arm-qemu/sp804.c:    regs->timers[1].Control = SP804_TIMER_ENABLE | SP804_TIMER_32BIT;
system/platforms/arm-qemu/sp804.c:    return ~regs->timers[1].Value;
system/platforms/arm-qemu/sp804.c:    regs->timers[0].IntClr = 0;
system/platforms/arm-qemu/sp804.c:    regs->timers[0].Load = cycles;
system/platforms/arm-qemu/sp804.c:    regs->timers[0].Control = SP804_TIMER_ENABLE | SP804_TIMER_32BIT |
system/platforms/arm-rpi/Makerules:COMP = system/platforms/arm-rpi
system/platforms/arm-rpi/bcm2835.h: * be found in the Linux source (arch/arm/mach-bcm2708/include/mach/platform.h).
system/platforms/arm-rpi/bcm2835.h:/* Start of memory-mapped peripherals address space  */
system/platforms/arm-rpi/bcm2835.h:/* Synopsys DesignWare Hi-Speed USB 2.0 On-The-Go Controller  */
system/platforms/arm-rpi/bcm2835.h: * used here:  IRQs 0-63 are those shared between the GPU and CPU, whereas *
system/platforms/arm-rpi/bcm2835.h: * IRQs 64+ are CPU-specific.                                              *
system/platforms/arm-rpi/bcm2835.h:/* System timer - one IRQ line per output compare register.  */
system/platforms/arm-rpi/bcm2835.h:/* Synopsys DesignWare Hi-Speed USB 2.0 On-The-Go Controller  */
system/platforms/arm-rpi/bcm2835.h: * Board-specific power management  *
system/platforms/arm-rpi/bcm2835_power.c:/* The BCM2835 mailboxes are used for passing 28-bit messages.  The low 4 bits
system/platforms/arm-rpi/bcm2835_power.c: * of the 32-bit value are used to specify the channel over which the message is
system/platforms/arm-rpi/dispatch.c: * controls which IRQs the ARM receives.  The VideoCore co-processor likely has
system/platforms/arm-rpi/dispatch.c: * See http://xinu-os.org/BCM2835_Interrupt_Controller for additional
system/platforms/arm-rpi/dispatch.c:/* Number of ARM-specific IRQs. These correspond to IRQs that show up in the
system/platforms/arm-rpi/dispatch.c:        if (regs->IRQ_basic_pending & (1 << (irq_num - 64)))
system/platforms/arm-rpi/dispatch.c:        if (regs->IRQ_pending_2 & (1 << (irq_num - 32)))
system/platforms/arm-rpi/dispatch.c:        if (regs->IRQ_pending_1 & (1 << irq_num))
system/platforms/arm-rpi/dispatch.c:        /* The pending bit should have been cleared in a device-specific way by
system/platforms/arm-rpi/dispatch.c:    return 31 - __builtin_clz(word);
system/platforms/arm-rpi/dispatch.c: * the poorly-documented hardware and conflicts with the GPU.
system/platforms/arm-rpi/dispatch.c:        regs->Enable_IRQs_1 = 1 << irq_num;
system/platforms/arm-rpi/dispatch.c:        regs->Enable_IRQs_2 = 1 << (irq_num - 32);
system/platforms/arm-rpi/dispatch.c:        arm_enabled_irqs[1] |= 1 << (irq_num - 32);
system/platforms/arm-rpi/dispatch.c:        regs->Enable_Basic_IRQs = 1 << (irq_num - 64);
system/platforms/arm-rpi/dispatch.c:        arm_enabled_irqs[2] |= 1 << (irq_num - 64);
system/platforms/arm-rpi/dispatch.c:        regs->Disable_IRQs_1 = 1 << irq_num;
system/platforms/arm-rpi/dispatch.c:        regs->Disable_IRQs_2 = 1 << (irq_num - 32);
system/platforms/arm-rpi/dispatch.c:        arm_enabled_irqs[1] &= ~(1 << (irq_num - 32));
system/platforms/arm-rpi/dispatch.c:        regs->Disable_Basic_IRQs = 1 << (irq_num - 64);
system/platforms/arm-rpi/dispatch.c:        arm_enabled_irqs[2] &= ~(1 << (irq_num - 64));
system/platforms/arm-rpi/kexec.c: * This stub is hard-coded as an array because it needs to be copied to a
system/platforms/arm-rpi/kexec.c: * r1:  size of new kernel in 32-bit words
system/platforms/arm-rpi/kexec.c: * This is hard-coded to copy the kernel to address 0x8000.
system/platforms/arm-rpi/kexec.c:#define COPY_KERNEL_ADDR ((void*)(0x8000 - sizeof(copy_kernel)))
system/platforms/arm-rpi/kexec.c: * Kernel execute - Transfer control to a new kernel.
system/platforms/arm-rpi/platforminit.c:const struct atag *atags_ptr = (void*)-1;
system/platforms/arm-rpi/platforminit.c:             atag->hdr.size > 2 && atag->hdr.tag != ATAG_NONE;
system/platforms/arm-rpi/platforminit.c:             atag = (const struct atag*)((const uint*)atag + atag->hdr.size))
system/platforms/arm-rpi/platforminit.c:            switch (atag->hdr.tag)
system/platforms/arm-rpi/platforminit.c:                    if (maxaddr == atag->mem.start && atag->mem.size != 0)
system/platforms/arm-rpi/platforminit.c:                        maxaddr += atag->mem.size;
system/platforms/arm-rpi/platforminit.c:                    platform.serial_low = atag->serialnr.low;
system/platforms/arm-rpi/platforminit.c:                    platform.serial_high = atag->serialnr.high;
system/platforms/arm-rpi/timer.c: * See 12. "System Timer" of the BCM2835-ARM-Peripherals.pdf document for
system/platforms/arm-rpi/timer.c: * connected to (it's IRQs 0-3 mapped linearly onto the output compare
system/platforms/arm-rpi/timer.c: * See http://xinu-os.org/BCM2835_System_Timer for more information about this
system/platforms/arm-rpi/timer.c: * Raspberry-Pi specific note:  This function returns the low-order 32 bits of
system/platforms/arm-rpi/timer.c: * the BCM2835's free-running counter.  This counter runs at 1 MHz and therefore
system/platforms/arm-rpi/timer.c:    count = regs->CLO;
system/platforms/arm-rpi/timer.c:    regs->CS = BCM2835_SYSTEM_TIMER_MATCH_3;
system/platforms/arm-rpi/timer.c:     * done by reading the current low-order bits of the counter and adding the
system/platforms/arm-rpi/timer.c:    regs->C3 = regs->CLO + cycles;
system/platforms/arm-rpi/usb_dwc_hcd.c: * Hi-Speed USB 2.0 On-The-Go Controller.
system/platforms/arm-rpi/usb_dwc_hcd.c: * DesignWare Hi-Speed USB 2.0 On-The-Go Controller, henceforth abbreviated as
system/platforms/arm-rpi/usb_dwc_hcd.c: * was written on a best-effort basis using several sources to gleam the
system/platforms/arm-rpi/usb_dwc_hcd.c: * to understand vendor-provided Linux driver.
system/platforms/arm-rpi/usb_dwc_hcd.c: * The DWC is controlled by reading and writing to/from memory-mapped registers.
system/platforms/arm-rpi/usb_dwc_hcd.c: * transfers in an interrupt-driven manner.  However, due to design flaws in
system/platforms/arm-rpi/usb_dwc_hcd.c: * though each individual transfer is itself interrupt-driven.  This means that,
system/platforms/arm-rpi/usb_dwc_hcd.c: * The "On-The-Go" in the name of this hardware means that it supports the USB
system/platforms/arm-rpi/usb_dwc_hcd.c: * On-The-Go protocol, which allows it to act either as a host or a device.
system/platforms/arm-rpi/usb_dwc_hcd.c:#define WORD_ALIGN(n) (((n) + sizeof(ulong) - 1) & ~(sizeof(ulong) - 1))
system/platforms/arm-rpi/usb_dwc_hcd.c:/** Determines whether a pointer is word-aligned or not.  */
system/platforms/arm-rpi/usb_dwc_hcd.c:/** Pointer to the memory-mapped registers of the Synopsys DesignWare Hi-Speed
system/platforms/arm-rpi/usb_dwc_hcd.c: * Name of USB defer transfer threads.  Note: including the null-terminator this
system/platforms/arm-rpi/usb_dwc_hcd.c:/** Bitmap of channel free (1) or in-use (0) statuses.  */
system/platforms/arm-rpi/usb_dwc_hcd.c:/** Bitmap of channels waiting for start-of-frame  */
system/platforms/arm-rpi/usb_dwc_hcd.c:    return 31 - __builtin_clz(word);
system/platforms/arm-rpi/usb_dwc_hcd.c:    usb_info("Powering on Synopsys DesignWare Hi-Speed "
system/platforms/arm-rpi/usb_dwc_hcd.c:             "USB 2.0 On-The-Go Controller\n");
system/platforms/arm-rpi/usb_dwc_hcd.c:    usb_info("Powering off Synopsys DesignWare Hi-Speed "
system/platforms/arm-rpi/usb_dwc_hcd.c:             "USB 2.0 On-The-Go Controller\n");
system/platforms/arm-rpi/usb_dwc_hcd.c:    regs->core_reset = DWC_SOFT_RESET;
system/platforms/arm-rpi/usb_dwc_hcd.c:    while (regs->core_reset & DWC_SOFT_RESET)
system/platforms/arm-rpi/usb_dwc_hcd.c: * makes it possible for the Host Controller to directly access in-memory
system/platforms/arm-rpi/usb_dwc_hcd.c: * must be 4-byte-aligned.  Furthermore, if the L1 data cache is enabled, then
system/platforms/arm-rpi/usb_dwc_hcd.c:    const uint32_t rx_words = 1024;  /* Size of Rx FIFO in 4-byte words */
system/platforms/arm-rpi/usb_dwc_hcd.c:    const uint32_t tx_words = 1024;  /* Size of Non-periodic Tx FIFO in 4-byte words */
system/platforms/arm-rpi/usb_dwc_hcd.c:    const uint32_t ptx_words = 1024; /* Size of Periodic Tx FIFO in 4-byte words */
system/platforms/arm-rpi/usb_dwc_hcd.c:    usb_debug("%u words of RAM available for dynamic FIFOs\n", regs->hwcfg3 >> 16);
system/platforms/arm-rpi/usb_dwc_hcd.c:              regs->rx_fifo_size, regs->nonperiodic_tx_fifo_size,
system/platforms/arm-rpi/usb_dwc_hcd.c:              regs->host_periodic_tx_fifo_size);
system/platforms/arm-rpi/usb_dwc_hcd.c:    regs->rx_fifo_size = rx_words;
system/platforms/arm-rpi/usb_dwc_hcd.c:    regs->nonperiodic_tx_fifo_size = (tx_words << 16) | rx_words;
system/platforms/arm-rpi/usb_dwc_hcd.c:    regs->host_periodic_tx_fifo_size = (ptx_words << 16) | (rx_words + tx_words);
system/platforms/arm-rpi/usb_dwc_hcd.c:    regs->ahb_configuration |= DWC_AHB_DMA_ENABLE | BCM_DWC_AHB_AXI_WAIT;
system/platforms/arm-rpi/usb_dwc_hcd.c: * this requires zeroing the write-clear bits so they aren't unintentionally
system/platforms/arm-rpi/usb_dwc_hcd.c:    union dwc_host_port_ctrlstatus hw_status = regs->host_port_ctrlstatus;
system/platforms/arm-rpi/usb_dwc_hcd.c:    regs->host_port_ctrlstatus = hw_status;
system/platforms/arm-rpi/usb_dwc_hcd.c:    regs->host_port_ctrlstatus = hw_status;
system/platforms/arm-rpi/usb_dwc_hcd.c:    regs->host_port_ctrlstatus = hw_status;
system/platforms/arm-rpi/usb_dwc_hcd.c:/** Hard-coded device descriptor for the faked root hub.  */
system/platforms/arm-rpi/usb_dwc_hcd.c:    .bcdUSB = 0x200, /* USB version 2.0 (binary-coded decimal) */
system/platforms/arm-rpi/usb_dwc_hcd.c:/** Hard-coded configuration descriptor, along with an associated interface
system/platforms/arm-rpi/usb_dwc_hcd.c:/** Hard-coded list of language IDs for the faked root hub.  */
system/platforms/arm-rpi/usb_dwc_hcd.c:/** Hard-coded product string for the faked root hub.  */
system/platforms/arm-rpi/usb_dwc_hcd.c:    /* This is a UTF-16LE string, hence the array of individual characters
system/platforms/arm-rpi/usb_dwc_hcd.c:/** Hard-coded table of strings for the faked root hub.  */
system/platforms/arm-rpi/usb_dwc_hcd.c:/** Hard-coded hub descriptor for the faked root hub.  */
system/platforms/arm-rpi/usb_dwc_hcd.c:/** Hard-coded hub status for the faked root hub.  */
system/platforms/arm-rpi/usb_dwc_hcd.c:        *(uint8_t*)req->recvbuf = 0x2; /* 0x2 means Port 1 status changed (bit 0 is
system/platforms/arm-rpi/usb_dwc_hcd.c:        req->actual_size = 1;
system/platforms/arm-rpi/usb_dwc_hcd.c:        req->status = USB_STATUS_SUCCESS;
system/platforms/arm-rpi/usb_dwc_hcd.c: * Fake a standard (i.e. not hub-specific) control message request to the root
system/platforms/arm-rpi/usb_dwc_hcd.c:    const struct usb_control_setup_data *setup = &req->setup_data;
system/platforms/arm-rpi/usb_dwc_hcd.c:    switch (setup->bRequest)
system/platforms/arm-rpi/usb_dwc_hcd.c:            len = min(setup->wLength, sizeof(root_hub_device_status));
system/platforms/arm-rpi/usb_dwc_hcd.c:            memcpy(req->recvbuf, &root_hub_device_status, len);
system/platforms/arm-rpi/usb_dwc_hcd.c:            req->actual_size = len;
system/platforms/arm-rpi/usb_dwc_hcd.c:            switch ((setup->wValue >> 8)) /* Switch on descriptor type */
system/platforms/arm-rpi/usb_dwc_hcd.c:                    len = min(setup->wLength, root_hub_device_descriptor.bLength);
system/platforms/arm-rpi/usb_dwc_hcd.c:                    memcpy(req->recvbuf, &root_hub_device_descriptor, len);
system/platforms/arm-rpi/usb_dwc_hcd.c:                    req->actual_size = len;
system/platforms/arm-rpi/usb_dwc_hcd.c:                    len = min(setup->wLength,
system/platforms/arm-rpi/usb_dwc_hcd.c:                    memcpy(req->recvbuf, &root_hub_configuration, len);
system/platforms/arm-rpi/usb_dwc_hcd.c:                    req->actual_size = len;
system/platforms/arm-rpi/usb_dwc_hcd.c:                    if ((setup->wValue & 0xff) < ARRAY_LEN(root_hub_strings))
system/platforms/arm-rpi/usb_dwc_hcd.c:                                root_hub_strings[setup->wValue & 0xff];
system/platforms/arm-rpi/usb_dwc_hcd.c:                        len = min(setup->wLength, desc->bLength);
system/platforms/arm-rpi/usb_dwc_hcd.c:                        memcpy(req->recvbuf, desc, len);
system/platforms/arm-rpi/usb_dwc_hcd.c:                        req->actual_size = len;
system/platforms/arm-rpi/usb_dwc_hcd.c:            if (setup->wLength >= 1)
system/platforms/arm-rpi/usb_dwc_hcd.c:                *(uint8_t*)req->recvbuf = req->dev->configuration;
system/platforms/arm-rpi/usb_dwc_hcd.c:                req->actual_size = 1;
system/platforms/arm-rpi/usb_dwc_hcd.c:            if (setup->wValue <= 1)
system/platforms/arm-rpi/usb_dwc_hcd.c:    status->wHubStatus = 0;
system/platforms/arm-rpi/usb_dwc_hcd.c:    status->wHubChange = 0;
system/platforms/arm-rpi/usb_dwc_hcd.c:    status->local_power = 1;
system/platforms/arm-rpi/usb_dwc_hcd.c: * Fake a hub-class-specific control message request to the root hub.
system/platforms/arm-rpi/usb_dwc_hcd.c: *      Hub-class-specific request to the root hub to fake.
system/platforms/arm-rpi/usb_dwc_hcd.c:    const struct usb_control_setup_data *setup = &req->setup_data;
system/platforms/arm-rpi/usb_dwc_hcd.c:    switch (setup->bRequest)
system/platforms/arm-rpi/usb_dwc_hcd.c:            switch ((setup->wValue >> 8)) /* Switch on descriptor type */
system/platforms/arm-rpi/usb_dwc_hcd.c:                    len = min(setup->wLength, root_hub_hub_descriptor.bDescLength);
system/platforms/arm-rpi/usb_dwc_hcd.c:                    memcpy(req->recvbuf, &root_hub_hub_descriptor, len);
system/platforms/arm-rpi/usb_dwc_hcd.c:                    req->actual_size = len;
system/platforms/arm-rpi/usb_dwc_hcd.c:            switch (setup->bmRequestType & USB_BMREQUESTTYPE_RECIPIENT_MASK)
system/platforms/arm-rpi/usb_dwc_hcd.c:                    if (setup->wLength >= sizeof(struct usb_hub_status))
system/platforms/arm-rpi/usb_dwc_hcd.c:                        dwc_get_root_hub_status(req->recvbuf);
system/platforms/arm-rpi/usb_dwc_hcd.c:                        req->actual_size = sizeof(struct usb_hub_status);
system/platforms/arm-rpi/usb_dwc_hcd.c:                    if (setup->wLength >= sizeof(struct usb_port_status))
system/platforms/arm-rpi/usb_dwc_hcd.c:                        memcpy(req->recvbuf, &host_port_status,
system/platforms/arm-rpi/usb_dwc_hcd.c:                        req->actual_size = sizeof(struct usb_port_status);
system/platforms/arm-rpi/usb_dwc_hcd.c:            switch (setup->bmRequestType & USB_BMREQUESTTYPE_RECIPIENT_MASK)
system/platforms/arm-rpi/usb_dwc_hcd.c:                    return dwc_set_host_port_feature(setup->wValue);
system/platforms/arm-rpi/usb_dwc_hcd.c:            switch (setup->bmRequestType & USB_BMREQUESTTYPE_RECIPIENT_MASK)
system/platforms/arm-rpi/usb_dwc_hcd.c:                    return dwc_clear_host_port_feature(setup->wValue);
system/platforms/arm-rpi/usb_dwc_hcd.c:    switch (req->setup_data.bmRequestType & USB_BMREQUESTTYPE_TYPE_MASK)
system/platforms/arm-rpi/usb_dwc_hcd.c:    if (req->endpoint_desc == NULL)
system/platforms/arm-rpi/usb_dwc_hcd.c:        req->status = dwc_root_hub_control_msg(req);
system/platforms/arm-rpi/usb_dwc_hcd.c: * Starts a low-level transaction on the USB.
system/platforms/arm-rpi/usb_dwc_hcd.c:    volatile struct dwc_host_channel *chanptr = &regs->host_channels[chan];
system/platforms/arm-rpi/usb_dwc_hcd.c:    chanptr->interrupt_mask.val = 0;
system/platforms/arm-rpi/usb_dwc_hcd.c:    chanptr->interrupts.val = 0xffffffff;
system/platforms/arm-rpi/usb_dwc_hcd.c:    split_control = chanptr->split_control;
system/platforms/arm-rpi/usb_dwc_hcd.c:    split_control.complete_split = req->complete_split;
system/platforms/arm-rpi/usb_dwc_hcd.c:    chanptr->split_control = split_control;
system/platforms/arm-rpi/usb_dwc_hcd.c:    next_frame = (regs->host_frame_number & 0xffff) + 1;
system/platforms/arm-rpi/usb_dwc_hcd.c:        req->csplit_retries = 0;
system/platforms/arm-rpi/usb_dwc_hcd.c:    characteristics = chanptr->characteristics;
system/platforms/arm-rpi/usb_dwc_hcd.c:    chanptr->characteristics = characteristics;
system/platforms/arm-rpi/usb_dwc_hcd.c:    chanptr->interrupt_mask = interrupt_mask;
system/platforms/arm-rpi/usb_dwc_hcd.c:    regs->host_channels_interrupt_mask |= 1 << chan;
system/platforms/arm-rpi/usb_dwc_hcd.c: * Starts or restarts a USB transfer on a channel of the DesignWare Hi-Speed USB
system/platforms/arm-rpi/usb_dwc_hcd.c: * To do this, software must give the parameters of a series of low-level
system/platforms/arm-rpi/usb_dwc_hcd.c:    chanptr = &regs->host_channels[chan];
system/platforms/arm-rpi/usb_dwc_hcd.c:    req->short_attempt = 0;
system/platforms/arm-rpi/usb_dwc_hcd.c:    if (req->endpoint_desc != NULL)
system/platforms/arm-rpi/usb_dwc_hcd.c:                                    req->endpoint_desc->bEndpointAddress & 0xf;
system/platforms/arm-rpi/usb_dwc_hcd.c:                                    req->endpoint_desc->bmAttributes & 0x3;
system/platforms/arm-rpi/usb_dwc_hcd.c:                                    req->endpoint_desc->wMaxPacketSize & 0x7ff;
system/platforms/arm-rpi/usb_dwc_hcd.c:        if (req->dev->speed == USB_SPEED_HIGH)
system/platforms/arm-rpi/usb_dwc_hcd.c:                        ((req->endpoint_desc->wMaxPacketSize >> 11) & 0x3);
system/platforms/arm-rpi/usb_dwc_hcd.c:         * packets per frame are pre-determined, while the maximum packet size
system/platforms/arm-rpi/usb_dwc_hcd.c:        characteristics.max_packet_size = req->dev->descriptor.bMaxPacketSize0;
system/platforms/arm-rpi/usb_dwc_hcd.c:        switch (req->control_phase)
system/platforms/arm-rpi/usb_dwc_hcd.c:                usb_dev_debug(req->dev, "Starting SETUP transaction\n");
system/platforms/arm-rpi/usb_dwc_hcd.c:                data = &req->setup_data;
system/platforms/arm-rpi/usb_dwc_hcd.c:                usb_dev_debug(req->dev, "Starting DATA transactions\n");
system/platforms/arm-rpi/usb_dwc_hcd.c:                                        req->setup_data.bmRequestType >> 7;
system/platforms/arm-rpi/usb_dwc_hcd.c:                 * re-starting a partially complete transfer.  */
system/platforms/arm-rpi/usb_dwc_hcd.c:                data = req->recvbuf + req->actual_size;
system/platforms/arm-rpi/usb_dwc_hcd.c:                transfer.size = req->size - req->actual_size;
system/platforms/arm-rpi/usb_dwc_hcd.c:                if (req->actual_size == 0)
system/platforms/arm-rpi/usb_dwc_hcd.c:                    transfer.packet_id = req->next_data_pid;
system/platforms/arm-rpi/usb_dwc_hcd.c:                usb_dev_debug(req->dev, "Starting STATUS transaction\n");
system/platforms/arm-rpi/usb_dwc_hcd.c:                if ((req->setup_data.bmRequestType >> 7) == USB_DIRECTION_OUT ||
system/platforms/arm-rpi/usb_dwc_hcd.c:                    req->setup_data.wLength == 0)
system/platforms/arm-rpi/usb_dwc_hcd.c:    else /* Starting or re-starting a non-control transfer.  */
system/platforms/arm-rpi/usb_dwc_hcd.c:                    req->endpoint_desc->bEndpointAddress >> 7;
system/platforms/arm-rpi/usb_dwc_hcd.c:        data = req->recvbuf + req->actual_size;
system/platforms/arm-rpi/usb_dwc_hcd.c:        transfer.size = req->size - req->actual_size;
system/platforms/arm-rpi/usb_dwc_hcd.c:         * data than fits in one (micro)frame--- that is, the maximum packets
system/platforms/arm-rpi/usb_dwc_hcd.c:            req->short_attempt = 1;
system/platforms/arm-rpi/usb_dwc_hcd.c:        transfer.packet_id = req->next_data_pid;
system/platforms/arm-rpi/usb_dwc_hcd.c:    characteristics.device_address = req->dev->address;
system/platforms/arm-rpi/usb_dwc_hcd.c:    /* If communicating with a low or full-speed device, program the split
system/platforms/arm-rpi/usb_dwc_hcd.c:     * Channel Characteristics register if communicating with a low-speed
system/platforms/arm-rpi/usb_dwc_hcd.c:    if (req->dev->speed != USB_SPEED_HIGH)
system/platforms/arm-rpi/usb_dwc_hcd.c:        tt_hub = req->dev;
system/platforms/arm-rpi/usb_dwc_hcd.c:            tt_hub_port = tt_hub->port_number;
system/platforms/arm-rpi/usb_dwc_hcd.c:            tt_hub = tt_hub->parent;
system/platforms/arm-rpi/usb_dwc_hcd.c:        } while (tt_hub->speed != USB_SPEED_HIGH);
system/platforms/arm-rpi/usb_dwc_hcd.c:        split_control.port_address = tt_hub_port - 1;
system/platforms/arm-rpi/usb_dwc_hcd.c:        split_control.hub_address = tt_hub->address;
system/platforms/arm-rpi/usb_dwc_hcd.c:            req->short_attempt = 1;
system/platforms/arm-rpi/usb_dwc_hcd.c:        if (req->dev->speed == USB_SPEED_LOW)
system/platforms/arm-rpi/usb_dwc_hcd.c:        /* Can DMA directly from source or to destination if word-aligned.  */
system/platforms/arm-rpi/usb_dwc_hcd.c:        chanptr->dma_address = (uint32_t)data;
system/platforms/arm-rpi/usb_dwc_hcd.c:         * destination is not word-aligned.  If the attempted transfer size
system/platforms/arm-rpi/usb_dwc_hcd.c:        chanptr->dma_address = (uint32_t)aligned_bufs[chan];
system/platforms/arm-rpi/usb_dwc_hcd.c:            transfer.size = sizeof(aligned_bufs[chan]) -
system/platforms/arm-rpi/usb_dwc_hcd.c:            req->short_attempt = 1;
system/platforms/arm-rpi/usb_dwc_hcd.c:    req->cur_data_ptr = data;
system/platforms/arm-rpi/usb_dwc_hcd.c:         * zero-length transfers.  */
system/platforms/arm-rpi/usb_dwc_hcd.c:    req->attempted_size = transfer.size;
system/platforms/arm-rpi/usb_dwc_hcd.c:    req->attempted_bytes_remaining = transfer.size;
system/platforms/arm-rpi/usb_dwc_hcd.c:    req->attempted_packets_remaining = transfer.packet_count;
system/platforms/arm-rpi/usb_dwc_hcd.c:    usb_dev_debug(req->dev, "Setting up transactions on channel %u:\n"
system/platforms/arm-rpi/usb_dwc_hcd.c:                  req->complete_split);
system/platforms/arm-rpi/usb_dwc_hcd.c:    chanptr->characteristics = characteristics;
system/platforms/arm-rpi/usb_dwc_hcd.c:    chanptr->split_control   = split_control;
system/platforms/arm-rpi/usb_dwc_hcd.c:    chanptr->transfer        = transfer;
system/platforms/arm-rpi/usb_dwc_hcd.c:    if (req->dev->speed == USB_SPEED_HIGH)
system/platforms/arm-rpi/usb_dwc_hcd.c:        interval_ms = (1 << (req->endpoint_desc->bInterval - 1)) /
system/platforms/arm-rpi/usb_dwc_hcd.c:        interval_ms = req->endpoint_desc->bInterval / USB_FRAMES_PER_MS;
system/platforms/arm-rpi/usb_dwc_hcd.c:        wait(req->deferer_thread_sema);
system/platforms/arm-rpi/usb_dwc_hcd.c:        if (req->need_sof)
system/platforms/arm-rpi/usb_dwc_hcd.c:            usb_dev_debug(req->dev,
system/platforms/arm-rpi/usb_dwc_hcd.c:                          "Waiting for start-of-frame\n");
system/platforms/arm-rpi/usb_dwc_hcd.c:            intr_mask = regs->core_interrupt_mask;
system/platforms/arm-rpi/usb_dwc_hcd.c:            regs->core_interrupt_mask = intr_mask;
system/platforms/arm-rpi/usb_dwc_hcd.c:            req->need_sof = 0;
system/platforms/arm-rpi/usb_dwc_hcd.c:            usb_dev_debug(req->dev,
system/platforms/arm-rpi/usb_dwc_hcd.c: * the endpoint descriptor.  For low and full-speed devices, bInterval specifies
system/platforms/arm-rpi/usb_dwc_hcd.c: * the number of millisconds to wait before the next poll, while for high-speed
system/platforms/arm-rpi/usb_dwc_hcd.c: * devices it specifies the exponent (plus one) of a power-of-two number of
system/platforms/arm-rpi/usb_dwc_hcd.c: * thread created on-demand.  Each such thread simply enters a loop where it
system/platforms/arm-rpi/usb_dwc_hcd.c:    usb_dev_debug(req->dev, "Deferring transfer\n");
system/platforms/arm-rpi/usb_dwc_hcd.c:    if (SYSERR == req->deferer_thread_sema)
system/platforms/arm-rpi/usb_dwc_hcd.c:        req->deferer_thread_sema = semcreate(0);
system/platforms/arm-rpi/usb_dwc_hcd.c:        if (SYSERR == req->deferer_thread_sema)
system/platforms/arm-rpi/usb_dwc_hcd.c:            usb_dev_error(req->dev, "Can't create semaphore\n");
system/platforms/arm-rpi/usb_dwc_hcd.c:    if (BADTID == req->deferer_thread_tid)
system/platforms/arm-rpi/usb_dwc_hcd.c:        req->deferer_thread_tid = create(defer_xfer_thread,
system/platforms/arm-rpi/usb_dwc_hcd.c:        if (SYSERR == ready(req->deferer_thread_tid, RESCHED_NO))
system/platforms/arm-rpi/usb_dwc_hcd.c:            req->deferer_thread_tid = BADTID;
system/platforms/arm-rpi/usb_dwc_hcd.c:            usb_dev_error(req->dev,
system/platforms/arm-rpi/usb_dwc_hcd.c:    signal(req->deferer_thread_sema);
system/platforms/arm-rpi/usb_dwc_hcd.c:    volatile struct dwc_host_channel *chanptr = &regs->host_channels[chan];
system/platforms/arm-rpi/usb_dwc_hcd.c:    uint packets_remaining   = chanptr->transfer.packet_count;
system/platforms/arm-rpi/usb_dwc_hcd.c:    uint packets_transferred = req->attempted_packets_remaining -
system/platforms/arm-rpi/usb_dwc_hcd.c:    usb_dev_debug(req->dev, "%u packets transferred on channel %u\n",
system/platforms/arm-rpi/usb_dwc_hcd.c:                                            chanptr->characteristics;
system/platforms/arm-rpi/usb_dwc_hcd.c:            bytes_transferred = req->attempted_bytes_remaining -
system/platforms/arm-rpi/usb_dwc_hcd.c:                                chanptr->transfer.size;
system/platforms/arm-rpi/usb_dwc_hcd.c:            if (!IS_WORD_ALIGNED(req->cur_data_ptr))
system/platforms/arm-rpi/usb_dwc_hcd.c:                memcpy(req->cur_data_ptr,
system/platforms/arm-rpi/usb_dwc_hcd.c:                       &aligned_bufs[chan][req->attempted_size -
system/platforms/arm-rpi/usb_dwc_hcd.c:                                           req->attempted_bytes_remaining],
system/platforms/arm-rpi/usb_dwc_hcd.c:                bytes_transferred += max_packet_size * (packets_transferred - 1);
system/platforms/arm-rpi/usb_dwc_hcd.c:                (req->attempted_size % max_packet_size != 0 ||
system/platforms/arm-rpi/usb_dwc_hcd.c:                 req->attempted_size == 0))
system/platforms/arm-rpi/usb_dwc_hcd.c:                bytes_transferred += req->attempted_size % max_packet_size;
system/platforms/arm-rpi/usb_dwc_hcd.c:        usb_dev_debug(req->dev, "Calculated %u bytes transferred\n",
system/platforms/arm-rpi/usb_dwc_hcd.c:        req->attempted_packets_remaining -= packets_transferred;
system/platforms/arm-rpi/usb_dwc_hcd.c:        req->attempted_bytes_remaining -= bytes_transferred;
system/platforms/arm-rpi/usb_dwc_hcd.c:        req->cur_data_ptr += bytes_transferred;
system/platforms/arm-rpi/usb_dwc_hcd.c:        if (req->attempted_packets_remaining == 0 ||
system/platforms/arm-rpi/usb_dwc_hcd.c:                usb_dev_error(req->dev, "transfer_completed flag not "
system/platforms/arm-rpi/usb_dwc_hcd.c:                              interrupts.val, chanptr->transfer.val);
system/platforms/arm-rpi/usb_dwc_hcd.c:             * channels (for one of several reasons--- see
system/platforms/arm-rpi/usb_dwc_hcd.c:            if (req->short_attempt && req->attempted_bytes_remaining == 0 &&
system/platforms/arm-rpi/usb_dwc_hcd.c:                usb_dev_debug(req->dev,
system/platforms/arm-rpi/usb_dwc_hcd.c:                              "Starting next part of %u-byte transfer "
system/platforms/arm-rpi/usb_dwc_hcd.c:                              req->size, req->attempted_size);
system/platforms/arm-rpi/usb_dwc_hcd.c:                req->complete_split = 0;
system/platforms/arm-rpi/usb_dwc_hcd.c:                req->next_data_pid = chanptr->transfer.packet_id;
system/platforms/arm-rpi/usb_dwc_hcd.c:                if (!usb_is_control_request(req) || req->control_phase == 1)
system/platforms/arm-rpi/usb_dwc_hcd.c:                    req->actual_size = req->cur_data_ptr - req->recvbuf;
system/platforms/arm-rpi/usb_dwc_hcd.c:            if (usb_is_control_request(req) && req->control_phase < 2)
system/platforms/arm-rpi/usb_dwc_hcd.c:                req->complete_split = 0;
system/platforms/arm-rpi/usb_dwc_hcd.c:                if (req->control_phase == 1)
system/platforms/arm-rpi/usb_dwc_hcd.c:                    req->actual_size = req->cur_data_ptr - req->recvbuf;
system/platforms/arm-rpi/usb_dwc_hcd.c:                req->control_phase++;
system/platforms/arm-rpi/usb_dwc_hcd.c:                if (req->control_phase == 1 && req->size == 0)
system/platforms/arm-rpi/usb_dwc_hcd.c:                    req->control_phase++;
system/platforms/arm-rpi/usb_dwc_hcd.c:            usb_dev_debug(req->dev, "Transfer completed on channel %u\n", chan);
system/platforms/arm-rpi/usb_dwc_hcd.c:            if (chanptr->split_control.split_enable)
system/platforms/arm-rpi/usb_dwc_hcd.c:                req->complete_split ^= 1;
system/platforms/arm-rpi/usb_dwc_hcd.c:            usb_dev_debug(req->dev, "Continuing transfer (complete_split=%u)\n",
system/platforms/arm-rpi/usb_dwc_hcd.c:                          req->complete_split);
system/platforms/arm-rpi/usb_dwc_hcd.c:            chanptr->split_control.split_enable && !req->complete_split)
system/platforms/arm-rpi/usb_dwc_hcd.c:            req->complete_split = 1;
system/platforms/arm-rpi/usb_dwc_hcd.c:            usb_dev_debug(req->dev, "Continuing transfer (complete_split=%u)\n",
system/platforms/arm-rpi/usb_dwc_hcd.c:                          req->complete_split);
system/platforms/arm-rpi/usb_dwc_hcd.c:            usb_dev_error(req->dev, "No packets transferred.\n");
system/platforms/arm-rpi/usb_dwc_hcd.c:    volatile struct dwc_host_channel *chanptr = &regs->host_channels[chan];
system/platforms/arm-rpi/usb_dwc_hcd.c:    union dwc_host_channel_interrupts interrupts = chanptr->interrupts;
system/platforms/arm-rpi/usb_dwc_hcd.c:              chan, interrupts.val, chanptr->characteristics.val,
system/platforms/arm-rpi/usb_dwc_hcd.c:              chanptr->transfer.val);
system/platforms/arm-rpi/usb_dwc_hcd.c:        (interrupts.nyet_response_received && !req->complete_split) ||
system/platforms/arm-rpi/usb_dwc_hcd.c:         chanptr->characteristics.endpoint_direction == USB_DIRECTION_OUT))
system/platforms/arm-rpi/usb_dwc_hcd.c:        usb_dev_error(req->dev, "Transfer error on channel %u "
system/platforms/arm-rpi/usb_dwc_hcd.c:                      chan, interrupts.val, chanptr->transfer.packet_count);
system/platforms/arm-rpi/usb_dwc_hcd.c:        usb_dev_debug(req->dev, "Frame overrun on channel %u; "
system/platforms/arm-rpi/usb_dwc_hcd.c:        usb_dev_debug(req->dev, "NYET response received on channel %u\n", chan);
system/platforms/arm-rpi/usb_dwc_hcd.c:        if (++req->csplit_retries >= 10)
system/platforms/arm-rpi/usb_dwc_hcd.c:            usb_dev_debug(req->dev, "Restarting split transaction "
system/platforms/arm-rpi/usb_dwc_hcd.c:                          "(CSPLIT tried %u times)\n", req->csplit_retries);
system/platforms/arm-rpi/usb_dwc_hcd.c:            req->complete_split = FALSE;
system/platforms/arm-rpi/usb_dwc_hcd.c:        usb_dev_debug(req->dev, "NAK response received on channel %u\n", chan);
system/platforms/arm-rpi/usb_dwc_hcd.c:        req->complete_split = FALSE;
system/platforms/arm-rpi/usb_dwc_hcd.c:        usb_is_interrupt_request(req) && req->dev->speed != USB_SPEED_HIGH &&
system/platforms/arm-rpi/usb_dwc_hcd.c:        !req->complete_split)
system/platforms/arm-rpi/usb_dwc_hcd.c:        req->need_sof = 1;
system/platforms/arm-rpi/usb_dwc_hcd.c:            req->status = USB_STATUS_SUCCESS;
system/platforms/arm-rpi/usb_dwc_hcd.c:            req->status = USB_STATUS_HARDWARE_ERROR;
system/platforms/arm-rpi/usb_dwc_hcd.c:    req->next_data_pid = chanptr->transfer.packet_id;
system/platforms/arm-rpi/usb_dwc_hcd.c:    chanptr->interrupt_mask.val = 0;
system/platforms/arm-rpi/usb_dwc_hcd.c:    chanptr->interrupts.val = 0xffffffff;
system/platforms/arm-rpi/usb_dwc_hcd.c:    if (!usb_is_control_request(req) || req->control_phase == 1)
system/platforms/arm-rpi/usb_dwc_hcd.c:        req->actual_size = req->cur_data_ptr - req->recvbuf;
system/platforms/arm-rpi/usb_dwc_hcd.c:            req->status = status;
system/platforms/arm-rpi/usb_dwc_hcd.c:     * occurred, call the device-driver-provided completion callback.  */
system/platforms/arm-rpi/usb_dwc_hcd.c: * Interrupt handler function for the Synopsys DesignWare Hi-Speed USB 2.0
system/platforms/arm-rpi/usb_dwc_hcd.c: * On-The-Go Controller (DWC).  This should only be called when an interrupt
system/platforms/arm-rpi/usb_dwc_hcd.c:     * being executed re-entrantly.  */
system/platforms/arm-rpi/usb_dwc_hcd.c:    union dwc_core_interrupts interrupts = regs->core_interrupts;
system/platforms/arm-rpi/usb_dwc_hcd.c:                  regs->host_frame_number);
system/platforms/arm-rpi/usb_dwc_hcd.c:        if ((regs->host_frame_number & 0x7) != 6)
system/platforms/arm-rpi/usb_dwc_hcd.c:                send(channel_pending_xfers[chan]->deferer_thread_tid, 0);
system/platforms/arm-rpi/usb_dwc_hcd.c:                tmp = regs->core_interrupt_mask;
system/platforms/arm-rpi/usb_dwc_hcd.c:                regs->core_interrupt_mask = tmp;
system/platforms/arm-rpi/usb_dwc_hcd.c:            regs->core_interrupts = tmp;
system/platforms/arm-rpi/usb_dwc_hcd.c:        chintr = regs->host_channels_interrupt;
system/platforms/arm-rpi/usb_dwc_hcd.c:        union dwc_host_port_ctrlstatus hw_status = regs->host_port_ctrlstatus;
system/platforms/arm-rpi/usb_dwc_hcd.c:        /* Clear the interrupt(s), which are "write-clear", by writing the Host
system/platforms/arm-rpi/usb_dwc_hcd.c:        regs->host_port_ctrlstatus = hw_status;
system/platforms/arm-rpi/usb_dwc_hcd.c:    if (--resdefer > 0)
system/platforms/arm-rpi/usb_dwc_hcd.c: * Performs initial setup of the Synopsys Designware USB 2.0 On-The-Go
system/platforms/arm-rpi/usb_dwc_hcd.c: * - The AHB configuration register contains a mask bit used to enable/disable
system/platforms/arm-rpi/usb_dwc_hcd.c: * - The "Core" interrupt and interrupt mask registers control top-level
system/platforms/arm-rpi/usb_dwc_hcd.c: * - The "Host All Channels" interrupt and interrupt mask registers control all
system/platforms/arm-rpi/usb_dwc_hcd.c: * - The "Channel" interrupt and interrupt mask registers, of which one copy
system/platforms/arm-rpi/usb_dwc_hcd.c: * The above just covers the DWC-specific interrupt registers.  In addition to
system/platforms/arm-rpi/usb_dwc_hcd.c:    regs->core_interrupt_mask.val = 0;
system/platforms/arm-rpi/usb_dwc_hcd.c:    regs->core_interrupts.val = 0xffffffff;
system/platforms/arm-rpi/usb_dwc_hcd.c:    regs->core_interrupt_mask = core_interrupt_mask;
system/platforms/arm-rpi/usb_dwc_hcd.c:    regs->ahb_configuration |= DWC_AHB_INTERRUPT_ENABLE;
system/platforms/arm-rpi/usb_dwc_hcd.c:        if (is_root_hub(req->dev))
system/platforms/arm-rpi/usb_dwc_hcd.c:    chfree = (1 << DWC_NUM_CHANNELS) - 1;
system/platforms/arm-rpi/usb_dwc_hcd.c:/* Implementation of hcd_start() for the DesignWare Hi-Speed USB 2.0 On-The-Go
system/platforms/arm-rpi/usb_dwc_hcd.c:/* Implementation of hcd_stop() for the DesignWare Hi-Speed USB 2.0 On-The-Go
system/platforms/arm-rpi/usb_dwc_hcd.c:/* Implementation of hcd_submit_xfer_request() for the DesignWare Hi-Speed USB
system/platforms/arm-rpi/usb_dwc_hcd.c: * 2.0 On-The-Go Controller.  See usb_hcdi.h for the documentation of this
system/platforms/arm-rpi/usb_dwc_regs.h: * Registers of the DesignWare Hi-Speed USB 2.0 On-The-Go Controller.
system/platforms/arm-rpi/usb_dwc_regs.h: * Layout of the registers of the DesignWare Hi-Speed USB 2.0 On-The-Go
system/platforms/arm-rpi/usb_dwc_regs.h:     * This register contains the state of pending top-level DWC interrupts.  1
system/platforms/arm-rpi/usb_dwc_regs.h:     * This register contains the size of the Receive FIFO, in 4-byte words.
system/platforms/arm-rpi/usb_dwc_regs.h:     * Transmit FIFO, in 4-byte words, from the start of the memory reserved by
system/platforms/arm-rpi/usb_dwc_regs.h:     * contain its size, in 4-byte words.
system/platforms/arm-rpi/usb_dwc_regs.h:     * The high 16 bits of this read-only register contain the maximum total
system/platforms/arm-rpi/usb_dwc_regs.h:     * Transmit FIFO, in 4-byte words, from the start of the memory reserved by
system/platforms/arm-rpi/usb_dwc_regs.h:     * configure its size, in 4-byte words.
system/platforms/arm-rpi/usb_dwc_regs.h:     * registers.  These are used for the "Host" half of the OTG (On-The-Go)
system/platforms/arm-rpi/usb_dwc_regs.h:     * interrupts by writing to this register; use the channel-specific
system/platforms/arm-rpi/usb_dwc_regs.h:             * Current logic of data lines (10: logic of D+; 11: logic of D-).
system/platforms/arm-rpi/usb_dwc_regs.h:            uint32_t line_status : 2; /* Bits 10-11*/
system/platforms/arm-rpi/usb_dwc_regs.h:            uint32_t test_control : 4; /* Bits 13-16 */
system/platforms/arm-rpi/usb_dwc_regs.h:            uint32_t speed : 2; /* Bits 17-18 */
system/platforms/arm-rpi/usb_dwc_regs.h:            uint32_t reserved2 : 13; /* Bits 19-32 */
system/platforms/arm-rpi/usb_dwc_regs.h:     * having to re-program the channel, it may be useful to use one channel for
system/platforms/arm-rpi/usb_dwc_regs.h:         * Channel Characteristics Register -
system/platforms/arm-rpi/usb_dwc_regs.h:         * channel is re-programmed for a different transfer or the transfer is
system/platforms/arm-rpi/usb_dwc_regs.h:                uint32_t max_packet_size     : 11; /* Bits 0-10  */
system/platforms/arm-rpi/usb_dwc_regs.h:                uint32_t endpoint_number     : 4;  /* Bits 11-14 */
system/platforms/arm-rpi/usb_dwc_regs.h:                uint32_t endpoint_type       : 2;  /* Bits 18-19 */
system/platforms/arm-rpi/usb_dwc_regs.h:                 * high-speed interrupt and isochronous endpoints.  Must be
system/platforms/arm-rpi/usb_dwc_regs.h:                uint32_t packets_per_frame   : 2;  /* Bits 20-21 */
system/platforms/arm-rpi/usb_dwc_regs.h:                uint32_t device_address      : 7;  /* Bits 22-28 */
system/platforms/arm-rpi/usb_dwc_regs.h:         * Channel Split Control Register -
system/platforms/arm-rpi/usb_dwc_regs.h:         * with low or full-speed devices attached to a high-speed hub.  When
system/platforms/arm-rpi/usb_dwc_regs.h:                 * 0-based index of the port on the high-speed hub on which the
system/platforms/arm-rpi/usb_dwc_regs.h:                 * low or full-speed device is attached.
system/platforms/arm-rpi/usb_dwc_regs.h:                uint32_t port_address          : 7;  /* Bits 0-6   */
system/platforms/arm-rpi/usb_dwc_regs.h:                 * USB device address of the high-speed hub that acts as the
system/platforms/arm-rpi/usb_dwc_regs.h:                 * Transaction Translator for this low or full-speed device.
system/platforms/arm-rpi/usb_dwc_regs.h:                 * connected to, since that could be a full-speed or low-speed
system/platforms/arm-rpi/usb_dwc_regs.h:                 * (towards the root hub) until a high-speed hub is found and
system/platforms/arm-rpi/usb_dwc_regs.h:                uint32_t hub_address           : 7;  /* Bits 7-13  */
system/platforms/arm-rpi/usb_dwc_regs.h:                uint32_t transaction_position  : 2;  /* Bits 14-15 */
system/platforms/arm-rpi/usb_dwc_regs.h:                uint32_t reserved              : 14; /* Bits 17-30 */
system/platforms/arm-rpi/usb_dwc_regs.h:         * Channel Interrupts Register -
system/platforms/arm-rpi/usb_dwc_regs.h:         * and by any system-specific interrupt controller.
system/platforms/arm-rpi/usb_dwc_regs.h:                 * - When doing split transactions, this bit will be set after a
system/platforms/arm-rpi/usb_dwc_regs.h:                 * - The transfer will only be complete up to the extent that
system/platforms/arm-rpi/usb_dwc_regs.h:                 * - An OUT transfer is otherwise considered complete when
system/platforms/arm-rpi/usb_dwc_regs.h:                 *   shorter-than-expected packet was received.
system/platforms/arm-rpi/usb_dwc_regs.h:                 * - The transfer has completed, thereby setting the
system/platforms/arm-rpi/usb_dwc_regs.h:                 * - A Start Split or Complete Split transaction has finished.
system/platforms/arm-rpi/usb_dwc_regs.h:                 * - The hub sent a NYET packet when trying to execute a
system/platforms/arm-rpi/usb_dwc_regs.h:                 * - The device sent a NAK packet, thereby signalling it had no
system/platforms/arm-rpi/usb_dwc_regs.h:                 * - One of several errors has occurred, such as an AHB error,
system/platforms/arm-rpi/usb_dwc_regs.h:                 * An error occurred on the ARM Advanced High-Performance Bus
system/platforms/arm-rpi/usb_dwc_regs.h:                 * the actual transactions themselves are interrupt-driven.
system/platforms/arm-rpi/usb_dwc_regs.h:                 * acknowledged error-free packet).
system/platforms/arm-rpi/usb_dwc_regs.h:                uint32_t reserved                 : 18; /* Bits 14-31 */
system/platforms/arm-rpi/usb_dwc_regs.h:         * Channel Interrupts Mask Register -
system/platforms/arm-rpi/usb_dwc_regs.h:                uint32_t size         : 19; /* Bits 0-18  */
system/platforms/arm-rpi/usb_dwc_regs.h:                uint32_t packet_count : 10; /* Bits 19-28 */
system/platforms/arm-rpi/usb_dwc_regs.h:                 * needs to be re-programmed if the transfer is moved to a
system/platforms/arm-rpi/usb_dwc_regs.h:                 * different channel or the channel is re-used before the
system/platforms/arm-rpi/usb_dwc_regs.h:                 * field so that it can be re-programmed correctly.
system/platforms/arm-rpi/usb_dwc_regs.h:                uint32_t packet_id    : 2;  /* Bits 29-30 */
system/platforms/arm-rpi/usb_dwc_regs.h:         * Channel DMA Address Register -
system/platforms/arm-rpi/usb_dwc_regs.h:         * Word-aligned address at which the hardware will read or write data
system/platforms/arm-rpi/usb_dwc_regs.h:         * BCM2835-specific note:  Theoretically, addresses written to this
system/platforms/arm-rpi/usb_dwc_regs.h:    uint32_t host_reserved_after_channels[(0x800 - 0x500 -
system/platforms/arm-rpi/usb_dwc_regs.h:    uint32_t reserved_0x800[(0xe00 - 0x800) / sizeof(uint32_t)];
Binary file system/platforms/arm-rpi/.ctxsw.S.swp matches
system/platforms/e2100l/dispatch.c:    long irqcode = 0, irqnum = -1;
system/platforms/e2100l/dispatch.c:    exlreset();                 /* Reset system-wide exception bit */
system/platforms/e2100l/dispatch.c:    (*handler) ();              /* Call device-specific handler */
system/platforms/e2100l/dispatch.c:    exlset();                   /* Set system-wide exception bit */
system/platforms/e2100l/dispatch.c:        irqmisc = irqnumber - 8;
system/platforms/e2100l/dispatch.c:        irqmisc = irqnumber - 8;
system/platforms/e2100l/interrupt.h:/** Address of Xinu-defined trap (exception) vector.               */
system/platforms/e2100l/interrupt.h:/** Address of Xinu-defined interrupt request vector.              */
system/platforms/e2100l/interrupt.h:/** Address of end of Xinu-defined interrupt tables.               */
system/platforms/mipsel-qemu/Makerules:COMP = system/platforms/mipsel-qemu
system/platforms/mipsel-qemu/dispatch.c:    "Interrupt controller request 8, real-time clock",
system/platforms/mipsel-qemu/dispatch.c:    long irqcode = 0, irqnum = -1;
system/platforms/mipsel-qemu/dispatch.c:    exlreset();                 /* Reset system-wide exception bit */
system/platforms/mipsel-qemu/dispatch.c:    (*handler) ();              /* Call device-specific handler */
system/platforms/mipsel-qemu/dispatch.c:    exlset();                   /* Set system-wide exception bit */
system/platforms/mipsel-qemu/dispatch.c:        irqmisc = irqnumber - 16;
system/platforms/mipsel-qemu/dispatch.c:        irqmisc = irqnumber - 8;
system/platforms/mipsel-qemu/dispatch.c:        irqmisc = irqnumber - 16;
system/platforms/mipsel-qemu/dispatch.c:        irqmisc = irqnumber - 8;
system/platforms/mipsel-qemu/interrupt.h:/** Address of Xinu-defined trap (exception) vector.               */
system/platforms/mipsel-qemu/interrupt.h:/** Address of Xinu-defined interrupt request vector.              */
system/platforms/mipsel-qemu/interrupt.h:/** Address of end of Xinu-defined interrupt tables.               */
system/platforms/mipsel-qemu/pic8259.h: * PC-style i8259 programmable interrupt controller.
system/platforms/mipsel-qemu/platforminit.c:    /* Set all interrupts to be level-triggered, not edge */
system/platforms/wl330ge/dispatch.c:    long irqcode = 0, irqnum = -1;
system/platforms/wl330ge/dispatch.c:    exlreset();                 /* Reset system-wide exception bit */
system/platforms/wl330ge/dispatch.c:    (*handler) ();              /* Call device-specific handler */
system/platforms/wl330ge/dispatch.c:    exlset();                   /* Set system-wide exception bit */
system/platforms/wl330ge/flash.h:    uint crc;                   /**< 32-bit CRC from flag_vers to EOF    */
system/platforms/wl330ge/flash.h:    uint flags_vers;             /**< 0-15 flags, 16-31 version           */
system/platforms/wl330ge/flash.h:/* put/get 8-bits commands for CFI */
system/platforms/wl330ge/flash.h:/* put/get 8-bits commands for Intel */
system/platforms/wl330ge/flash.h:/* put/get 8-bits commands for AMD */
system/platforms/wl330ge/flash.h:/* put/get 16-bits commands for Intel */
system/platforms/wl330ge/flash.h:/* put/get 16-bits commands for AMD */
system/platforms/wl330ge/flash.h:#define INTEL_RESUME   0xD0   /**< write/erase resume (post-suspend) */
system/platforms/wl330ge/flash.h:#define INTEL_UNLOCK   0xD0   /**< soft-unlock a block               */
system/platforms/wl330ge/flash.h:#define INTEL_LOCK     0x01   /**< soft-lock a block                 */
system/platforms/wl330ge/flash.h:#define AMD_LOCK            0x01    /**< soft-lock a block           */
system/platforms/wl330ge/flash.h:#define INTEL_SR_ESS   6      /**< Erase-Suspend Status              */
system/platforms/wl330ge/flash.h:#define INTEL_ID_DEV   0x02   /**< Device memory-map                 */
system/platforms/wl330ge/flash.h:#define INTEL_ID_BLS   0x04   /**< bit: 0 = soft-lock, 1 = hard-lock */
system/platforms/wl330ge/flash.h:#define INTEL_H_LOCK   0x02   /**< lock-down (hardward lock)         */
system/platforms/wl330ge/flash.h:#define AMD_H_LOCK   0x02   /**< lock-down (hardward lock)         */
system/platforms/wl330ge/flash.h:#define FLASH_STATUS   0x0000 /**< return status register (8-bits)   */
system/platforms/wl330ge/flash.h:#define FLASH_LOCKED   0x0010 /**< return id register (16-bits)      */
system/platforms/wl330ge/interrupt.h:/** Address of Xinu-defined trap (exception) vector.               */
system/platforms/wl330ge/interrupt.h:/** Address of Xinu-defined interrupt request vector.              */
system/platforms/wl330ge/interrupt.h:/** Address of end of Xinu-defined interrupt tables.               */
system/platforms/wrt160nl/dispatch.c:    long irqcode = 0, irqnum = -1;
system/platforms/wrt160nl/dispatch.c:    exlreset();                 /* Reset system-wide exception bit */
system/platforms/wrt160nl/dispatch.c:    (*handler) ();              /* Call device-specific handler */
system/platforms/wrt160nl/dispatch.c:    exlset();                   /* Set system-wide exception bit */
system/platforms/wrt160nl/dispatch.c:        irqmisc = irqnumber - 8;
system/platforms/wrt160nl/dispatch.c:        irqmisc = irqnumber - 8;
system/platforms/wrt160nl/interrupt.h:/** Address of Xinu-defined trap (exception) vector.               */
system/platforms/wrt160nl/interrupt.h:/** Address of Xinu-defined interrupt request vector.              */
system/platforms/wrt160nl/interrupt.h:/** Address of end of Xinu-defined interrupt tables.               */
system/platforms/wrt54gl/dispatch.c:    long irqcode = 0, irqnum = -1;
system/platforms/wrt54gl/dispatch.c:    exlreset();                 /* Reset system-wide exception bit */
system/platforms/wrt54gl/dispatch.c:    (*handler) ();              /* Call device-specific handler */
system/platforms/wrt54gl/dispatch.c:    exlset();                   /* Set system-wide exception bit */
system/platforms/wrt54gl/interrupt.h:/** Address of Xinu-defined trap (exception) vector.               */
system/platforms/wrt54gl/interrupt.h:/** Address of Xinu-defined interrupt request vector.              */
system/platforms/wrt54gl/interrupt.h:/** Address of end of Xinu-defined interrupt tables.               */
system/platforms/x86/asm-i386/asm.h:/* asm.h - DELAY */
system/platforms/x86/asm-i386/asm.h:        while (--N > 0) ;                     \
system/platforms/x86/asm-i386/icu.h:#define EOI 0x20     /* end-of-interrupt signal                   */
system/platforms/x86/asm-i386/xint.S: * Generic exception handler(s) for x86-xinu.  Adapted from D.W.Brylow's 
system/platforms/x86/asm-i386/xint.S:#include <asm-i386/icu.h>
system/platforms/x86/clkupdate.S:/* clockupdate.s - clock_update */
system/platforms/x86/clkupdate.S:#include <asm-i386/icu.h>
system/platforms/x86/clkupdate.S:	movb   $EOI, %al   /* write end-of-interrupt signal */
system/platforms/x86/ctxsw.S:/*------------------------------------------------------------------------
system/platforms/x86/ctxsw.S: * ctxsw -  call is ctxsw(&oldsp, &newsp, asid)
system/platforms/x86/ctxsw.S: *------------------------------------------------------------------------
system/platforms/x86/evec.c: * handler set. disable() & restore() are OR-ed with it to get the
system/platforms/x86/evec.c:        pidt->igd_loffset = (ushort)(defevec[i] & 0x0ffff);
system/platforms/x86/evec.c:        pidt->igd_hoffset = (ushort)(defevec[i] >> 16);
system/platforms/x86/evec.c:        pidt->igd_segsel = 0x8;        /* kernel code segment */
system/platforms/x86/evec.c:        pidt->igd_mbz = 0;
system/platforms/x86/evec.c:        pidt->igd_type = IGDT_TRAPG;
system/platforms/x86/evec.c:        pidt->igd_dpl = 0;
system/platforms/x86/evec.c:        pidt->igd_present = 1;
system/platforms/x86/evec.c:    pidt->igd_loffset = (ushort)(handler & 0x0ffff);
system/platforms/x86/evec.c:    pidt->igd_hoffset = (ushort)(handler >> 16);
system/platforms/x86/evec.c:    pidt->igd_segsel = 0x8;        /* kernel code segment */
system/platforms/x86/evec.c:    pidt->igd_mbz = 0;
system/platforms/x86/evec.c:    pidt->igd_type = IGDT_TRAPG;
system/platforms/x86/evec.c:    pidt->igd_dpl = 0;
system/platforms/x86/evec.c:    pidt->igd_present = 1;
system/platforms/x86/evec.c:        exc_num -= 32;
system/platforms/x86/evec.c:        exc_num -= 32;
system/platforms/x86/intr.S:/* intr.s - disable(), restore(), enable(), pause(), halt() */
system/platforms/x86/intr.S:#include <asm-i386/icu.h> 
system/platforms/x86/intr.S:/*------------------------------------------------------------------------
system/platforms/x86/intr.S: * _Xint? - default exception and interrupt entry points
system/platforms/x86/intr.S: *------------------------------------------------------------------------
system/platforms/x86/intr.S:#include <asm-i386/xint.S>
system/platforms/x86/intr.S:/*---------------------------------------------------------
system/platforms/x86/intr.S: *---------------------------------------------------------
system/platforms/x86/intr.S:/*---------------------------------------------------------
system/platforms/x86/intr.S: * disable()    - disable interrupts, save old state in ps
system/platforms/x86/intr.S: *---------------------------------------------------------
system/platforms/x86/intr.S:/*---------------------------------------------------------
system/platforms/x86/intr.S: * restore(ps)    - restore interrupts to value in ps
system/platforms/x86/intr.S: *---------------------------------------------------------
system/platforms/x86/intr.S:/*------------------------------------------------------------------------
system/platforms/x86/intr.S: * getirmask(ps)  - return current interrupt mask in ps
system/platforms/x86/intr.S: *------------------------------------------------------------------------
system/platforms/x86/parport.S:#include <asm-i386/icu.h>
system/platforms/x86/parport.S:	/* send end-of-interrupt signal */
system/platforms/x86/pause.S: * Platform-dependent code for idling the processor
system/platforms/x86/platforminit.c:#include <asm-i386/icu.h>
system/platforms/x86/segment.c:    seg->lobase = base & 0xffff;
system/platforms/x86/segment.c:    seg->midbase = (base >> 16) & 0xff;
system/platforms/x86/segment.c:    seg->hibase = (base >> 24) & 0xff;
system/platforms/x86/segment.c:    seg->lolimit = (limit >> 12) & 0xffff;
system/platforms/x86/segment.c:    seg->hilimit = (limit >> 28) & 0xf;
system/platforms/x86/segment.c:    seg->type = properties & 0xf;
system/platforms/x86/segment.c:    seg->dataseg = (properties >> SEG_DSEG_SHIFT) & 0x1;
system/platforms/x86/segment.c:    seg->dpl = (properties >> SEG_DPL_SHIFT) & 0x3;
system/platforms/x86/segment.c:    seg->present = (properties >> SEG_P_SHIFT) & 0x1;
system/platforms/x86/segment.c:    seg->avl = (properties >> SEG_AVL_SHIFT) & 0x1;
system/platforms/x86/segment.c:    seg->mbz = 0;
system/platforms/x86/segment.c:    seg->db = (properties >> SEG_DB_SHIFT) & 0x1;
system/platforms/x86/segment.c:    seg->gran = (properties >> SEG_GRAN_SHIFT) & 0x1;
system/platforms/x86/segment.h:/* segment.h - DELAY */
system/platforms/x86/segment.h:		while (--N > 0);                    \
system/platforms/x86/setupStack.c:    saddr -= nargs;
system/platforms/x86/setupStack.c:    *--saddr     = (ulong)INITRET;
system/platforms/x86/setupStack.c:    *--saddr     = (ulong)procaddr;
system/platforms/x86/setupStack.c:    *--saddr     = savsp;
system/platforms/x86/setupStack.c:    *--saddr     = 0;
system/platforms/x86/setupStack.c:    *--saddr     = 0; /* %eax */
system/platforms/x86/setupStack.c:    *--saddr     = 0; /* %ecx */
system/platforms/x86/setupStack.c:    *--saddr     = 0; /* %edx */
system/platforms/x86/setupStack.c:    *--saddr     = 0; /* %ebx */
system/platforms/x86/setupStack.c:    *--saddr     = 0; /* %esp; "popal" doesn't actually pop it, so 0 is ok */
system/platforms/x86/setupStack.c:    *--saddr     = savsp; /* %ebp */
system/platforms/x86/setupStack.c:    *--saddr     = 0; /* %esi */
system/platforms/x86/setupStack.c:    *--saddr     = 0; /* %edi */
system/platforms/x86/startup.S: * Non-relocating version -- for programs which are loaded by boot
system/platforms/x86/startup.S:idtr:	.word	383	# size of idt - 1 (in bytes)
system/platforms/x86/startup.S:	# Restore the stack point post-segment init
system/platforms/x86/startup.S:	# lidt() - load interrupt descriptor table from idtr
system/platforms/x86/xtrap.c:    "non-maskable interrupt",
system/platforms/x86/xtrap.c:    kprintf(" errno: 0x%08x  ",   *(frame-2));
system/platforms/x86/xtrap.c:    kprintf("stkptr: 0x%08x\r\n", *(frame-1));
Binary file system/platforms/x86/evec.o.granados.mscs.mu.edu.10632.Xf0JnF matches
system/platforms/x86/platforminit.d.granados.mscs.mu.edu.8927.Ujkzqf: ../system/platforms/x86/asm-i386/icu.h \
system/platforms/x86/platforminit.d.granados.mscs.mu.edu.8927.Ujkzqf:../system/platforms/x86/asm-i386/icu.h:
system/platforms/arm-rpi3/Makerules:COMP = system/platforms/arm-rpi3
system/platforms/arm-rpi3/bcm2837.h: * be found in the Linux source (arch/arm/mach-bcm2708/include/mach/platform.h).
system/platforms/arm-rpi3/bcm2837.h:/* Start of memory-mapped peripherals address space  */
system/platforms/arm-rpi3/bcm2837.h:/* Synopsys DesignWare Hi-Speed USB 2.0 On-The-Go Controller  */
system/platforms/arm-rpi3/bcm2837.h: * used here:  IRQs 0-63 are those shared between the GPU and CPU, whereas *
system/platforms/arm-rpi3/bcm2837.h: * IRQs 64+ are CPU-specific.                                              *
system/platforms/arm-rpi3/bcm2837.h:/* System timer - one IRQ line per output compare register.  */
system/platforms/arm-rpi3/bcm2837.h:/* Synopsys DesignWare Hi-Speed USB 2.0 On-The-Go Controller  */
system/platforms/arm-rpi3/bcm2837.h: * Board-specific power management  *
system/platforms/arm-rpi3/bcm2837_mbox.h:/* The BCM2837 mailboxes are used for passing 28-bit messages.  The low 4 bits
system/platforms/arm-rpi3/bcm2837_mbox.h: *  * of the 32-bit value are used to specify the channel over which the message is
system/platforms/arm-rpi3/bcm2837_mbox.h:#define MBX_TAG_GET_ARM_MEMORY 0x00010005 /* in 0, out 8 (4 -> base addr, 4 -> len in bytes) */
system/platforms/arm-rpi3/bcm2837_mbox.h:#define MBX_TAG_GET_VC_MEMORY 0x00010006 /* in 0, out 8 (4 -> base addr, 4 -> len in bytes) */
system/platforms/arm-rpi3/bcm2837_mbox.h:#define MBX_TAG_GET_POWER_STATE 0x00020001 /* in 4 -> dev id, out 8 (4 -> device, 4 -> status) */
system/platforms/arm-rpi3/ctxsw.S: * @return special case -- see above
system/platforms/arm-rpi3/ctxsw.S:    push   {r0-r14}
system/platforms/arm-rpi3/ctxsw.S:    pop	   {r0-r12}
system/platforms/arm-rpi3/des.c:            addbit(&data_temp, *data, InitialPermutation[ii] - 1, ii);
system/platforms/arm-rpi3/des.c:            addbit(&data_temp, *data, FinalPermutation[ii] - 1, ii);
system/platforms/arm-rpi3/des.c:        // Test the parity bit (8-th bit)
system/platforms/arm-rpi3/des.c:                // Test if 8-th bit != 0
system/platforms/arm-rpi3/des.c:                // Test if 8-th bit != 1
system/platforms/arm-rpi3/des.c:            parity_bit = 0; // Re-init parity_bit for next byte block
system/platforms/arm-rpi3/des.c:    // 1. First round => PC-1 : Permuted Choice 1
system/platforms/arm-rpi3/des.c:                addbit(&key_left, *key, PC1[ii] - 1, ii);
system/platforms/arm-rpi3/des.c:                addbit(&key_right, *key, PC1[ii] - 1, ii % 28);
system/platforms/arm-rpi3/des.c:    key_left_temp = (key_left & key_left_temp) >> (28 - Rotations[round]);
system/platforms/arm-rpi3/des.c:    key_right_temp = (key_right & key_right_temp) >> (28 - Rotations[round]);
system/platforms/arm-rpi3/des.c:    // 3. PC-2 : Permuted Choice 2
system/platforms/arm-rpi3/des.c:        addbit(key, *next_key, PC2[ii] - 1, ii);
system/platforms/arm-rpi3/des.c:                coordy += 2^(4 - jj);
system/platforms/arm-rpi3/des.c:        substitued = substitued << (60 - (4 * ii));
system/platforms/arm-rpi3/des.c:        addbit(&right_block_temp, right_block, Pbox[ii] - 1, ii);
system/platforms/arm-rpi3/des.c:	/* make sure input is 8-byte aligned */
system/platforms/arm-rpi3/des.c:		kprintf("Input is not 8-byte aligned..\r\n");
system/platforms/arm-rpi3/des.c:	uint nblocks = isize / 8;	/* amount of 64-bit blocks in the input buffer */
system/platforms/arm-rpi3/des.c:	/* make sure input is 8-byte aligned */
system/platforms/arm-rpi3/des.c:		kprintf("Input is not 8-byte aligned..\r\n");
system/platforms/arm-rpi3/des.c:	uint nblocks = isize / 8;	/* amount of 64-bit blocks in the input buffer */
system/platforms/arm-rpi3/des.c:		for (i = 15; i >= 0; i--)
system/platforms/arm-rpi3/des.h://     - David Wong, moi@davidwong.fr
system/platforms/arm-rpi3/des.h://     - Jacques Monin, jacques.monin@u-bordeaux.fr
system/platforms/arm-rpi3/des.h://     - Hugo Bonnin, hugo.bonnin@u-bordeaux.fr
system/platforms/arm-rpi3/des.h:// Key Schedule ( http://en.wikipedia.org/wiki/File:DES-key-schedule.png )
system/platforms/arm-rpi3/dispatch.c: * controls which IRQs the ARM receives.  The VideoCore co-processor likely has
system/platforms/arm-rpi3/dispatch.c: * See http://xinu-os.org/BCM2835_Interrupt_Controller for additional
system/platforms/arm-rpi3/dispatch.c:/* Number of ARM-specific IRQs. These correspond to IRQs that show up in the
system/platforms/arm-rpi3/dispatch.c:        if (regs->IRQ_basic_pending & (1 << (irq_num - 64)))
system/platforms/arm-rpi3/dispatch.c:        if (regs->IRQ_pending_2 & (1 << (irq_num - 32)))
system/platforms/arm-rpi3/dispatch.c:        if (regs->IRQ_pending_1 & (1 << irq_num))
system/platforms/arm-rpi3/dispatch.c:        /* The pending bit should have been cleared in a device-specific way by
system/platforms/arm-rpi3/dispatch.c:    return 31 - __builtin_clz(word);
system/platforms/arm-rpi3/dispatch.c: * the poorly-documented hardware and conflicts with the GPU.
system/platforms/arm-rpi3/dispatch.c:        regs->Enable_IRQs_1 = 1 << irq_num;
system/platforms/arm-rpi3/dispatch.c:        regs->Enable_IRQs_2 = 1 << (irq_num - 32);
system/platforms/arm-rpi3/dispatch.c:        arm_enabled_irqs[1] |= 1 << (irq_num - 32);
system/platforms/arm-rpi3/dispatch.c:        regs->Enable_Basic_IRQs = 1 << (irq_num - 64);
system/platforms/arm-rpi3/dispatch.c:        arm_enabled_irqs[2] |= 1 << (irq_num - 64);
system/platforms/arm-rpi3/dispatch.c:        regs->Disable_IRQs_1 = 1 << irq_num;
system/platforms/arm-rpi3/dispatch.c:        regs->Disable_IRQs_2 = 1 << (irq_num - 32);
system/platforms/arm-rpi3/dispatch.c:        arm_enabled_irqs[1] &= ~(1 << (irq_num - 32));
system/platforms/arm-rpi3/dispatch.c:        regs->Disable_Basic_IRQs = 1 << (irq_num - 64);
system/platforms/arm-rpi3/dispatch.c:        arm_enabled_irqs[2] &= ~(1 << (irq_num - 64));
system/platforms/arm-rpi3/intutils.S: * See http://xinu-os.org/Interrupt_handling_(ARM) for more information.
system/platforms/arm-rpi3/irq_handler.S:	 * namely the SYS mode LR and all other caller-save general purpose
system/platforms/arm-rpi3/irq_handler.S:	 * decremented the stack pointer by to align it to an 8-byte boundary
system/platforms/arm-rpi3/irq_handler.S:	push {r0-r4, r12, lr}
system/platforms/arm-rpi3/irq_handler.S:	 * Architecture", the stack pointer is 4-byte aligned at all times, but
system/platforms/arm-rpi3/irq_handler.S:	 * it must be 8-byte aligned when calling an externally visible
system/platforms/arm-rpi3/irq_handler.S:	 * and therefore the stack currently may only be 4-byte aligned.  If
system/platforms/arm-rpi3/irq_handler.S:	 * this is the case, the stack must be padded to an 8-byte boundary
system/platforms/arm-rpi3/irq_handler.S:	/* Restore the original stack alignment (see note about 8-byte alignment
system/platforms/arm-rpi3/irq_handler.S:	/* Restore the above-mentioned registers from the SYS mode stack. */
system/platforms/arm-rpi3/irq_handler.S:	pop {r0-r4, r12, lr}
system/platforms/arm-rpi3/irq_handler.S:	/* Load the original SYS-mode CPSR and PC that were saved on the SYS
system/platforms/arm-rpi3/kexec.c: * This stub is hard-coded as an array because it needs to be copied to a
system/platforms/arm-rpi3/kexec.c: * r1:  size of new kernel in 32-bit words
system/platforms/arm-rpi3/kexec.c: * This is hard-coded to copy the kernel to address 0x8000.
system/platforms/arm-rpi3/kexec.c:#define COPY_KERNEL_ADDR ((void*)(0x8000 - sizeof(copy_kernel)))
system/platforms/arm-rpi3/kexec.c: * Kernel execute - Transfer control to a new kernel.
system/platforms/arm-rpi3/pause.S: * Platform-dependent code for idling the processor.
system/platforms/arm-rpi3/platforminit.c:#include "../../../device/uart-pl011/pl011.h"
system/platforms/arm-rpi3/platforminit.c:	ATAG_VIDEOLFB   = 0x54410008, //Initial values for vesafb-type framebuffers
system/platforms/arm-rpi3/platforminit.c:const struct atag *atags_ptr = (void*)-1;
system/platforms/arm-rpi3/platforminit.c:	regptr->gpfsel[1] &= ~(7 << 18);
system/platforms/arm-rpi3/platforminit.c:	regptr->gpfsel[1] |=  (1 << 18);	
system/platforms/arm-rpi3/platforminit.c:	regptr->gpset[0] = 1 << 16;
system/platforms/arm-rpi3/platforminit.c:	regptr->gpclr[0] = 1 << 16;
system/platforms/arm-rpi3/random.c://	return *RNG_DATA % (max - min) + min;
system/platforms/arm-rpi3/rpi_gpio.h:	volatile unsigned int gppud;		/* GPIO Pin Pull-up/down Enable */
system/platforms/arm-rpi3/rpi_gpio.h:	volatile unsigned int gppudclk[2];	/* GPIO Pin Pull-up/down Enable Clock */
system/platforms/arm-rpi3/setupCores.S:	/* move value to non-volatile registers before calling start_mmu */
system/platforms/arm-rpi3/setupStack.c:/* Length of ARM context record in words (includes r0-r11, cpsr, lr, pc).  */
system/platforms/arm-rpi3/setupStack.c:/* The standard ARMv8 calling convention passes first eight arguments in x0-x7; the
system/platforms/arm-rpi3/setupStack.c:        spilled_nargs = nargs - MAX_REG_ARGS;
system/platforms/arm-rpi3/setupStack.c:        saddr -= spilled_nargs;
system/platforms/arm-rpi3/setupStack.c:    /* Possibly skip a word to ensure the stack is aligned on a **8-byte** boundary
system/platforms/arm-rpi3/setupStack.c:        --saddr;
system/platforms/arm-rpi3/setupStack.c:    saddr -= CONTEXT_WORDS;
system/platforms/arm-rpi3/setupStack.c:    for (; i < CONTEXT_WORDS - 3; i++)
system/platforms/arm-rpi3/setupStack.c:    saddr[CONTEXT_WORDS - 3] = ARM_MODE_SYS | ARM_F_BIT;
system/platforms/arm-rpi3/setupStack.c:    saddr[CONTEXT_WORDS - 2] = (ulong)retaddr;
system/platforms/arm-rpi3/setupStack.c:    saddr[CONTEXT_WORDS - 1] = (ulong)procaddr;
system/platforms/arm-rpi3/timer.c: * See 12. "System Timer" of the BCM2835-ARM-Peripherals.pdf document for
system/platforms/arm-rpi3/timer.c: * connected to (it's IRQs 0-3 mapped linearly onto the output compare
system/platforms/arm-rpi3/timer.c: * See http://xinu-os.org/BCM2835_System_Timer for more information about this
system/platforms/arm-rpi3/timer.c: * Raspberry-Pi specific note:  This function returns the low-order 32 bits of
system/platforms/arm-rpi3/timer.c: * the BCM2835's free-running counter.  This counter runs at 1 MHz and therefore
system/platforms/arm-rpi3/timer.c:    count = regs->CLO;
system/platforms/arm-rpi3/timer.c:    regs->CS = BCM2835_SYSTEM_TIMER_MATCH_3;
system/platforms/arm-rpi3/timer.c:     * done by reading the current low-order bits of the counter and adding the
system/platforms/arm-rpi3/timer.c:    regs->C3 = regs->CLO + cycles;
system/platforms/arm-rpi3/unparkcore.c:	for (i = 31; i >= 0; i--)
system/platforms/arm-rpi3/usb_dwc_hcd.c: * Hi-Speed USB 2.0 On-The-Go Controller.
system/platforms/arm-rpi3/usb_dwc_hcd.c: * DesignWare Hi-Speed USB 2.0 On-The-Go Controller, henceforth abbreviated as
system/platforms/arm-rpi3/usb_dwc_hcd.c: * was written on a best-effort basis using several sources to gleam the
system/platforms/arm-rpi3/usb_dwc_hcd.c: * to understand vendor-provided Linux driver.
system/platforms/arm-rpi3/usb_dwc_hcd.c: * The DWC is controlled by reading and writing to/from memory-mapped registers.
system/platforms/arm-rpi3/usb_dwc_hcd.c: * transfers in an interrupt-driven manner.  However, due to design flaws in
system/platforms/arm-rpi3/usb_dwc_hcd.c: * though each individual transfer is itself interrupt-driven.  This means that,
system/platforms/arm-rpi3/usb_dwc_hcd.c: * The "On-The-Go" in the name of this hardware means that it supports the USB
system/platforms/arm-rpi3/usb_dwc_hcd.c: * On-The-Go protocol, which allows it to act either as a host or a device.
system/platforms/arm-rpi3/usb_dwc_hcd.c:#define WORD_ALIGN(n) (((n) + sizeof(ulong) - 1) & ~(sizeof(ulong) - 1))
system/platforms/arm-rpi3/usb_dwc_hcd.c:/** Determines whether a pointer is word-aligned or not.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:/** Pointer to the memory-mapped registers of the Synopsys DesignWare Hi-Speed
system/platforms/arm-rpi3/usb_dwc_hcd.c: * Name of USB defer transfer threads.  Note: including the null-terminator this
system/platforms/arm-rpi3/usb_dwc_hcd.c:/** Bitmap of channel free (1) or in-use (0) statuses.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:/** Bitmap of channels waiting for start-of-frame  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:    return 31 - __builtin_clz(word);
system/platforms/arm-rpi3/usb_dwc_hcd.c:    usb_info("Powering on Synopsys DesignWare Hi-Speed "
system/platforms/arm-rpi3/usb_dwc_hcd.c:             "USB 2.0 On-The-Go Controller\r\n");
system/platforms/arm-rpi3/usb_dwc_hcd.c:    usb_info("Powering off Synopsys DesignWare Hi-Speed "
system/platforms/arm-rpi3/usb_dwc_hcd.c:             "USB 2.0 On-The-Go Controller\r\n");
system/platforms/arm-rpi3/usb_dwc_hcd.c:    regs->core_reset = DWC_SOFT_RESET;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    while (regs->core_reset & DWC_SOFT_RESET)
system/platforms/arm-rpi3/usb_dwc_hcd.c: * makes it possible for the Host Controller to directly access in-memory
system/platforms/arm-rpi3/usb_dwc_hcd.c: * must be 4-byte-aligned.  Furthermore, if the L1 data cache is enabled, then
system/platforms/arm-rpi3/usb_dwc_hcd.c:    const uint32_t rx_words = 1024;  /* Size of Rx FIFO in 4-byte words */
system/platforms/arm-rpi3/usb_dwc_hcd.c:    const uint32_t tx_words = 1024;  /* Size of Non-periodic Tx FIFO in 4-byte words */
system/platforms/arm-rpi3/usb_dwc_hcd.c:    const uint32_t ptx_words = 1024; /* Size of Periodic Tx FIFO in 4-byte words */
system/platforms/arm-rpi3/usb_dwc_hcd.c:    usb_debug("%u words of RAM available for dynamic FIFOs\r\n", regs->hwcfg3 >> 16);
system/platforms/arm-rpi3/usb_dwc_hcd.c:              regs->rx_fifo_size, regs->nonperiodic_tx_fifo_size,
system/platforms/arm-rpi3/usb_dwc_hcd.c:              regs->host_periodic_tx_fifo_size);
system/platforms/arm-rpi3/usb_dwc_hcd.c:    regs->rx_fifo_size = rx_words;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    regs->nonperiodic_tx_fifo_size = (tx_words << 16) | rx_words;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    regs->host_periodic_tx_fifo_size = (ptx_words << 16) | (rx_words + tx_words);
system/platforms/arm-rpi3/usb_dwc_hcd.c:    regs->ahb_configuration |= DWC_AHB_DMA_ENABLE | BCM_DWC_AHB_AXI_WAIT;
system/platforms/arm-rpi3/usb_dwc_hcd.c: * this requires zeroing the write-clear bits so they aren't unintentionally
system/platforms/arm-rpi3/usb_dwc_hcd.c:    union dwc_host_port_ctrlstatus hw_status = regs->host_port_ctrlstatus;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    regs->host_port_ctrlstatus = hw_status;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    regs->host_port_ctrlstatus = hw_status;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    regs->host_port_ctrlstatus = hw_status;
system/platforms/arm-rpi3/usb_dwc_hcd.c:/** Hard-coded device descriptor for the faked root hub.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:    .bcdUSB = 0x200, /* USB version 2.0 (binary-coded decimal) */
system/platforms/arm-rpi3/usb_dwc_hcd.c:/** Hard-coded configuration descriptor, along with an associated interface
system/platforms/arm-rpi3/usb_dwc_hcd.c:/** Hard-coded list of language IDs for the faked root hub.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:/** Hard-coded product string for the faked root hub.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:    /* This is a UTF-16LE string, hence the array of individual characters
system/platforms/arm-rpi3/usb_dwc_hcd.c:/** Hard-coded table of strings for the faked root hub.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:/** Hard-coded hub descriptor for the faked root hub.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:/** Hard-coded hub status for the faked root hub.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:        *(uint8_t*)req->recvbuf = 0x2; /* 0x2 means Port 1 status changed (bit 0 is
system/platforms/arm-rpi3/usb_dwc_hcd.c:        req->actual_size = 1;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        req->status = USB_STATUS_SUCCESS;
system/platforms/arm-rpi3/usb_dwc_hcd.c: * Fake a standard (i.e. not hub-specific) control message request to the root
system/platforms/arm-rpi3/usb_dwc_hcd.c:    const struct usb_control_setup_data *setup = &req->setup_data;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    switch (setup->bRequest)
system/platforms/arm-rpi3/usb_dwc_hcd.c:            len = min(setup->wLength, sizeof(root_hub_device_status));
system/platforms/arm-rpi3/usb_dwc_hcd.c:            memcpy(req->recvbuf, &root_hub_device_status, len);
system/platforms/arm-rpi3/usb_dwc_hcd.c:            req->actual_size = len;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            switch ((setup->wValue >> 8)) /* Switch on descriptor type */
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    len = min(setup->wLength, root_hub_device_descriptor.bLength);
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    memcpy(req->recvbuf, &root_hub_device_descriptor, len);
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    req->actual_size = len;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    len = min(setup->wLength,
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    memcpy(req->recvbuf, &root_hub_configuration, len);
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    req->actual_size = len;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    if ((setup->wValue & 0xff) < ARRAY_LEN(root_hub_strings))
system/platforms/arm-rpi3/usb_dwc_hcd.c:                                root_hub_strings[setup->wValue & 0xff];
system/platforms/arm-rpi3/usb_dwc_hcd.c:                        len = min(setup->wLength, desc->bLength);
system/platforms/arm-rpi3/usb_dwc_hcd.c:                        memcpy(req->recvbuf, desc, len);
system/platforms/arm-rpi3/usb_dwc_hcd.c:                        req->actual_size = len;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            if (setup->wLength >= 1)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                *(uint8_t*)req->recvbuf = req->dev->configuration;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                req->actual_size = 1;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            if (setup->wValue <= 1)
system/platforms/arm-rpi3/usb_dwc_hcd.c:    status->wHubStatus = 0;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    status->wHubChange = 0;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    status->local_power = 1;
system/platforms/arm-rpi3/usb_dwc_hcd.c: * Fake a hub-class-specific control message request to the root hub.
system/platforms/arm-rpi3/usb_dwc_hcd.c: *      Hub-class-specific request to the root hub to fake.
system/platforms/arm-rpi3/usb_dwc_hcd.c:    const struct usb_control_setup_data *setup = &req->setup_data;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    switch (setup->bRequest)
system/platforms/arm-rpi3/usb_dwc_hcd.c:            switch ((setup->wValue >> 8)) /* Switch on descriptor type */
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    len = min(setup->wLength, root_hub_hub_descriptor.bDescLength);
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    memcpy(req->recvbuf, &root_hub_hub_descriptor, len);
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    req->actual_size = len;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            switch (setup->bmRequestType & USB_BMREQUESTTYPE_RECIPIENT_MASK)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    if (setup->wLength >= sizeof(struct usb_hub_status))
system/platforms/arm-rpi3/usb_dwc_hcd.c:                        dwc_get_root_hub_status(req->recvbuf);
system/platforms/arm-rpi3/usb_dwc_hcd.c:                        req->actual_size = sizeof(struct usb_hub_status);
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    if (setup->wLength >= sizeof(struct usb_port_status))
system/platforms/arm-rpi3/usb_dwc_hcd.c:                        memcpy(req->recvbuf, &host_port_status,
system/platforms/arm-rpi3/usb_dwc_hcd.c:                        req->actual_size = sizeof(struct usb_port_status);
system/platforms/arm-rpi3/usb_dwc_hcd.c:            switch (setup->bmRequestType & USB_BMREQUESTTYPE_RECIPIENT_MASK)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    return dwc_set_host_port_feature(setup->wValue);
system/platforms/arm-rpi3/usb_dwc_hcd.c:            switch (setup->bmRequestType & USB_BMREQUESTTYPE_RECIPIENT_MASK)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    return dwc_clear_host_port_feature(setup->wValue);
system/platforms/arm-rpi3/usb_dwc_hcd.c:    switch (req->setup_data.bmRequestType & USB_BMREQUESTTYPE_TYPE_MASK)
system/platforms/arm-rpi3/usb_dwc_hcd.c:    if (req->endpoint_desc == NULL)
system/platforms/arm-rpi3/usb_dwc_hcd.c:        req->status = dwc_root_hub_control_msg(req);
system/platforms/arm-rpi3/usb_dwc_hcd.c: * Starts a low-level transaction on the USB.
system/platforms/arm-rpi3/usb_dwc_hcd.c:    volatile struct dwc_host_channel *chanptr = &regs->host_channels[chan];
system/platforms/arm-rpi3/usb_dwc_hcd.c:    chanptr->interrupt_mask.val = 0;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    chanptr->interrupts.val = 0xffffffff;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    split_control = chanptr->split_control;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    split_control.complete_split = req->complete_split;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    chanptr->split_control = split_control;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    next_frame = (regs->host_frame_number & 0xffff) + 1;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        req->csplit_retries = 0;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    characteristics = chanptr->characteristics;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    chanptr->characteristics = characteristics;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    chanptr->interrupt_mask = interrupt_mask;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    regs->host_channels_interrupt_mask |= 1 << chan;
system/platforms/arm-rpi3/usb_dwc_hcd.c: * Starts or restarts a USB transfer on a channel of the DesignWare Hi-Speed USB
system/platforms/arm-rpi3/usb_dwc_hcd.c: * To do this, software must give the parameters of a series of low-level
system/platforms/arm-rpi3/usb_dwc_hcd.c:    chanptr = &regs->host_channels[chan];
system/platforms/arm-rpi3/usb_dwc_hcd.c:    req->short_attempt = 0;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    if (req->endpoint_desc != NULL)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                                    req->endpoint_desc->bEndpointAddress & 0xf;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                                    req->endpoint_desc->bmAttributes & 0x3;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                                    req->endpoint_desc->wMaxPacketSize & 0x7ff;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        if (req->dev->speed == USB_SPEED_HIGH)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                        ((req->endpoint_desc->wMaxPacketSize >> 11) & 0x3);
system/platforms/arm-rpi3/usb_dwc_hcd.c:         * packets per frame are pre-determined, while the maximum packet size
system/platforms/arm-rpi3/usb_dwc_hcd.c:        characteristics.max_packet_size = req->dev->descriptor.bMaxPacketSize0;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        switch (req->control_phase)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                usb_dev_debug(req->dev, "Starting SETUP transaction\r\n");
system/platforms/arm-rpi3/usb_dwc_hcd.c:                data = &req->setup_data;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                usb_dev_debug(req->dev, "Starting DATA transactions\r\n");
system/platforms/arm-rpi3/usb_dwc_hcd.c:                                        req->setup_data.bmRequestType >> 7;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                 * re-starting a partially complete transfer.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:                data = req->recvbuf + req->actual_size;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                transfer.size = req->size - req->actual_size;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                if (req->actual_size == 0)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    transfer.packet_id = req->next_data_pid;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                usb_dev_debug(req->dev, "Starting STATUS transaction\r\n");
system/platforms/arm-rpi3/usb_dwc_hcd.c:                if ((req->setup_data.bmRequestType >> 7) == USB_DIRECTION_OUT ||
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    req->setup_data.wLength == 0)
system/platforms/arm-rpi3/usb_dwc_hcd.c:    else /* Starting or re-starting a non-control transfer.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    req->endpoint_desc->bEndpointAddress >> 7;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        data = req->recvbuf + req->actual_size;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        transfer.size = req->size - req->actual_size;
system/platforms/arm-rpi3/usb_dwc_hcd.c:         * data than fits in one (micro)frame--- that is, the maximum packets
system/platforms/arm-rpi3/usb_dwc_hcd.c:            req->short_attempt = 1;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        transfer.packet_id = req->next_data_pid;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    characteristics.device_address = req->dev->address;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    /* If communicating with a low or full-speed device, program the split
system/platforms/arm-rpi3/usb_dwc_hcd.c:     * Channel Characteristics register if communicating with a low-speed
system/platforms/arm-rpi3/usb_dwc_hcd.c:    if (req->dev->speed != USB_SPEED_HIGH)
system/platforms/arm-rpi3/usb_dwc_hcd.c:        tt_hub = req->dev;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            tt_hub_port = tt_hub->port_number;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            tt_hub = tt_hub->parent;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        } while (tt_hub->speed != USB_SPEED_HIGH);
system/platforms/arm-rpi3/usb_dwc_hcd.c:        split_control.port_address = tt_hub_port - 1;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        split_control.hub_address = tt_hub->address;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            req->short_attempt = 1;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        if (req->dev->speed == USB_SPEED_LOW)
system/platforms/arm-rpi3/usb_dwc_hcd.c:        /* Can DMA directly from source or to destination if word-aligned.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:        chanptr->dma_address = (uint32_t)data | 0xC0000000;					/* convert ARM address to VC4 address */
system/platforms/arm-rpi3/usb_dwc_hcd.c:         * destination is not word-aligned.  If the attempted transfer size
system/platforms/arm-rpi3/usb_dwc_hcd.c:        chanptr->dma_address = (uint32_t)aligned_bufs[chan] | 0xC0000000;	/* convert ARM address to VC4 address */	
system/platforms/arm-rpi3/usb_dwc_hcd.c:            transfer.size = sizeof(aligned_bufs[chan]) -
system/platforms/arm-rpi3/usb_dwc_hcd.c:            req->short_attempt = 1;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    req->cur_data_ptr = data;
system/platforms/arm-rpi3/usb_dwc_hcd.c:         * zero-length transfers.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:    req->attempted_size = transfer.size;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    req->attempted_bytes_remaining = transfer.size;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    req->attempted_packets_remaining = transfer.packet_count;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    usb_dev_debug(req->dev, "Setting up transactions on channel %u:\r\n"
system/platforms/arm-rpi3/usb_dwc_hcd.c:                  req->complete_split);
system/platforms/arm-rpi3/usb_dwc_hcd.c:    chanptr->characteristics = characteristics;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    chanptr->split_control   = split_control;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    chanptr->transfer        = transfer;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    if (req->dev->speed == USB_SPEED_HIGH)
system/platforms/arm-rpi3/usb_dwc_hcd.c:        interval_ms = (1 << (req->endpoint_desc->bInterval - 1)) /
system/platforms/arm-rpi3/usb_dwc_hcd.c:        interval_ms = req->endpoint_desc->bInterval / USB_FRAMES_PER_MS;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        wait(req->deferer_thread_sema);
system/platforms/arm-rpi3/usb_dwc_hcd.c:        if (req->need_sof)
system/platforms/arm-rpi3/usb_dwc_hcd.c:            usb_dev_debug(req->dev,
system/platforms/arm-rpi3/usb_dwc_hcd.c:                          "Waiting for start-of-frame\r\n");
system/platforms/arm-rpi3/usb_dwc_hcd.c:            intr_mask = regs->core_interrupt_mask;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            regs->core_interrupt_mask = intr_mask;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            req->need_sof = 0;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            usb_dev_debug(req->dev,
system/platforms/arm-rpi3/usb_dwc_hcd.c: * the endpoint descriptor.  For low and full-speed devices, bInterval specifies
system/platforms/arm-rpi3/usb_dwc_hcd.c: * the number of millisconds to wait before the next poll, while for high-speed
system/platforms/arm-rpi3/usb_dwc_hcd.c: * devices it specifies the exponent (plus one) of a power-of-two number of
system/platforms/arm-rpi3/usb_dwc_hcd.c: * thread created on-demand.  Each such thread simply enters a loop where it
system/platforms/arm-rpi3/usb_dwc_hcd.c:    usb_dev_debug(req->dev, "Deferring transfer\r\n");
system/platforms/arm-rpi3/usb_dwc_hcd.c:    if (SYSERR == req->deferer_thread_sema)
system/platforms/arm-rpi3/usb_dwc_hcd.c:        req->deferer_thread_sema = semcreate(0);
system/platforms/arm-rpi3/usb_dwc_hcd.c:        if (SYSERR == req->deferer_thread_sema)
system/platforms/arm-rpi3/usb_dwc_hcd.c:            usb_dev_error(req->dev, "Can't create semaphore\r\n");
system/platforms/arm-rpi3/usb_dwc_hcd.c:    if (BADTID == req->deferer_thread_tid)
system/platforms/arm-rpi3/usb_dwc_hcd.c:        req->deferer_thread_tid = create(defer_xfer_thread,
system/platforms/arm-rpi3/usb_dwc_hcd.c:        if (SYSERR == ready(req->deferer_thread_tid, RESCHED_NO))
system/platforms/arm-rpi3/usb_dwc_hcd.c:            req->deferer_thread_tid = BADTID;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            usb_dev_error(req->dev,
system/platforms/arm-rpi3/usb_dwc_hcd.c:    signal(req->deferer_thread_sema);
system/platforms/arm-rpi3/usb_dwc_hcd.c:    volatile struct dwc_host_channel *chanptr = &regs->host_channels[chan];
system/platforms/arm-rpi3/usb_dwc_hcd.c:    uint packets_remaining   = chanptr->transfer.packet_count;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    uint packets_transferred = req->attempted_packets_remaining -
system/platforms/arm-rpi3/usb_dwc_hcd.c:    usb_dev_debug(req->dev, "%u packets transferred on channel %u\r\n",
system/platforms/arm-rpi3/usb_dwc_hcd.c:                                            chanptr->characteristics;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            bytes_transferred = req->attempted_bytes_remaining -
system/platforms/arm-rpi3/usb_dwc_hcd.c:                                chanptr->transfer.size;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            if (!IS_WORD_ALIGNED(req->cur_data_ptr))
system/platforms/arm-rpi3/usb_dwc_hcd.c:                memcpy(req->cur_data_ptr,
system/platforms/arm-rpi3/usb_dwc_hcd.c:                       &aligned_bufs[chan][req->attempted_size -
system/platforms/arm-rpi3/usb_dwc_hcd.c:                                           req->attempted_bytes_remaining],
system/platforms/arm-rpi3/usb_dwc_hcd.c:                bytes_transferred += max_packet_size * (packets_transferred - 1);
system/platforms/arm-rpi3/usb_dwc_hcd.c:                (req->attempted_size % max_packet_size != 0 ||
system/platforms/arm-rpi3/usb_dwc_hcd.c:                 req->attempted_size == 0))
system/platforms/arm-rpi3/usb_dwc_hcd.c:                bytes_transferred += req->attempted_size % max_packet_size;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        usb_dev_debug(req->dev, "Calculated %u bytes transferred\r\n",
system/platforms/arm-rpi3/usb_dwc_hcd.c:        req->attempted_packets_remaining -= packets_transferred;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        req->attempted_bytes_remaining -= bytes_transferred;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        req->cur_data_ptr += bytes_transferred;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        if (req->attempted_packets_remaining == 0 ||
system/platforms/arm-rpi3/usb_dwc_hcd.c:                usb_dev_error(req->dev, "transfer_completed flag not "
system/platforms/arm-rpi3/usb_dwc_hcd.c:                              interrupts.val, chanptr->transfer.val);
system/platforms/arm-rpi3/usb_dwc_hcd.c:             * channels (for one of several reasons--- see
system/platforms/arm-rpi3/usb_dwc_hcd.c:            if (req->short_attempt && req->attempted_bytes_remaining == 0 &&
system/platforms/arm-rpi3/usb_dwc_hcd.c:                usb_dev_debug(req->dev,
system/platforms/arm-rpi3/usb_dwc_hcd.c:                              "Starting next part of %u-byte transfer "
system/platforms/arm-rpi3/usb_dwc_hcd.c:                              req->size, req->attempted_size);
system/platforms/arm-rpi3/usb_dwc_hcd.c:                req->complete_split = 0;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                req->next_data_pid = chanptr->transfer.packet_id;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                if (!usb_is_control_request(req) || req->control_phase == 1)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    req->actual_size = req->cur_data_ptr - req->recvbuf;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            if (usb_is_control_request(req) && req->control_phase < 2)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                req->complete_split = 0;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                if (req->control_phase == 1)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    req->actual_size = req->cur_data_ptr - req->recvbuf;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                req->control_phase++;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                if (req->control_phase == 1 && req->size == 0)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                    req->control_phase++;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            usb_dev_debug(req->dev, "Transfer completed on channel %u\r\n", chan);
system/platforms/arm-rpi3/usb_dwc_hcd.c:            if (chanptr->split_control.split_enable)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                req->complete_split ^= 1;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            usb_dev_debug(req->dev, "Continuing transfer (complete_split=%u)\r\n",
system/platforms/arm-rpi3/usb_dwc_hcd.c:                          req->complete_split);
system/platforms/arm-rpi3/usb_dwc_hcd.c:            chanptr->split_control.split_enable && !req->complete_split)
system/platforms/arm-rpi3/usb_dwc_hcd.c:            req->complete_split = 1;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            usb_dev_debug(req->dev, "Continuing transfer (complete_split=%u)\r\n",
system/platforms/arm-rpi3/usb_dwc_hcd.c:                          req->complete_split);
system/platforms/arm-rpi3/usb_dwc_hcd.c:            usb_dev_error(req->dev, "No packets transferred.\r\n");
system/platforms/arm-rpi3/usb_dwc_hcd.c:    volatile struct dwc_host_channel *chanptr = &regs->host_channels[chan];
system/platforms/arm-rpi3/usb_dwc_hcd.c:    union dwc_host_channel_interrupts interrupts = chanptr->interrupts;
system/platforms/arm-rpi3/usb_dwc_hcd.c:              chan, interrupts.val, chanptr->characteristics.val,
system/platforms/arm-rpi3/usb_dwc_hcd.c:              chanptr->transfer.val);
system/platforms/arm-rpi3/usb_dwc_hcd.c:        (interrupts.nyet_response_received && !req->complete_split) ||
system/platforms/arm-rpi3/usb_dwc_hcd.c:         chanptr->characteristics.endpoint_direction == USB_DIRECTION_OUT))
system/platforms/arm-rpi3/usb_dwc_hcd.c:        usb_dev_error(req->dev, "Transfer error on channel %u "
system/platforms/arm-rpi3/usb_dwc_hcd.c:                      chan, interrupts.val, chanptr->transfer.packet_count);
system/platforms/arm-rpi3/usb_dwc_hcd.c:        usb_dev_debug(req->dev, "Frame overrun on channel %u; "
system/platforms/arm-rpi3/usb_dwc_hcd.c:        usb_dev_debug(req->dev, "NYET response received on channel %u\r\n", chan);
system/platforms/arm-rpi3/usb_dwc_hcd.c:        if (++req->csplit_retries >= 10)
system/platforms/arm-rpi3/usb_dwc_hcd.c:            usb_dev_debug(req->dev, "Restarting split transaction "
system/platforms/arm-rpi3/usb_dwc_hcd.c:                          "(CSPLIT tried %u times)\r\n", req->csplit_retries);
system/platforms/arm-rpi3/usb_dwc_hcd.c:            req->complete_split = FALSE;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        usb_dev_debug(req->dev, "NAK response received on channel %u\r\n", chan);
system/platforms/arm-rpi3/usb_dwc_hcd.c:        req->complete_split = FALSE;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        usb_is_interrupt_request(req) && req->dev->speed != USB_SPEED_HIGH &&
system/platforms/arm-rpi3/usb_dwc_hcd.c:        !req->complete_split)
system/platforms/arm-rpi3/usb_dwc_hcd.c:        req->need_sof = 1;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            req->status = USB_STATUS_SUCCESS;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            req->status = USB_STATUS_HARDWARE_ERROR;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    req->next_data_pid = chanptr->transfer.packet_id;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    chanptr->interrupt_mask.val = 0;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    chanptr->interrupts.val = 0xffffffff;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    if (!usb_is_control_request(req) || req->control_phase == 1)
system/platforms/arm-rpi3/usb_dwc_hcd.c:        req->actual_size = req->cur_data_ptr - req->recvbuf;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            req->status = status;
system/platforms/arm-rpi3/usb_dwc_hcd.c:     * occurred, call the device-driver-provided completion callback.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c: * Interrupt handler function for the Synopsys DesignWare Hi-Speed USB 2.0
system/platforms/arm-rpi3/usb_dwc_hcd.c: * On-The-Go Controller (DWC).  This should only be called when an interrupt
system/platforms/arm-rpi3/usb_dwc_hcd.c:     * being executed re-entrantly.  */
system/platforms/arm-rpi3/usb_dwc_hcd.c:    union dwc_core_interrupts interrupts = regs->core_interrupts;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                  regs->host_frame_number);
system/platforms/arm-rpi3/usb_dwc_hcd.c:        if ((regs->host_frame_number & 0x7) != 6)
system/platforms/arm-rpi3/usb_dwc_hcd.c:                send(channel_pending_xfers[chan]->deferer_thread_tid, 0);
system/platforms/arm-rpi3/usb_dwc_hcd.c:                tmp = regs->core_interrupt_mask;
system/platforms/arm-rpi3/usb_dwc_hcd.c:                regs->core_interrupt_mask = tmp;
system/platforms/arm-rpi3/usb_dwc_hcd.c:            regs->core_interrupts = tmp;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        chintr = regs->host_channels_interrupt;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        union dwc_host_port_ctrlstatus hw_status = regs->host_port_ctrlstatus;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        /* Clear the interrupt(s), which are "write-clear", by writing the Host
system/platforms/arm-rpi3/usb_dwc_hcd.c:        regs->host_port_ctrlstatus = hw_status;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    if (--resdefer > 0)
system/platforms/arm-rpi3/usb_dwc_hcd.c: * Performs initial setup of the Synopsys Designware USB 2.0 On-The-Go
system/platforms/arm-rpi3/usb_dwc_hcd.c: * - The AHB configuration register contains a mask bit used to enable/disable
system/platforms/arm-rpi3/usb_dwc_hcd.c: * - The "Core" interrupt and interrupt mask registers control top-level
system/platforms/arm-rpi3/usb_dwc_hcd.c: * - The "Host All Channels" interrupt and interrupt mask registers control all
system/platforms/arm-rpi3/usb_dwc_hcd.c: * - The "Channel" interrupt and interrupt mask registers, of which one copy
system/platforms/arm-rpi3/usb_dwc_hcd.c: * The above just covers the DWC-specific interrupt registers.  In addition to
system/platforms/arm-rpi3/usb_dwc_hcd.c:    regs->core_interrupt_mask.val = 0;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    regs->core_interrupts.val = 0xffffffff;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    regs->core_interrupt_mask = core_interrupt_mask;
system/platforms/arm-rpi3/usb_dwc_hcd.c:    regs->ahb_configuration |= DWC_AHB_INTERRUPT_ENABLE;
system/platforms/arm-rpi3/usb_dwc_hcd.c:        if (is_root_hub(req->dev))
system/platforms/arm-rpi3/usb_dwc_hcd.c:    chfree = (1 << DWC_NUM_CHANNELS) - 1;
system/platforms/arm-rpi3/usb_dwc_hcd.c:/* Implementation of hcd_start() for the DesignWare Hi-Speed USB 2.0 On-The-Go
system/platforms/arm-rpi3/usb_dwc_hcd.c:/* Implementation of hcd_stop() for the DesignWare Hi-Speed USB 2.0 On-The-Go
system/platforms/arm-rpi3/usb_dwc_hcd.c:/* Implementation of hcd_submit_xfer_request() for the DesignWare Hi-Speed USB
system/platforms/arm-rpi3/usb_dwc_hcd.c: * 2.0 On-The-Go Controller.  See usb_hcdi.h for the documentation of this
system/platforms/arm-rpi3/usb_dwc_regs.h: * Registers of the DesignWare Hi-Speed USB 2.0 On-The-Go Controller.
system/platforms/arm-rpi3/usb_dwc_regs.h: * Layout of the registers of the DesignWare Hi-Speed USB 2.0 On-The-Go
system/platforms/arm-rpi3/usb_dwc_regs.h:     * This register contains the state of pending top-level DWC interrupts.  1
system/platforms/arm-rpi3/usb_dwc_regs.h:     * This register contains the size of the Receive FIFO, in 4-byte words.
system/platforms/arm-rpi3/usb_dwc_regs.h:     * Transmit FIFO, in 4-byte words, from the start of the memory reserved by
system/platforms/arm-rpi3/usb_dwc_regs.h:     * contain its size, in 4-byte words.
system/platforms/arm-rpi3/usb_dwc_regs.h:     * The high 16 bits of this read-only register contain the maximum total
system/platforms/arm-rpi3/usb_dwc_regs.h:     * Transmit FIFO, in 4-byte words, from the start of the memory reserved by
system/platforms/arm-rpi3/usb_dwc_regs.h:     * configure its size, in 4-byte words.
system/platforms/arm-rpi3/usb_dwc_regs.h:     * registers.  These are used for the "Host" half of the OTG (On-The-Go)
system/platforms/arm-rpi3/usb_dwc_regs.h:     * interrupts by writing to this register; use the channel-specific
system/platforms/arm-rpi3/usb_dwc_regs.h:             * Current logic of data lines (10: logic of D+; 11: logic of D-).
system/platforms/arm-rpi3/usb_dwc_regs.h:            uint32_t line_status : 2; /* Bits 10-11*/
system/platforms/arm-rpi3/usb_dwc_regs.h:            uint32_t test_control : 4; /* Bits 13-16 */
system/platforms/arm-rpi3/usb_dwc_regs.h:            uint32_t speed : 2; /* Bits 17-18 */
system/platforms/arm-rpi3/usb_dwc_regs.h:            uint32_t reserved2 : 13; /* Bits 19-32 */
system/platforms/arm-rpi3/usb_dwc_regs.h:     * having to re-program the channel, it may be useful to use one channel for
system/platforms/arm-rpi3/usb_dwc_regs.h:         * Channel Characteristics Register -
system/platforms/arm-rpi3/usb_dwc_regs.h:         * channel is re-programmed for a different transfer or the transfer is
system/platforms/arm-rpi3/usb_dwc_regs.h:                uint32_t max_packet_size     : 11; /* Bits 0-10  */
system/platforms/arm-rpi3/usb_dwc_regs.h:                uint32_t endpoint_number     : 4;  /* Bits 11-14 */
system/platforms/arm-rpi3/usb_dwc_regs.h:                uint32_t endpoint_type       : 2;  /* Bits 18-19 */
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * high-speed interrupt and isochronous endpoints.  Must be
system/platforms/arm-rpi3/usb_dwc_regs.h:                uint32_t packets_per_frame   : 2;  /* Bits 20-21 */
system/platforms/arm-rpi3/usb_dwc_regs.h:                uint32_t device_address      : 7;  /* Bits 22-28 */
system/platforms/arm-rpi3/usb_dwc_regs.h:         * Channel Split Control Register -
system/platforms/arm-rpi3/usb_dwc_regs.h:         * with low or full-speed devices attached to a high-speed hub.  When
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * 0-based index of the port on the high-speed hub on which the
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * low or full-speed device is attached.
system/platforms/arm-rpi3/usb_dwc_regs.h:                uint32_t port_address          : 7;  /* Bits 0-6   */
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * USB device address of the high-speed hub that acts as the
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * Transaction Translator for this low or full-speed device.
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * connected to, since that could be a full-speed or low-speed
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * (towards the root hub) until a high-speed hub is found and
system/platforms/arm-rpi3/usb_dwc_regs.h:                uint32_t hub_address           : 7;  /* Bits 7-13  */
system/platforms/arm-rpi3/usb_dwc_regs.h:                uint32_t transaction_position  : 2;  /* Bits 14-15 */
system/platforms/arm-rpi3/usb_dwc_regs.h:                uint32_t reserved              : 14; /* Bits 17-30 */
system/platforms/arm-rpi3/usb_dwc_regs.h:         * Channel Interrupts Register -
system/platforms/arm-rpi3/usb_dwc_regs.h:         * and by any system-specific interrupt controller.
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * - When doing split transactions, this bit will be set after a
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * - The transfer will only be complete up to the extent that
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * - An OUT transfer is otherwise considered complete when
system/platforms/arm-rpi3/usb_dwc_regs.h:                 *   shorter-than-expected packet was received.
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * - The transfer has completed, thereby setting the
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * - A Start Split or Complete Split transaction has finished.
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * - The hub sent a NYET packet when trying to execute a
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * - The device sent a NAK packet, thereby signalling it had no
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * - One of several errors has occurred, such as an AHB error,
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * An error occurred on the ARM Advanced High-Performance Bus
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * the actual transactions themselves are interrupt-driven.
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * acknowledged error-free packet).
system/platforms/arm-rpi3/usb_dwc_regs.h:                uint32_t reserved                 : 18; /* Bits 14-31 */
system/platforms/arm-rpi3/usb_dwc_regs.h:         * Channel Interrupts Mask Register -
system/platforms/arm-rpi3/usb_dwc_regs.h:                uint32_t size         : 19; /* Bits 0-18  */
system/platforms/arm-rpi3/usb_dwc_regs.h:                uint32_t packet_count : 10; /* Bits 19-28 */
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * needs to be re-programmed if the transfer is moved to a
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * different channel or the channel is re-used before the
system/platforms/arm-rpi3/usb_dwc_regs.h:                 * field so that it can be re-programmed correctly.
system/platforms/arm-rpi3/usb_dwc_regs.h:                uint32_t packet_id    : 2;  /* Bits 29-30 */
system/platforms/arm-rpi3/usb_dwc_regs.h:         * Channel DMA Address Register -
system/platforms/arm-rpi3/usb_dwc_regs.h:         * Word-aligned address at which the hardware will read or write data
system/platforms/arm-rpi3/usb_dwc_regs.h:         * BCM2835-specific note:  Theoretically, addresses written to this
system/platforms/arm-rpi3/usb_dwc_regs.h:    uint32_t host_reserved_after_channels[(0x800 - 0x500 -
system/platforms/arm-rpi3/usb_dwc_regs.h:    uint32_t reserved_0x800[(0xe00 - 0x800) / sizeof(uint32_t)];
Binary file system/platforms/arm-rpi3/intutils.o matches
system/platforms/arm-rpi3/intutils.d:../system/platforms/arm-rpi3/intutils.o: \
system/platforms/arm-rpi3/intutils.d: ../system/platforms/arm-rpi3/intutils.S
Binary file system/platforms/arm-rpi3/ctxsw.o matches
system/platforms/arm-rpi3/ctxsw.d:../system/platforms/arm-rpi3/ctxsw.o: \
system/platforms/arm-rpi3/ctxsw.d: ../system/platforms/arm-rpi3/ctxsw.S ../include/arm.h
Binary file system/platforms/arm-rpi3/halt.o matches
system/platforms/arm-rpi3/halt.d:../system/platforms/arm-rpi3/halt.o: ../system/platforms/arm-rpi3/halt.S \
Binary file system/platforms/arm-rpi3/memory_barrier.o matches
system/platforms/arm-rpi3/memory_barrier.d:../system/platforms/arm-rpi3/memory_barrier.o: \
system/platforms/arm-rpi3/memory_barrier.d: ../system/platforms/arm-rpi3/memory_barrier.S
Binary file system/platforms/arm-rpi3/irq_handler.o matches
system/platforms/arm-rpi3/irq_handler.d:../system/platforms/arm-rpi3/irq_handler.o: \
system/platforms/arm-rpi3/irq_handler.d: ../system/platforms/arm-rpi3/irq_handler.S ../include/arm.h
Binary file system/platforms/arm-rpi3/pause.o matches
system/platforms/arm-rpi3/pause.d:../system/platforms/arm-rpi3/pause.o: \
system/platforms/arm-rpi3/pause.d: ../system/platforms/arm-rpi3/pause.S
Binary file system/platforms/arm-rpi3/getmode.o matches
system/platforms/arm-rpi3/getmode.d:../system/platforms/arm-rpi3/getmode.o: \
system/platforms/arm-rpi3/getmode.d: ../system/platforms/arm-rpi3/getmode.S
Binary file system/platforms/arm-rpi3/getcpuid.o matches
system/platforms/arm-rpi3/getcpuid.d:../system/platforms/arm-rpi3/getcpuid.o: \
system/platforms/arm-rpi3/getcpuid.d: ../system/platforms/arm-rpi3/getcpuid.S
Binary file system/platforms/arm-rpi3/setupCores.o matches
system/platforms/arm-rpi3/setupCores.d:../system/platforms/arm-rpi3/setupCores.o: \
system/platforms/arm-rpi3/setupCores.d: ../system/platforms/arm-rpi3/setupCores.S ../include/arm.h \
system/platforms/arm-rpi3/setupCores.d: ../system/platforms/arm-rpi3/mmu.h
system/platforms/arm-rpi3/setupCores.d:../system/platforms/arm-rpi3/mmu.h:
Binary file system/platforms/arm-rpi3/setmode.o matches
system/platforms/arm-rpi3/setmode.d:../system/platforms/arm-rpi3/setmode.o: \
system/platforms/arm-rpi3/setmode.d: ../system/platforms/arm-rpi3/setmode.S ../include/arm.h
Binary file system/platforms/arm-rpi3/mutex.o matches
system/platforms/arm-rpi3/mutex.d:../system/platforms/arm-rpi3/mutex.o: \
system/platforms/arm-rpi3/mutex.d: ../system/platforms/arm-rpi3/mutex.S \
system/platforms/arm-rpi3/mutex.d: ../system/platforms/arm-rpi3/mutex.h
system/platforms/arm-rpi3/mutex.d:../system/platforms/arm-rpi3/mutex.h:
Binary file system/platforms/arm-rpi3/mmu_util.o matches
system/platforms/arm-rpi3/mmu_util.d:../system/platforms/arm-rpi3/mmu_util.o: \
system/platforms/arm-rpi3/mmu_util.d: ../system/platforms/arm-rpi3/mmu_util.S
Binary file system/platforms/arm-rpi3/preload_data.o matches
system/platforms/arm-rpi3/preload_data.d:../system/platforms/arm-rpi3/preload_data.o: \
system/platforms/arm-rpi3/preload_data.d: ../system/platforms/arm-rpi3/preload_data.S
Binary file system/platforms/arm-rpi3/setupStack.o matches
system/platforms/arm-rpi3/setupStack.d:../system/platforms/arm-rpi3/setupStack.o: \
system/platforms/arm-rpi3/setupStack.d: ../system/platforms/arm-rpi3/setupStack.c ../include/platform.h \
Binary file system/platforms/arm-rpi3/bcm2837_power.o matches
system/platforms/arm-rpi3/bcm2837_power.d:../system/platforms/arm-rpi3/bcm2837_power.o: \
system/platforms/arm-rpi3/bcm2837_power.d: ../system/platforms/arm-rpi3/bcm2837_power.c \
system/platforms/arm-rpi3/bcm2837_power.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/stddef.h \
system/platforms/arm-rpi3/bcm2837_power.d: ../system/platforms/arm-rpi3/bcm2837_mbox.h ../include/stdint.h
system/platforms/arm-rpi3/bcm2837_power.d:../system/platforms/arm-rpi3/bcm2837.h:
system/platforms/arm-rpi3/bcm2837_power.d:../system/platforms/arm-rpi3/bcm2837_mbox.h:
Binary file system/platforms/arm-rpi3/dispatch.o matches
system/platforms/arm-rpi3/dispatch.d:../system/platforms/arm-rpi3/dispatch.o: \
system/platforms/arm-rpi3/dispatch.d: ../system/platforms/arm-rpi3/dispatch.c \
system/platforms/arm-rpi3/dispatch.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/platforms/arm-rpi3/dispatch.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/kernel.h \
system/platforms/arm-rpi3/dispatch.d:../system/platforms/arm-rpi3/interrupt.h:
system/platforms/arm-rpi3/dispatch.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/platforms/arm-rpi3/kexec.o matches
system/platforms/arm-rpi3/kexec.d:../system/platforms/arm-rpi3/kexec.o: \
system/platforms/arm-rpi3/kexec.d: ../system/platforms/arm-rpi3/kexec.c \
system/platforms/arm-rpi3/kexec.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/platforms/arm-rpi3/kexec.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/kernel.h \
system/platforms/arm-rpi3/kexec.d:../system/platforms/arm-rpi3/interrupt.h:
system/platforms/arm-rpi3/kexec.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/platforms/arm-rpi3/platforminit.o matches
system/platforms/arm-rpi3/platforminit.d:../system/platforms/arm-rpi3/platforminit.o: \
system/platforms/arm-rpi3/platforminit.d: ../system/platforms/arm-rpi3/platforminit.c ../include/platform.h \
system/platforms/arm-rpi3/platforminit.d: ../system/platforms/arm-rpi3/bcm2837.h \
system/platforms/arm-rpi3/platforminit.d: ../system/platforms/arm-rpi3/rpi_gpio.h \
system/platforms/arm-rpi3/platforminit.d: ../system/platforms/arm-rpi3/../../../device/uart-pl011/pl011.h \
system/platforms/arm-rpi3/platforminit.d: ../system/platforms/arm-rpi3/mmu.h ../system/platforms/arm-rpi3/random.h
system/platforms/arm-rpi3/platforminit.d:../system/platforms/arm-rpi3/bcm2837.h:
system/platforms/arm-rpi3/platforminit.d:../system/platforms/arm-rpi3/rpi_gpio.h:
system/platforms/arm-rpi3/platforminit.d:../system/platforms/arm-rpi3/../../../device/uart-pl011/pl011.h:
system/platforms/arm-rpi3/platforminit.d:../system/platforms/arm-rpi3/mmu.h:
system/platforms/arm-rpi3/platforminit.d:../system/platforms/arm-rpi3/random.h:
Binary file system/platforms/arm-rpi3/timer.o matches
system/platforms/arm-rpi3/timer.d:../system/platforms/arm-rpi3/timer.o: \
system/platforms/arm-rpi3/timer.d: ../system/platforms/arm-rpi3/timer.c ../include/clock.h \
system/platforms/arm-rpi3/timer.d: ../system/platforms/arm-rpi3/bcm2837.h
system/platforms/arm-rpi3/timer.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/platforms/arm-rpi3/usb_dwc_hcd.o matches
system/platforms/arm-rpi3/usb_dwc_hcd.d:../system/platforms/arm-rpi3/usb_dwc_hcd.o: \
system/platforms/arm-rpi3/usb_dwc_hcd.d: ../system/platforms/arm-rpi3/usb_dwc_hcd.c \
system/platforms/arm-rpi3/usb_dwc_hcd.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/platforms/arm-rpi3/usb_dwc_hcd.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/mailbox.h \
system/platforms/arm-rpi3/usb_dwc_hcd.d: ../system/platforms/arm-rpi3/usb_dwc_regs.h ../include/usb_hcdi.h \
system/platforms/arm-rpi3/usb_dwc_hcd.d:../system/platforms/arm-rpi3/interrupt.h:
system/platforms/arm-rpi3/usb_dwc_hcd.d:../system/platforms/arm-rpi3/bcm2837.h:
system/platforms/arm-rpi3/usb_dwc_hcd.d:../system/platforms/arm-rpi3/usb_dwc_regs.h:
Binary file system/platforms/arm-rpi3/watchdog.o matches
system/platforms/arm-rpi3/watchdog.d:../system/platforms/arm-rpi3/watchdog.o: \
system/platforms/arm-rpi3/watchdog.d: ../system/platforms/arm-rpi3/watchdog.c ../include/stddef.h \
system/platforms/arm-rpi3/watchdog.d: ../system/platforms/arm-rpi3/bcm2837.h
system/platforms/arm-rpi3/watchdog.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/platforms/arm-rpi3/unparkcore.o matches
system/platforms/arm-rpi3/unparkcore.d:../system/platforms/arm-rpi3/unparkcore.o: \
system/platforms/arm-rpi3/unparkcore.d: ../system/platforms/arm-rpi3/unparkcore.c ../include/stddef.h \
system/platforms/arm-rpi3/unparkcore.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/platforms/arm-rpi3/unparkcore.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/platforms/arm-rpi3/unparkcore.d: ../include/memory.h ../include/core.h ../system/platforms/arm-rpi3/mmu.h \
system/platforms/arm-rpi3/unparkcore.d:../system/platforms/arm-rpi3/interrupt.h:
system/platforms/arm-rpi3/unparkcore.d:../system/platforms/arm-rpi3/bcm2837.h:
system/platforms/arm-rpi3/unparkcore.d:../system/platforms/arm-rpi3/mmu.h:
Binary file system/platforms/arm-rpi3/mmu.o matches
system/platforms/arm-rpi3/mmu.d:../system/platforms/arm-rpi3/mmu.o: ../system/platforms/arm-rpi3/mmu.c \
system/platforms/arm-rpi3/mmu.d: ../system/platforms/arm-rpi3/mmu.h
system/platforms/arm-rpi3/mmu.d:../system/platforms/arm-rpi3/mmu.h:
Binary file system/platforms/arm-rpi3/random.o matches
system/platforms/arm-rpi3/random.d:../system/platforms/arm-rpi3/random.o: \
system/platforms/arm-rpi3/random.d: ../system/platforms/arm-rpi3/random.c \
system/platforms/arm-rpi3/random.d: ../system/platforms/arm-rpi3/random.h \
system/platforms/arm-rpi3/random.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/stddef.h
system/platforms/arm-rpi3/random.d:../system/platforms/arm-rpi3/random.h:
system/platforms/arm-rpi3/random.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/platforms/arm-rpi3/bcm2837_mbox.o matches
system/platforms/arm-rpi3/bcm2837_mbox.d:../system/platforms/arm-rpi3/bcm2837_mbox.o: \
system/platforms/arm-rpi3/bcm2837_mbox.d: ../system/platforms/arm-rpi3/bcm2837_mbox.c ../include/kernel.h \
system/platforms/arm-rpi3/bcm2837_mbox.d: ../system/platforms/arm-rpi3/bcm2837_mbox.h \
system/platforms/arm-rpi3/bcm2837_mbox.d: ../system/platforms/arm-rpi3/bcm2837.h
system/platforms/arm-rpi3/bcm2837_mbox.d:../system/platforms/arm-rpi3/bcm2837_mbox.h:
system/platforms/arm-rpi3/bcm2837_mbox.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/platforms/arm-rpi3/des.o matches
system/platforms/arm-rpi3/des.d:../system/platforms/arm-rpi3/des.o: ../system/platforms/arm-rpi3/des.c \
system/platforms/arm-rpi3/des.d: ../system/platforms/arm-rpi3/interrupt.h \
system/platforms/arm-rpi3/des.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/platforms/arm-rpi3/des.d: ../include/clock.h ../system/platforms/arm-rpi3/des.h \
system/platforms/arm-rpi3/des.d: ../system/platforms/arm-rpi3/random.h \
system/platforms/arm-rpi3/des.d: ../system/platforms/arm-rpi3/bcm2837.h
system/platforms/arm-rpi3/des.d:../system/platforms/arm-rpi3/interrupt.h:
system/platforms/arm-rpi3/des.d:../system/platforms/arm-rpi3/bcm2837.h:
system/platforms/arm-rpi3/des.d:../system/platforms/arm-rpi3/des.h:
system/platforms/arm-rpi3/des.d:../system/platforms/arm-rpi3/random.h:
system/platforms/arm-rpi3/des.d:../system/platforms/arm-rpi3/bcm2837.h:
system/putc.c:    return ((*devptr->putc) (devptr, ch));
system/read.c: *      count in the event of a read error or end-of-file condition.
system/read.c:    return ((*devptr->read) (devptr, buffer, count));
system/ready.c:    thrptr->state = THRREADY;
system/ready.c:    insert(tid, readylist, thrptr->prio);
system/receive.c: * receive - wait for a message and return it
system/receive.c:    if (FALSE == thrptr->hasmsg)
system/receive.c:        thrptr->state = THRRECV;
system/receive.c:    msg = thrptr->msg;          /* retrieve message                */
system/receive.c:    thrptr->hasmsg = FALSE;     /* reset message flag              */
system/recvclr.c:    if (thrptr->hasmsg)
system/recvclr.c:        msg = thrptr->msg;
system/recvclr.c:    thrptr->hasmsg = FALSE;     /* reset message flag   */
system/recvtime.c:    if (FALSE == thrptr->hasmsg)
system/recvtime.c:    if (thrptr->hasmsg)
system/recvtime.c:        msg = thrptr->msg;      /* retrieve message              */
system/recvtime.c:        thrptr->hasmsg = FALSE; /* reset message flag            */
system/resched.c:    throld->intmask = disable();
system/resched.c:    if (THRCURR == throld->state)
system/resched.c:        if (nonempty(readylist) && (throld->prio > firstkey(readylist)))
system/resched.c:            restore(throld->intmask);
system/resched.c:        throld->state = THRREADY;
system/resched.c:        insert(thrcurrent, readylist, throld->prio);
system/resched.c:    thrnew->state = THRCURR;
system/resched.c:    ctxsw(&throld->stkptr, &thrnew->stkptr, asid);
system/resched.c:    restore(throld->intmask);
system/resume.c:    if (isbadtid(tid) || (thrptr->state != THRSUSP))
system/resume.c:    prio = thrptr->prio;
system/seek.c:    return ((*devptr->seek) (devptr, pos));
system/semcreate.c: *      is available).  Must be non-negative.
system/semfree.c:    while (nonempty(semptr->queue))
system/semfree.c:        tid = dequeue(semptr->queue);   /* free waiting threads */
system/semfree.c:    semptr->count = 0;
system/semfree.c:    semptr->state = SFREE;
system/send.c:    if ((THRFREE == thrptr->state) || thrptr->hasmsg)
system/send.c:    thrptr->msg = msg;          /* deposit message                */
system/send.c:    thrptr->hasmsg = TRUE;      /* raise message flag             */
system/send.c:    if (THRRECV == thrptr->state)
system/send.c:    else if (THRTMOUT == thrptr->state)
system/signal.c: * should not be called from non-reentrant interrupt handlers unless ::resdefer
system/signal.c:    if ((semptr->count++) < 0)
system/signal.c:        ready(dequeue(semptr->queue), RESCHED_YES);
system/signaln.c: * signaln() should not be called from non-reentrant interrupt handlers unless
system/signaln.c:    for (; count > 0; count--)
system/signaln.c:        if ((semptr->count++) < 0)
system/signaln.c:            ready(dequeue(semptr->queue), RESCHED_NO);
system/stkget.c:        if (next->length >= nbytes)
system/stkget.c:        next = next->next;
system/stkget.c:    if (nbytes == fits->length)
system/stkget.c:        fitsprev->next = fits->next;
system/stkget.c:        fits->length -= nbytes;
system/stkget.c:        fits = (struct memblock *)((ulong)fits + fits->length);
system/stkget.c:    memlist.length -= nbytes;
system/stkget.c:    return (void *)((ulong)fits + nbytes - sizeof(int));
system/suspend.c:    if ((thrptr->state != THRCURR) && (thrptr->state != THRREADY))
system/suspend.c:    if (THRREADY == thrptr->state)
system/suspend.c:        thrptr->state = THRSUSP;
system/suspend.c:        thrptr->state = THRSUSP;
system/suspend.c:    prio = thrptr->prio;
system/tar.c:        if (0x00 == file->filename[0])
system/tar.c:                file->filename, TAR_FILENAME_LEN);
system/tar.c:        filesize = tarFilesize(file->filesize);
system/tar.c:        if (0x00 == file->filename[0])
system/tar.c:        if (0 == strncmp(filename, file->filename, TAR_FILENAME_LEN))
system/tar.c:        filesize = tarFilesize(file->filesize);
system/tar.c:    return tarFilesize(file->filesize);
system/tar.c:    data = file->type.data;
system/tar.c:    filesize = tarFilesize(file->filesize);
system/tar.c:    if (0 == strncmp((void *)&(file->type.ustar.isustar), "ustar", 5))
system/tar.c:        data = file->type.ustar.data;
system/tar.c:    for (i = 0; i < (TAR_FILESIZE_LEN - 1); i++)
system/tar.c:        size += (octalsize[i] - '0');
system/udelay.c:/* The below udelay() implementation is platform-independent and only depends on
system/udelay.c: * clkcount() being implemented by the platform-specific code.  However it does
system/udelay.c: * Thus, this is not platform-independent.
system/udelay.c: * Busy-waits for a number of microseconds.
system/unistd.c:            i = i * 10 + c - '0';
system/unlock.c:    if (monptr->count == 0)
system/unlock.c:    (monptr->count)--;
system/unlock.c:    /* if this is the top-level unlock call, then free this monitor's lock */
system/unlock.c:    if (monptr->count == 0)
system/unlock.c:        monptr->owner = NOOWNER;
system/unlock.c:        signal(monptr->sem);
system/unsleep.c:    if ((thrptr->state != THRSLEEP) && (thrptr->state != THRTMOUT))
system/wait.c:    if (--(semptr->count) < 0)
system/wait.c:        thrptr->state = THRWAIT;
system/wait.c:        thrptr->sem = sem;
system/wait.c:        enqueue(thrcurrent, semptr->queue);
system/write.c:    return ((*devptr->write) (devptr, buffer, count));
system/conf.c: * dev-number, minor-number, dev-name,
system/conf.c: * dev-csr-address, intr-handler, irq
system/initialize.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/initialize.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
system/initialize.d:../system/platforms/arm-rpi3/interrupt.h:
system/initialize.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/initialize.o matches
Binary file system/conf.o matches
system/main.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/main.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
system/main.d:../system/platforms/arm-rpi3/interrupt.h:
system/main.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/main.o matches
Binary file system/kill.o matches
Binary file system/queue.o matches
system/queue.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/queue.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/queue.d:../system/platforms/arm-rpi3/interrupt.h:
system/queue.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/create.o matches
system/create.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/create.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/create.d:../system/platforms/arm-rpi3/interrupt.h:
system/create.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/resched.o matches
system/resched.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/resched.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/resched.d:../system/platforms/arm-rpi3/interrupt.h:
system/resched.d:../system/platforms/arm-rpi3/bcm2837.h:
system/kill.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/kill.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/kill.d:../system/platforms/arm-rpi3/interrupt.h:
system/kill.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/ready.o matches
system/ready.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/ready.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/ready.d:../system/platforms/arm-rpi3/interrupt.h:
system/ready.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/clkhandler.o matches
system/clkhandler.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/clkhandler.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/clkhandler.d:../system/platforms/arm-rpi3/interrupt.h:
system/clkhandler.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/resume.o matches
system/resume.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/resume.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/resume.d:../system/platforms/arm-rpi3/interrupt.h:
system/resume.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/suspend.o matches
system/suspend.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/suspend.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/suspend.d:../system/platforms/arm-rpi3/interrupt.h:
system/suspend.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/getitem.o matches
Binary file system/queinit.o matches
Binary file system/insert.o matches
system/insert.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/insert.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/insert.d:../system/platforms/arm-rpi3/interrupt.h:
system/insert.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/gettid.o matches
system/gettid.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/gettid.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/gettid.d:../system/platforms/arm-rpi3/interrupt.h:
system/gettid.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/xdone.o matches
system/xdone.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/xdone.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/xdone.d:../system/platforms/arm-rpi3/interrupt.h:
system/xdone.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/yield.o matches
system/yield.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/yield.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/yield.d:../system/platforms/arm-rpi3/interrupt.h:
system/yield.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/userret.o matches
system/userret.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/userret.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/userret.d:../system/platforms/arm-rpi3/interrupt.h:
system/userret.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/getprio.o matches
system/getprio.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/getprio.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/getprio.d:../system/platforms/arm-rpi3/interrupt.h:
system/getprio.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/clkinit.o matches
system/clkinit.d: ../system/platforms/arm-rpi3/interrupt.h \
system/clkinit.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/clock.h \
system/clkinit.d:../system/platforms/arm-rpi3/interrupt.h:
system/clkinit.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/mdelay.o matches
Binary file system/insertd.o matches
system/insertd.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/insertd.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/insertd.d:../system/platforms/arm-rpi3/interrupt.h:
system/insertd.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/sleep.o matches
system/sleep.d: ../include/compiler.h ../system/platforms/arm-rpi3/interrupt.h \
system/sleep.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/thread.h \
system/sleep.d:../system/platforms/arm-rpi3/interrupt.h:
system/sleep.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/unsleep.o matches
system/unsleep.d: ../include/compiler.h ../system/platforms/arm-rpi3/interrupt.h \
system/unsleep.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/thread.h \
system/unsleep.d:../system/platforms/arm-rpi3/interrupt.h:
system/unsleep.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/wakeup.o matches
system/wakeup.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/wakeup.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/wakeup.d:../system/platforms/arm-rpi3/interrupt.h:
system/wakeup.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/udelay.o matches
Binary file system/signal.o matches
system/signal.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/signal.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/signal.d:../system/platforms/arm-rpi3/interrupt.h:
system/signal.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/signaln.o matches
system/signaln.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/signaln.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/signaln.d:../system/platforms/arm-rpi3/interrupt.h:
system/signaln.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/wait.o matches
system/wait.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/wait.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/wait.d:../system/platforms/arm-rpi3/interrupt.h:
system/wait.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/semcreate.o matches
system/semcreate.d: ../system/platforms/arm-rpi3/interrupt.h \
system/semcreate.d: ../system/platforms/arm-rpi3/bcm2837.h
system/semcreate.d:../system/platforms/arm-rpi3/interrupt.h:
system/semcreate.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/lock.o matches
Binary file system/semfree.o matches
system/semfree.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/semfree.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/semfree.d:../system/platforms/arm-rpi3/interrupt.h:
system/semfree.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/semcount.o matches
Binary file system/moncreate.o matches
system/moncreate.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/moncreate.d: ../include/stddef.h ../system/platforms/arm-rpi3/bcm2837.h \
system/moncreate.d:../system/platforms/arm-rpi3/interrupt.h:
system/moncreate.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/monfree.o matches
system/monfree.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/monfree.d: ../include/stddef.h ../system/platforms/arm-rpi3/bcm2837.h \
system/monfree.d:../system/platforms/arm-rpi3/interrupt.h:
system/monfree.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/moncount.o matches
system/moncount.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/moncount.d: ../include/stddef.h ../system/platforms/arm-rpi3/bcm2837.h \
system/moncount.d:../system/platforms/arm-rpi3/interrupt.h:
system/moncount.d:../system/platforms/arm-rpi3/bcm2837.h:
system/lock.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/lock.d: ../include/stddef.h ../system/platforms/arm-rpi3/bcm2837.h \
system/lock.d:../system/platforms/arm-rpi3/interrupt.h:
system/lock.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/unlock.o matches
system/unlock.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/unlock.d: ../include/stddef.h ../system/platforms/arm-rpi3/bcm2837.h \
system/unlock.d:../system/platforms/arm-rpi3/interrupt.h:
system/unlock.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/memget.o matches
system/memget.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/memget.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/memory.h
system/memget.d:../system/platforms/arm-rpi3/interrupt.h:
system/memget.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/memfree.o matches
system/memfree.d: ../system/platforms/arm-rpi3/interrupt.h \
system/memfree.d: ../system/platforms/arm-rpi3/bcm2837.h
system/memfree.d:../system/platforms/arm-rpi3/interrupt.h:
system/memfree.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/stkget.o matches
system/stkget.d: ../include/memory.h ../system/platforms/arm-rpi3/interrupt.h \
system/stkget.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/platform.h \
system/stkget.d:../system/platforms/arm-rpi3/interrupt.h:
system/stkget.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/bfpalloc.o matches
system/bfpalloc.d: ../system/platforms/arm-rpi3/interrupt.h \
system/bfpalloc.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/memory.h \
system/bfpalloc.d:../system/platforms/arm-rpi3/interrupt.h:
system/bfpalloc.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/bfpfree.o matches
system/bfpfree.d: ../system/platforms/arm-rpi3/interrupt.h \
system/bfpfree.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/memory.h \
system/bfpfree.d:../system/platforms/arm-rpi3/interrupt.h:
system/bfpfree.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/bufget.o matches
system/bufget.d: ../system/platforms/arm-rpi3/interrupt.h \
system/bufget.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/bufpool.h
system/bufget.d:../system/platforms/arm-rpi3/interrupt.h:
system/bufget.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/send.o matches
Binary file system/buffree.o matches
system/buffree.d: ../system/platforms/arm-rpi3/interrupt.h \
system/buffree.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/bufpool.h
system/buffree.d:../system/platforms/arm-rpi3/interrupt.h:
system/buffree.d:../system/platforms/arm-rpi3/bcm2837.h:
system/send.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/send.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/send.d:../system/platforms/arm-rpi3/interrupt.h:
system/send.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/receive.o matches
system/receive.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/receive.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/receive.d:../system/platforms/arm-rpi3/interrupt.h:
system/receive.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/recvclr.o matches
system/recvclr.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
system/recvclr.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/recvclr.d:../system/platforms/arm-rpi3/interrupt.h:
system/recvclr.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/recvtime.o matches
system/recvtime.d: ../system/platforms/arm-rpi3/interrupt.h \
system/recvtime.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/recvtime.d:../system/platforms/arm-rpi3/interrupt.h:
system/recvtime.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file system/close.o matches
Binary file system/control.o matches
Binary file system/getc.o matches
Binary file system/ioerr.o matches
Binary file system/ionull.o matches
Binary file system/read.o matches
Binary file system/putc.o matches
Binary file system/seek.o matches
Binary file system/write.o matches
Binary file system/getdev.o matches
Binary file system/open.o matches
Binary file system/debug.o matches
system/debug.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
system/debug.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
system/debug.d:../system/platforms/arm-rpi3/interrupt.h:
system/debug.d:../system/platforms/arm-rpi3/bcm2837.h:
test/test_arp.c:#define ELOOP (-1)
test/test_arp.c:        pkt->nif = netptr;
test/test_arp.c:    pkt->len +=
test/test_arp.c:    pkt->curr -= pkt->len;
test/test_arp.c:    arp = (struct arpPkt *)pkt->curr;
test/test_arp.c:    arp->hwtype = hs2net(ARP_HWTYPE_ETHERNET);
test/test_arp.c:    arp->prtype = hs2net(ARP_PRTYPE_IPv4);
test/test_arp.c:    arp->hwalen = ETH_ADDR_LEN;
test/test_arp.c:    arp->pralen = IPv4_ADDR_LEN;
test/test_arp.c:    arp->op = hs2net(ARP_OP_RQST);
test/test_arp.c:    memcpy(&arp->addrs[ARP_ADDR_SHA(arp)], netptr->hwaddr.addr,
test/test_arp.c:           arp->hwalen);
test/test_arp.c:    memcpy(&arp->addrs[ARP_ADDR_SPA(arp)], netptr->ip.addr, arp->pralen);
test/test_arp.c:    memcpy(&arp->addrs[ARP_ADDR_DPA(arp)], praddr.addr, arp->pralen);
test/test_arp.c:    failif((0 != memcmp(data + ELOOP_LINKHDRSIZE, arp, pkt->len)), "");
test/test_arp.c:    arp->op = hs2net(ARP_OP_REPLY);
test/test_arp.c:    memcpy(&arp->addrs[ARP_ADDR_DHA(arp)], &arp->addrs[ARP_ADDR_SHA(arp)],
test/test_arp.c:           arp->hwalen);
test/test_arp.c:    arp->addrs[ARP_ADDR_DHA(arp) + ETH_ADDR_LEN - 1] = 0xCC;
test/test_arp.c:    memcpy(&arp->addrs[ARP_ADDR_DPA(arp)], praddr.addr, arp->pralen);
test/test_arp.c:    memcpy(&arp->addrs[ARP_ADDR_SHA(arp)], netptr->hwaddr.addr,
test/test_arp.c:           arp->hwalen);
test/test_arp.c:    memcpy(&arp->addrs[ARP_ADDR_SPA(arp)], netptr->ip.addr, arp->pralen);
test/test_arp.c:    failif((0 != memcmp(data + ELOOP_LINKHDRSIZE, arp, pkt->len)), "");
test/test_arp.c:            || (0 == (entry->state & ARP_USED))), "");
test/test_arp.c:            || (0 == (entry->state & ARP_USED))), "");
test/test_arp.c:    entry->state = ARP_UNRESOLVED;
test/test_arp.c:        entry->waiting[i] = tid;
test/test_arp.c:        entry->count++;
test/test_arp.c:    failif(nout || (entry->count != 0), "");
test/test_arp.c:    entry->state = ARP_RESOLVED;
test/test_arp.c:    entry->expires = clktime;
test/test_arp.c:    failif(((SYSERR == arpFree(entry)) || (entry->expires != 0)), "");
test/test_arp.c:    entry->state = ARP_UNRESOLVED;
test/test_arp.c:        entry->waiting[i] = tid;
test/test_arp.c:        entry->count++;
test/test_arp.c:        failif(nout || (entry->count != 0), "");
test/test_arp.c:        entry->state = ARP_RESOLVED;
test/test_arp.c:        entry->nif = netptr;
test/test_arp.c:        netaddrcpy(&entry->hwaddr, &hwaddr);
test/test_arp.c:        netaddrcpy(&entry->praddr, &praddr);
test/test_arp.c:        entry->expires = clktime + ARP_TTL_RESOLVED;
test/test_arp.c:    arptab[i].expires = clktime - 1;
test/test_arp.c:    /* Test receive reply for non-existing ARP table entry */
test/test_arp.c:    nout = pelp->nout;
test/test_arp.c:    nproc = netptr->nproc;
test/test_arp.c:    while ((wait < MAX_WAIT) && (netptr->nproc == nproc))
test/test_arp.c:        else if ((FALSE == netaddrequal(&praddr, &entry->praddr))
test/test_arp.c:                 || (FALSE == netaddrequal(&hwaddr, &entry->hwaddr))
test/test_arp.c:                 || (entry->nif != netptr) || (entry->count != 0))
test/test_arp.c:        else if (pelp->nout > (nout + 1))
test/test_arp.c:    /* Test receive request for non-existing ARP table entry */
test/test_arp.c:    nout = pelp->nout;
test/test_arp.c:    nproc = netptr->nproc;
test/test_arp.c:    while ((wait < MAX_WAIT) && (netptr->nproc == nproc))
test/test_arp.c:        else if ((FALSE == netaddrequal(&praddr, &entry->praddr))
test/test_arp.c:                 || (FALSE == netaddrequal(&hwaddr, &entry->hwaddr))
test/test_arp.c:                 || (entry->nif != netptr) || (entry->count != 0))
test/test_arp.c:    /* Test receive request for non-supported hardware type */
test/test_arp.c:    nproc = netptr->nproc;
test/test_arp.c:    while ((wait < MAX_WAIT) && (netptr->nproc == nproc))
test/test_arp.c:    /* Test receive reply for non-supported protocol type */
test/test_arp.c:    nproc = netptr->nproc;
test/test_arp.c:    while ((wait < MAX_WAIT) && (netptr->nproc == nproc))
test/test_arp.c:    nout = pelp->nout;
test/test_arp.c:    nproc = netptr->nproc;
test/test_arp.c:    while ((wait < MAX_WAIT) && (netptr->nproc == nproc))
test/test_arp.c:        failif((FALSE == netaddrequal(&hwaddr, &entry->hwaddr)),
test/test_arp.c:    nproc = netptr->nproc;
test/test_arp.c:    while ((wait < MAX_WAIT) && (netptr->nproc == nproc))
test/test_arp.c:    entry->state = ARP_UNRESOLVED;
test/test_arp.c:    entry->nif = netptr;
test/test_arp.c:    netaddrcpy(&entry->hwaddr, &hwaddr);
test/test_arp.c:    netaddrcpy(&entry->praddr, &praddr);
test/test_arp.c:    entry->expires = clktime + ARP_TTL_UNRESOLVED;
test/test_arp.c:    entry->state = ARP_RESOLVED;
test/test_arp.c:    entry->nif = netptr;
test/test_arp.c:    netaddrcpy(&entry->hwaddr, &hwaddr);
test/test_arp.c:    netaddrcpy(&entry->praddr, &praddr);
test/test_arp.c:    entry->expires = clktime + ARP_TTL_UNRESOLVED;
test/test_arp.c:    entry->state = ARP_UNRESOLVED;
test/test_arp.c:    entry->nif = netptr;
test/test_arp.c:    netaddrcpy(&entry->hwaddr, &hwaddr);
test/test_arp.c:    netaddrcpy(&entry->praddr, &praddr);
test/test_arp.c:    entry->expires = clktime + ARP_TTL_UNRESOLVED;
test/test_arp.c:    entry->state = ARP_UNRESOLVED;
test/test_arp.c:    entry->count = ARP_NTHRWAIT;
test/test_arp.c:    testPrint(verbose, "Lookup non-existing unresolved addr");
test/test_bufpool.c:        memsize - ((TBUFSIZE + sizeof(struct poolbuf)) * TBUFNUM))
test/test_deltaQueue.c:    atid = create((void *)NULL, INITSTK, 0, "DELTA-A", 0);
test/test_deltaQueue.c:    btid = create((void *)NULL, INITSTK, 0, "DELTA-B", 0);
test/test_deltaQueue.c:    ctid = create((void *)NULL, INITSTK, 0, "DELTA-C", 0);
test/test_deltaQueue.c:    dtid = create((void *)NULL, INITSTK, 0, "DELTA-D", 0);
test/test_ether.c:    int dev = peth->dev->num;
test/test_ether.c:    memsize = sizeof(struct etherGram) + MAX_PAYLOAD - 1;
test/test_ether.c:    payload = &(outpkt->payload[0]);
test/test_ether.c:    memcpy(outpkt->dst, mymac, ETH_ADDR_LEN);
test/test_ether.c:    memcpy(outpkt->src, mymac, ETH_ADDR_LEN);
test/test_ether.c:    outpkt->type_len = hs2net(ETH_TYPE_ARP);
test/test_ether.c:    while (peth->icount > 0)
test/test_ether.c:    sprintf(str, "%s 1516 byte packet", peth->dev->name);
test/test_ether.c:    sprintf(str, "%s 1514 byte packet (write)", peth->dev->name);
test/test_ether.c:    sprintf(str, "%s 1514 byte packet (read)", peth->dev->name);
test/test_ether.c:    sprintf(str, "%s  700 byte packet (write)", peth->dev->name);
test/test_ether.c:    sprintf(str, "%s  700 byte packet (read)", peth->dev->name);
test/test_ether.c:    sprintf(str, "%s   30 byte packet (write)", peth->dev->name);
test/test_ether.c:    sprintf(str, "%s   30 byte packet (read)", peth->dev->name);
test/test_ether.c:    sprintf(str, "%s   12 byte packet", peth->dev->name);
test/test_ether.c:    sprintf(str, "%s  512 random-sized packets", peth->dev->name);
test/test_ethloop.c:    devminor = pdev->minor;
test/test_ethloop.c:    sprintf(str, "%s Open", pdev->name);
test/test_ethloop.c:    memsize = sizeof(struct etherGram) + MAX_PAYLOAD - 1;
test/test_ethloop.c:    payload = &(outpkt->payload[0]);
test/test_ethloop.c:    memcpy(outpkt->dst, addr.addr, addr.len);
test/test_ethloop.c:    memcpy(outpkt->src, addr.addr, addr.len);
test/test_ethloop.c:    outpkt->type_len = hs2net(ETH_TYPE_ARP);
test/test_ethloop.c:    sprintf(str, "%s 1516 byte packet", pelp->dev->name);
test/test_ethloop.c:    sprintf(str, "%s 1514 byte packet (write)", pelp->dev->name);
test/test_ethloop.c:    sprintf(str, "%s 1514 byte packet (read)", pelp->dev->name);
test/test_ethloop.c:    sprintf(str, "%s  700 byte packet (write)", pelp->dev->name);
test/test_ethloop.c:    sprintf(str, "%s  700 byte packet (read)", pelp->dev->name);
test/test_ethloop.c:    sprintf(str, "%s   30 byte packet (write)", pelp->dev->name);
test/test_ethloop.c:    sprintf(str, "%s   30 byte packet (read)", pelp->dev->name);
test/test_ethloop.c:    sprintf(str, "%s   12 byte packet", pelp->dev->name);
test/test_ethloop.c:    sprintf(str, "%s  512 random-sized packets", pelp->dev->name);
test/test_ethloop.c:    sprintf(str, "%s  700 byte packet (write hold)", pelp->dev->name);
test/test_ethloop.c:    sprintf(str, "%s  700 byte packet (read hold)", pelp->dev->name);
test/test_ethloop.c:    sprintf(str, "%s  700 byte packet (write drop)", pelp->dev->name);
test/test_ethloop.c:    sprintf(str, "%s  700 byte packet (write)", pelp->dev->name);
test/test_ethloop.c:    outpkt->dst[0] += 1;
test/test_ethloop.c:    sprintf(str, "%s  700 byte packet (read)", pelp->dev->name);
test/test_ethloop.c:    sprintf(str, "%s Close", pdev->name);
test/test_ip.c:#define ELOOP (-1)
test/test_ip.c:#define NNETIF (-1)
test/test_ip.c:    nproc = netptr->nproc;
test/test_ip.c:    while ((wait < MAX_WAIT) && (netptr->nproc == nproc))
test/test_ip.c:        memcpy(pktA->data, data, phdr.caplen);
test/test_ip.c:        pktA->len = phdr.caplen;
test/test_ip.c:        pktA->nif = netptr;
test/test_ip.c:        pktA->linkhdr = pktA->data;
test/test_ip.c:        pktA->nethdr = pktA->linkhdr + ETH_HDR_LEN;
test/test_ip.c:        pktA->curr = pktA->nethdr + IPv4_HDR_LEN;
test/test_ip.c:        pktB->curr -= UDP_HDR_LEN + 4;
test/test_ip.c:        pktB->len += UDP_HDR_LEN + 4;
test/test_ip.c:        memcpy(pktB->curr, pktA->curr, pktB->len);
test/test_ip.c:            failif(0 != memcmp(buf, pktA->linkhdr, pktA->len), "");
test/test_ip.c:	pktA->curr -= IPv4_HDR_LEN;
test/test_libCtype.c:    char *punct = "!\"#$%&’()*+,-./:;<=>?@[\\]^_`{|}~";
test/test_libLimits.c:    c--;
test/test_libLimits.c:    sc--;
test/test_libLimits.c:    s--;
test/test_libLimits.c:    i--;
test/test_libLimits.c:    l--;
test/test_libStdio.c:#define TEST_STR_LEN (sizeof(TEST_STR) - 1)
test/test_libStdio.c:    /* fgets - test basic functionality */
test/test_libStdio.c:    /* fgets - Test partial reads */
test/test_libStdio.c:    /* fgets - check returns NULL at end-of-file */
test/test_libStdio.c:    testPrint(verbose, "fgets: return NULL on end-of-file");
test/test_libStdio.c:    failif(pret != NULL, "fgets failed to return NULL on end-of-file");
test/test_libStdio.c:    /* fgets - Test reading stops at newline */
test/test_libStdio.c:    testPrint(verbose, "getchar: return EOF on end-of-file");
test/test_libStdio.c:    failif(ret != EOF, "getchar failed to return EOF on end-of-file");
test/test_libStdio.c:        .format = "%-10",
test/test_libStdio.c:        .expected_output = "%-10",
test/test_libStdio.c:    { /* Truncated string, max-width specified as vararg */
test/test_libStdio.c:    { /* Non-truncated string, negative max-width has no effect  */
test/test_libStdio.c:        .args = {-1, (uint)"truncate me"},
test/test_libStdio.c:    { /* Truncated string, implicit zero max-width   */
test/test_libStdio.c:    { /* Right justified string, min-width specified as vararg */
test/test_libStdio.c:        .format = "%-8s",
test/test_libStdio.c:    { /* Left justified string, min-width specified as vararg */
test/test_libStdio.c:        .format = "%-*s",
test/test_libStdio.c:    { /* Left justified string via negative min-width specified as vararg */
test/test_libStdio.c:        .args = {-8, (uint)"left"},
test/test_libStdio.c:        .expected_output = "-88",
test/test_libStdio.c:        .args = {-88},
test/test_libStdio.c:        .expected_output = "-2147483648", /* INT_MIN */
test/test_libStdio.c:        .format = "%-06d", /* '-' overrides '0' */
test/test_libStdio.c:        .expected_output = "-00123",
test/test_libStdio.c:        .args = {-123},
test/test_libStdio.c:        .expected_output = "  -123",
test/test_libStdio.c:        .args = {-123},
test/test_libStdio.c:        .format = "%-6d",
test/test_libStdio.c:        .expected_output = "-123  ",
test/test_libStdio.c:        .args = {-123},
test/test_libStdio.c:        .format = "%-6.3d",
test/test_libStdio.c:        .expected_output = "  -003",
test/test_libStdio.c:        .args = {-3},
test/test_libStdio.c:        .format = "%-6.3d",
test/test_libStdio.c:        .expected_output = "-003  ",
test/test_libStdio.c:        .args = {-3},
test/test_libStdio.c:        .format = "literal %08d\t%-8s\t%c%cliteral",
test/test_libStdio.c:                ret = -1;
test/test_libStdio.c:        .input = "-123",
test/test_libStdio.c:        .expected_results = { INT_ARG(-123), },
test/test_libStdio.c:        .input = "-000123",
test/test_libStdio.c:        .expected_results = { INT_ARG(-123), },
test/test_libStdio.c:        .input="-123456",
test/test_libStdio.c:        .expected_results = { INT_ARG(-12), INT_ARG(345), STRING_ARG("6"), },
test/test_libStdio.c:        .input = "     -000123",
test/test_libStdio.c:        .expected_results = { INT_ARG(-123), },
test/test_libStdio.c:        .input = "-2147483648",
test/test_libStdio.c:            switch (arg->type)
test/test_libStdio.c:                ret = -1;
test/test_libStdio.c:            switch (arg->type)
test/test_libStdio.c:                    failif(longs[j] != (long)arg->expected_result,
test/test_libStdio.c:                    failif(ints[j] != (int)arg->expected_result,
test/test_libStdio.c:                    failif(shorts[j] != (short)arg->expected_result,
test/test_libStdio.c:                        size_t len = strlen((char*)arg->expected_result);
test/test_libStdio.c:                                           (char*)arg->expected_result,
test/test_libStdlib.c:        return -1;
test/test_libStdlib.c:        return -1;
test/test_libStdlib.c:    failif((-456 != atoi("-456"))
test/test_libStdlib.c:           || (-1 != atoi("-1one"))
test/test_libStdlib.c:           || (0 != atoi("-on1e"))
test/test_libStdlib.c:    failif((-456 != atol("-456"))
test/test_libStdlib.c:           || (-1 != atol("-1one"))
test/test_libStdlib.c:           || (0 != atol("-one"))
test/test_libStdlib.c:    qsort(list, sizeof(list) - 1, 1, (void *)qsort_callback);
test/test_libStdlib.c:    failif((2147483647 != abs(-2147483647))
test/test_libStdlib.c:    failif((2147483647 != labs(-2147483647))
test/test_libStdlib.c:        for (j = 0; j < len - 1; j++)
test/test_libString.c:    /* find a non-uniq char */
test/test_libString.c:    testPrint(verbose, "Find non-unique char; strchr()");
test/test_libString.c:    failif(str + (LEN_STR - 1) != s1 || '\0' != *s1, "");
test/test_libString.c:    /* find a non-uniq char */
test/test_libString.c:    testPrint(verbose, "Find non-unique char; strrchr()");
test/test_libString.c:    failif(str + (LEN_STR - 1) != s1 || '\0' != *s1, "");
test/test_mailbox.c:        if (pmbox->max != 1)
test/test_mailbox.c:        if (pmbox->max != 384)
test/test_mailbox.c:    /* Test de-allocation (freeing) of mailboxes */
test/test_mailbox.c:    /* Test over-allocation of mailboxes */
test/test_mailbox.c:            i--;
test/test_mailbox.c:    /* Clean-up mailbox allocation */
test/test_mailbox.c:    /* If clean-up went well, passed all allocation tests */
test/test_mailbox.c:        testFail(verbose, "failed sending mail-message to mailbox");
test/test_mailbox.c:        testFail(verbose, "failed receiving mail-message from mailbox");
test/test_mailbox.c:    if (thrptr->state != THRWAIT)
test/test_mailbox.c:    if (thrptr->state != THRWAIT)
test/test_memory.c:/* test_memory -- allocates and frees memory; tests consistency of
test/test_memory.c:                 "\nmemlist->length does not match computed free space");
test/test_memory.c:                     "\nmemlist->length does not match computed free space");
test/test_memory.c:                 "\nmemlist->length does not match computed free space");
test/test_memory.c: * compares this sum with the value maintained in memlist->length
test/test_memory.c:    for (mptr = memlist.next; mptr != NULL; mptr = mptr->next)
test/test_memory.c:        free += mptr->length;
test/test_memory.c:            fnext->fprev = fhead;
test/test_memory.c:            fnext->flen = size;
test/test_memory.c:        fhead = fhead->fprev;
test/test_memory.c:        memfree(fnext, fnext->flen);
test/test_messagePass.c:/* test_messagePass -- Creates two threads; a receiver and a sender.  
test/test_messagePass.c:    /* Receive clear - message pending */
test/test_messagePass.c:        testPrint(verbose, "Receive clear - message pending");
test/test_messagePass.c:    /* Receive clear - no pending message */
test/test_messagePass.c:    testPrint(verbose, "Receive clear - no message pending");
test/test_netaddr.c:    b.len = ETH_ADDR_LEN - 1;
test/test_netif.c:#define ELOOP (-1)
test/test_netif.c:#define NNETIF (-1)
test/test_netif.c:            || (netptr->state != NET_ALLOC)
test/test_netif.c:            || (netptr->mtu != ELOOP_MTU)
test/test_netif.c:            || (netptr->linkhdrlen != ELOOP_LINKHDRSIZE)
test/test_netif.c:            || (FALSE == netaddrequal(&netptr->ip, &ip))
test/test_netif.c:            || (FALSE == netaddrequal(&netptr->mask, &mask))
test/test_netif.c:            || (FALSE == netaddrequal(&netptr->gateway, &gate)))
test/test_netif.c:                if (isbadtid(netptr->recvthr[i]))
test/test_netif.c:        kill(netptr->recvthr[i]);
test/test_netif.c:        netptr->recvthr[i] = BADTID;
test/test_netif.c:    pkt->nif = netptr;
test/test_netif.c:    pkt->len = phdr.caplen - netptr->linkhdrlen;
test/test_netif.c:    pkt->curr = pkt->curr - pkt->len;
test/test_netif.c:    memcpy(pkt->curr, data + netptr->linkhdrlen, pkt->len);
test/test_netif.c:        if ((SYSERR == read(netptr->dev, pkt, phdr.caplen))
test/test_nvram.c:            || (nvram_header->magic != NVRAM_MAGIC)), "erroneous value");
test/test_nvram.c:        str = str - strnlen(NVRAM_GOODVAR, NVRAM_STRMAX) - 1;
test/test_nvram.c:    failif((NULL != str), "non-null value returned");
test/test_procQueue.c:        atid = create((void *)NULL, INITSTK, 0, "PQUEUE-A", 0);
test/test_procQueue.c:        btid = create((void *)NULL, INITSTK, 0, "PQUEUE-B", 0);
test/test_procQueue.c:        ctid = create((void *)NULL, INITSTK, 0, "PQUEUE-C", 0);
test/test_procQueue.c:        dtid = create((void *)NULL, INITSTK, 0, "PQUEUE-D", 0);
test/test_raw.c:        rawptr = &rawtab[devptr->minor];
test/test_raw.c:        failif(((rawptr->state != RAW_ALLOC)
test/test_raw.c:                || (rawptr->dev != devptr)
test/test_raw.c:                || (rawptr->proto != IPv4_PROTO_ICMP)
test/test_raw.c:                || (rawptr->localip.type != NULL)
test/test_raw.c:                || (rawptr->remoteip.type != NULL)
test/test_raw.c:                || (rawptr->icount != 0)
test/test_raw.c:                || (rawptr->istart != 0)
test/test_raw.c:                || (semcount(rawptr->isema) != 0)
test/test_raw.c:                || (rawptr->flags != 0)), "Incorrect control block");
test/test_raw.c:    failif((control(RAW0, -1, NULL, NULL) != SYSERR), "");
test/test_raw.c:            || (0 == (rawptr->flags & RAW_IACCEPT))
test/test_raw.c:            || (0 == (rawptr->flags & RAW_IHDR))), "");
test/test_raw.c:            || (0 == (rawptr->flags & RAW_IACCEPT))
test/test_raw.c:            || (1 == (rawptr->flags & RAW_IHDR))), "");
test/test_raw.c:        rawptr = &rawtab[devptr->minor];
test/test_raw.c:        failif(((rawptr->state != RAW_FREE)
test/test_raw.c:                || (rawptr->dev != NULL)), "Control block not clear");
test/test_raw.c:        rawptr = &rawtab[devptr->minor];
test/test_raw.c:        rawptr = &rawtab[devptr->minor];
test/test_raw.c:        rawptr = &rawtab[devptr->minor];
test/test_raw.c:        rawptr = &rawtab[devptr->minor];
test/test_raw.c:        rawptr = &rawtab[devptr->minor];
test/test_raw.c:        failif(((rawptr->state != RAW_ALLOC)
test/test_raw.c:                || (rawptr->dev != devptr)
test/test_raw.c:                || (rawptr->proto != IPv4_PROTO_ICMP)
test/test_raw.c:                || (FALSE == netaddrequal(&lip, &rawptr->localip))
test/test_raw.c:                || (FALSE == netaddrequal(&rip, &rawptr->remoteip))
test/test_raw.c:                || (rawptr->icount != 0)
test/test_raw.c:                || (rawptr->istart != 0)
test/test_raw.c:                || (semcount(rawptr->isema) != 0)
test/test_raw.c:                || (rawptr->flags != 0)), "Incorrect control block");
test/test_raw.c:    pkt->len = phdr.caplen;
test/test_raw.c:    memcpy(pkt->data, data, phdr.caplen);
test/test_raw.c:    pkt->linkhdr = pkt->data;
test/test_raw.c:    pkt->nethdr = pkt->linkhdr + ETH_HDR_LEN;
test/test_raw.c:    pkt->curr = pkt->nethdr + IPv4_HDR_LEN;
test/test_raw.c:    memcpy(pktA, pkt, sizeof(struct packet) + pkt->len);
test/test_raw.c:    pktA->linkhdr = pktA->data;
test/test_raw.c:    pktA->nethdr = pktA->linkhdr + ETH_HDR_LEN;
test/test_raw.c:    pktA->curr = pktA->nethdr + IPv4_HDR_LEN;
test/test_raw.c:        failif(((rawptr->icount != 0)
test/test_raw.c:                || (semcount(rawptr->isema) != 0)
test/test_raw.c:                || (TRUE == netaddrequal(&rawptr->src[0], &rip))
test/test_raw.c:                || (rawptr->in[0] == pktA)), "Packet enqueued");
test/test_raw.c:    memcpy(pktA, pkt, sizeof(struct packet) + pkt->len);
test/test_raw.c:    pktA->linkhdr = pktA->data;
test/test_raw.c:    pktA->nethdr = pktA->linkhdr + ETH_HDR_LEN;
test/test_raw.c:    pktA->curr = pktA->nethdr + IPv4_HDR_LEN;
test/test_raw.c:        failif(((rawptr->istart != 0)
test/test_raw.c:                || (rawptr->icount != 1)
test/test_raw.c:                || (semcount(rawptr->isema) != 1)
test/test_raw.c:                || (FALSE == netaddrequal(&rawptr->src[0], &rip))
test/test_raw.c:                || (rawptr->in[0] != pktA)), "Incorrectly enqueued");
test/test_raw.c:            || (memcmp(buf, (pkt->data + ETH_HDR_LEN + IPv4_HDR_LEN), 8)
test/test_raw.c:            || (rawptr->icount != 0)
test/test_raw.c:            || (rawptr->istart != 1)
test/test_raw.c:            || (semcount(rawptr->isema) != 0)
test/test_raw.c:            || (rawptr->in[0] != NULL)), "");
test/test_raw.c:    memcpy(pktA, pkt, sizeof(struct packet) + pkt->len);
test/test_raw.c:    pktA->linkhdr = pktA->data;
test/test_raw.c:    pktA->nethdr = pktA->linkhdr + ETH_HDR_LEN;
test/test_raw.c:    pktA->curr = pktA->nethdr + IPv4_HDR_LEN;
test/test_raw.c:    rawptr->flags = RAW_IHDR;
test/test_raw.c:                (memcmp(buf, (pkt->data + ETH_HDR_LEN), IPv4_HDR_LEN + 8)
test/test_raw.c:                 != 0) || (rawptr->icount != 0) || (rawptr->istart != 2)
test/test_raw.c:                || (semcount(rawptr->isema) != 0)
test/test_raw.c:                || (rawptr->in[0] != NULL)), "");
test/test_raw.c:    memcpy(pktA, pkt, sizeof(struct packet) + pkt->len);
test/test_raw.c:    pktA->linkhdr = pktA->data;
test/test_raw.c:    pktA->nethdr = pktA->linkhdr + ETH_HDR_LEN;
test/test_raw.c:    pktA->curr = pktA->nethdr + IPv4_HDR_LEN;
test/test_raw.c:    rawptr->flags = RAW_IACCEPT;
test/test_raw.c:    rawptr->remoteip.type = NULL;
test/test_raw.c:                || (FALSE == netaddrequal(&rawptr->remoteip, &rip))), "");
test/test_raw.c:    memcpy(pktA, pkt, sizeof(struct packet) + pkt->len);
test/test_raw.c:    pktA->linkhdr = pktA->data;
test/test_raw.c:    pktA->nethdr = pktA->linkhdr + ETH_HDR_LEN;
test/test_raw.c:    pktA->curr = pktA->nethdr + IPv4_HDR_LEN;
test/test_raw.c:                (memcmp(buf, (pkt->data + ETH_HDR_LEN + IPv4_HDR_LEN), 2)
test/test_raw.c:        memcpy(pktA, pkt, sizeof(struct packet) + pkt->len);
test/test_raw.c:        pktA->linkhdr = pktA->data;
test/test_raw.c:        pktA->nethdr = pktA->linkhdr + ETH_HDR_LEN;
test/test_raw.c:        pktA->curr = pktA->nethdr + IPv4_HDR_LEN;
test/test_raw.c:        memcpy(pktA, pkt, sizeof(struct packet) + pkt->len);
test/test_raw.c:        pktA->linkhdr = pktA->data;
test/test_raw.c:        pktA->nethdr = pktA->linkhdr + ETH_HDR_LEN;
test/test_raw.c:        pktA->curr = pktA->nethdr + IPv4_HDR_LEN;
test/test_raw.c:        rawptr = &rawtab[devptr->minor];
test/test_raw.c:    failif((rawSend(rawptr, pkt->curr, 8) != SYSERR), "");
test/test_raw.c:    rawptr->flags = RAW_OHDR;
test/test_raw.c:    failif((rawSend(rawptr, pkt->curr, 8) != SYSERR), "");
test/test_raw.c:    nproc = netptr->nproc;
test/test_raw.c:    memcpy(pkt->data, data, phdr.caplen);
test/test_raw.c:    pkt->len = phdr.caplen;
test/test_raw.c:    pkt->linkhdr = pkt->data;
test/test_raw.c:    pkt->nethdr = pkt->linkhdr + ETH_HDR_LEN;
test/test_raw.c:    pkt->curr = pkt->nethdr + IPv4_HDR_LEN;
test/test_raw.c:    while ((wait < MAX_WAIT) && (netptr->nproc == nproc))
test/test_raw.c:        netaddrcpy(&rawptr->remoteip, &rip);
test/test_raw.c:        if (SYSERR == rawSend(rawptr, pkt->nethdr, IPv4_HDR_LEN + 8))
test/test_raw.c:            failif((memcmp(pkt->data, buf, pkt->len) != 0),
test/test_raw.c:    rawptr->flags = NULL;
test/test_raw.c:    netaddrcpy(&rawptr->remoteip, &rip);
test/test_raw.c:    if (SYSERR == rawSend(rawptr, pkt->curr, 8))
test/test_raw.c:        failif((memcmp(pkt->data, buf, pkt->len) != 0),
test/test_raw.c:    if (SYSERR == write(RAW0, pkt->curr, 8))
test/test_raw.c:        failif((memcmp(pkt->data, buf, pkt->len) != 0),
test/test_recursion.c:        t5(times - 1, testArray, index);
test/test_recursion.c:     * lower-priority thread before the higher-priority ones are created */
test/test_recursion.c:    ready(atid = create((void *)t5, INITSTK, 31, "RECURSION-A",
test/test_recursion.c:    ready(btid = create((void *)t5, INITSTK, 32, "RECURSION-B",
test/test_recursion.c:    ready(ctid = create((void *)t5, INITSTK, 34, "RECURSION-C",
test/test_recursion.c:    ready(dtid = create((void *)t5, INITSTK, 32, "RECURSION-D",
test/test_recursion.c:    for (i = 0, j = TIMES; i < 2 * TIMES; i += 2, j--)
test/test_recursion.c:            btid_remaining--;
test/test_recursion.c:            dtid_remaining--;
test/test_recursion.c:    for (i = 6 * TIMES, j = TIMES; i < 8 * TIMES; i += 2, j--)
test/test_schedule.c:     * condition where the running thread may be replaced with an equal-priority
test/test_schedule.c:    ready(atid = create((void *)t4, INITSTK, 31, "PRIORITY-A",
test/test_schedule.c:    ready(btid = create((void *)t4, INITSTK, 32, "PRIORITY-B",
test/test_schedule.c:    ready(ctid = create((void *)t4, INITSTK, 34, "PRIORITY-C",
test/test_schedule.c:    ready(dtid = create((void *)t4, INITSTK, 32, "PRIORITY-D",
test/test_schedule.c:            btid_remaining--;
test/test_schedule.c:            dtid_remaining--;
test/test_semaphore.c:        times--;
test/test_semaphore.c:                 "SEMAPHORE-A", 3, s, 1, &testResult), RESCHED_YES);
test/test_semaphore.c:        && test_checkSemCount(s, -1, verbose)
test/test_semaphore2.c:                 "SEMAPHORE-A", 3, s, 1, &testResult), RESCHED_NO);
test/test_semaphore2.c:                 "SEMAPHORE-B", 3, s, 1, &testResult), RESCHED_NO);
test/test_semaphore2.c:        && test_checkSemCount(s, -2) && test_checkResult(testResult, 0))
test/test_semaphore2.c:        && test_checkSemCount(s, -1) && test_checkResult(testResult, 1))
test/test_semaphore3.c:                 "SEMAPHORE-A", 3, s, 1, &testResult), RESCHED_NO);
test/test_semaphore3.c:                 "SEMAPHORE-B", 3, s, 1, &testResult), RESCHED_YES);
test/test_semaphore3.c:        && test_checkSemCount(s, -1) && test_checkResult(testResult, 1))
test/test_semaphore4.c:                 "SEMAPHORE-A", 3, s, 1, &testResult), RESCHED_YES);
test/test_semaphore4.c:        && test_checkSemCount(s, -1) && test_checkResult(testResult, 0))
test/test_snoop.c:#define ELOOP (-1)
test/test_snoop.c:#define NNETIF (-1)
test/test_snoop.c:        pktA->len = phdr.caplen;
test/test_snoop.c:        pktA->curr = pktA->data;
test/test_snoop.c:        memcpy(pktA->data, data, phdr.caplen);
test/test_snoop.c:    failif((SYSERR != snoopOpen(&cap, "not-a-dev")), "");
test/test_snoop.c:        failif(((NULL == netptr) || (&cap != netptr->capture)),
test/test_snoop.c:    memcpy(pktA->data, data, phdr.caplen);
test/test_snoop.c:    pktA->len = phdr.caplen;
test/test_snoop.c:    pktA->nif = netptr;
test/test_snoop.c:    pktA->curr = pktA->data;
test/test_snoop.c:                memcmp(pktB->data, pktA->data, phdr.caplen)),
test/test_system.c:    failif((SYSERR != getprio(-1)),
test/test_ttydriver.c:        i += read(TTYLOOP, str + i, max - i);
test/test_udp.c:    failif((0 != memcmp(pseudo->srcIp, ipc.addr, IPv4_ADDR_LEN))
test/test_udp.c:           || (0 != memcmp(pseudo->dstIp, ipl.addr, IPv4_ADDR_LEN))
test/test_udp.c:           || (udppkt->srcPort != ptb) || (udppkt->dstPort != pta)
test/test_udp.c:           || (udppkt->len != UDP_HDR_LEN + 7)
test/test_udp.c:           || (0 != strncmp((char *)udppkt->data, "passive", 7)), "");
test/test_udp.c:    pkt->len = UDP_HDR_LEN + datalen;
test/test_udp.c:    pkt->curr -= (3 + (ulong)(pkt->len)) & ~0x03;
test/test_udp.c:    udppkt = (struct udpPkt *)(pkt->curr);
test/test_udp.c:    udppkt->srcPort = hs2net(localpt);
test/test_udp.c:    udppkt->dstPort = hs2net(remotept);
test/test_udp.c:    udppkt->len = hs2net(pkt->len);
test/test_udp.c:    udppkt->chksum = 0;
test/test_udp.c:    bzero(udppkt->data, datalen);
test/test_udp.c:    memcpy(udppkt->data, buf, datalen);
test/test_udp.c:    udppkt->chksum = udpChksum(pkt, UDP_HDR_LEN + datalen,
test/test_umemory.c:/* test_umemory -- allocates and frees memory; tests consistency of
test/test_umemory.c:    failif(NULL != memptr, "Non-NULL pointer detected");
test/test_umemory.c: * compares this sum with the value maintained in thread->memlist.length
test/test_umemory.c:    for (mptr = thread->memlist.next; mptr != NULL; mptr = mptr->next)
test/test_umemory.c:        free += mptr->length;
test/test_umemory.c:    if (thread->memlist.length == free)
test/test_umemory.c:            fnext->fprev = fhead;
test/test_umemory.c:            fnext->flen = size;
test/test_umemory.c:        fhead = fhead->fprev;
test/test_boundedbuffer.c: * @usage		A producer-consumer problem test for the mutex for multicore rpi3
test/test_boundedbuffer.c:	kprintf("---------------------------------\r\n");
test/test_boundedbuffer.c:	kprintf("---------------------------------\r\n");
test/test_threadcreation.c:	kprintf("	       (.-,--.       |      \r\n");
test/test_threadcreation.c:	kprintf("	       (__`--'   ._)        \r\n");
test/test_threadcreation.c:	kprintf("	       /  `-.     |         \r\n");
test/test_threadcreation.c:	kprintf("	      (     ,`-.  |         \r\n");
test/test_threadcreation.c:	kprintf("	       `-,--|_  ) |-.       \r\n");
test/test_threadcreation.c:	kprintf("	        _`.__.'  ,-' )      \r\n");
test/test_threadcreation.c:	kprintf("	       || )  _.-'    |      \r\n");
test/test_threadcreation.c:	kprintf("	       i-|.'|     ,--+.     \r\n");
test/test_threadcreation.c:	kprintf("	     .' .'   |,-'/     )    \r\n");
test/test_threadcreation.c:	kprintf("	  |____          |     |-;' \r\n");
test/test_threadcreation.c:	kprintf("	   |   """"----""|     | |  \r\n");
test/test_threadcreation.c:	kprintf("	   (           ,-'     |/   \r\n");
test/test_threadcreation.c:	kprintf("	    `.         `-,     |    \r\n");
test/test_threadcreation.c:	kprintf("	     |`-._      / /| |} )   \r\n");
test/test_threadcreation.c:	kprintf("	     |    `-.   `' | ||`-'  \r\n");
test/test_threadcreation.c:	kprintf("	     |      |      `-'|     \r\n");
test/test_threadcreation.c:	kprintf("	     )`-.___|         |     \r\n");
test/test_threadcreation.c:	kprintf("	   .'`-.____)`-.___.-'(     \r\n");
test/test_threadcreation.c:	kprintf("	 .'        .'-._____.-|     \r\n");
test/test_threadcreation.c:	kprintf("	`-------/         .   |     \r\n");
test/test_threadcreation.c:	kprintf("	        `--------' '--'     \r\n");
test/test_threadcreation.c:	kprintf("\r\n------------------------------- This is thread 1 -------------------------------\r\n");
test/test_threadcreation.c:	kprintf("\r\n------------------------------- This is thread 2 -------------------------------\r\n");
test/test_threadcreation.c:	kprintf("\r\n------------------------------- This is thread 3 -------------------------------\r\n");
test/test_threadcreation.c:	kprintf("---");
test/test_threadcreation.c:	kprintf("\tName:\t%s\r\n", tthrent->name);
test/test_threadcreation.c:	kprintf("\tState:\t%d\r\n", tthrent->state);
test/test_threadcreation.c:	kprintf("Base of run time stack   : 0x%08X \r\n", tthrent->stkbase);
test/test_threadcreation.c:			tthrent->stkptr);
test/test_threadcreation.c:	kprintf("Stack length of thread   : %8u\r\n", tthrent->stklen);
Binary file test/test_ip.o matches
Binary file test/test_semaphore3.o matches
test/test_semaphore3.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_semaphore3.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_semaphore3.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_semaphore3.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/testhelper.o matches
test/testhelper.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/testhelper.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/testhelper.d:../system/platforms/arm-rpi3/interrupt.h:
test/testhelper.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_mailbox.o matches
test/test_mailbox.d: ../system/platforms/arm-rpi3/interrupt.h \
test/test_mailbox.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
test/test_mailbox.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_mailbox.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_semaphore4.o matches
test/test_semaphore4.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_semaphore4.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_semaphore4.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_semaphore4.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_bigargs.o matches
test/test_bigargs.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_bigargs.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_bigargs.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_bigargs.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_memory.o matches
test/test_memory.d: ../system/platforms/arm-rpi3/interrupt.h \
test/test_memory.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_memory.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_memory.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_messagePass.o matches
test/test_messagePass.d: ../system/platforms/arm-rpi3/interrupt.h \
test/test_messagePass.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_messagePass.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_messagePass.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_bufpool.o matches
test/test_bufpool.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_bufpool.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
test/test_bufpool.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_bufpool.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_threadcreation.o matches
Binary file test/.test_ether.c.swp matches
Binary file test/test_semaphore.o matches
test/test_semaphore.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_semaphore.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_semaphore.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_semaphore.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_deltaQueue.o matches
test/test_deltaQueue.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_deltaQueue.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_deltaQueue.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_deltaQueue.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_netaddr.o matches
test/test_netaddr.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_netaddr.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_netaddr.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_netaddr.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_snoop.o matches
test/test_snoop.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_snoop.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
test/test_snoop.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_snoop.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_ether.o matches
test/test_ether.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
test/test_ether.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_ether.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_ether.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_netif.o matches
test/test_netif.d: ../system/platforms/arm-rpi3/interrupt.h \
test/test_netif.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/ipv4.h \
test/test_netif.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_netif.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_ethloop.o matches
test/test_ethloop.d: ../system/platforms/arm-rpi3/interrupt.h \
test/test_ethloop.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
test/test_ethloop.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_ethloop.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_nvram.o matches
test/test_nvram.d: ../system/platforms/arm-rpi3/interrupt.h \
test/test_nvram.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/stdio.h \
test/test_nvram.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_nvram.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_system.o matches
test/test_system.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
test/test_system.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_system.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_system.d:../system/platforms/arm-rpi3/bcm2837.h:
test/test_ip.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_ip.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
test/test_ip.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_ip.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_preempt.o matches
test/test_preempt.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
test/test_preempt.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_preempt.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_preempt.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_tlb.o matches
test/test_tlb.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
test/test_tlb.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_tlb.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_tlb.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_libCtype.o matches
test/test_libCtype.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_libCtype.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_libCtype.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_libCtype.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_procQueue.o matches
test/test_procQueue.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_procQueue.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_procQueue.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_procQueue.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_ttydriver.o matches
test/test_ttydriver.d: ../system/platforms/arm-rpi3/interrupt.h \
test/test_ttydriver.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_ttydriver.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_ttydriver.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_libLimits.o matches
test/test_libLimits.d: ../system/platforms/arm-rpi3/interrupt.h \
test/test_libLimits.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_libLimits.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_libLimits.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_raw.o matches
test/test_raw.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_raw.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/debug.h \
test/test_raw.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_raw.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_udp.o matches
test/test_udp.d: ../include/stdint.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_udp.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/memory.h \
test/test_udp.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_udp.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_libStdio.o matches
test/test_libStdio.d: ../system/platforms/arm-rpi3/interrupt.h ../include/stddef.h \
test/test_libStdio.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/limits.h \
test/test_libStdio.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_libStdio.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_recursion.o matches
test/test_recursion.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_recursion.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_recursion.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_recursion.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_umemory.o matches
test/test_umemory.d: ../system/platforms/arm-rpi3/interrupt.h \
test/test_umemory.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_umemory.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_umemory.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_schedule.o matches
test/test_arp.d: ../system/platforms/arm-rpi3/interrupt.h \
test/test_arp.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/ipv4.h \
test/test_arp.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_arp.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_libStdlib.o matches
test/test_libStdlib.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_libStdlib.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_libStdlib.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_libStdlib.d:../system/platforms/arm-rpi3/bcm2837.h:
test/test_schedule.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_schedule.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_schedule.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_schedule.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_libString.o matches
test/test_libString.d: ../system/platforms/arm-rpi3/interrupt.h \
test/test_libString.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_libString.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_libString.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_semaphore2.o matches
test/test_semaphore2.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_semaphore2.d: ../system/platforms/arm-rpi3/bcm2837.h ../include/semaphore.h \
test/test_semaphore2.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_semaphore2.d:../system/platforms/arm-rpi3/bcm2837.h:
test/test_threadcreation.d: ../include/thread.h ../system/platforms/arm-rpi3/interrupt.h \
test/test_threadcreation.d: ../include/stddef.h ../system/platforms/arm-rpi3/bcm2837.h \
test/test_threadcreation.d:../system/platforms/arm-rpi3/interrupt.h:
test/test_threadcreation.d:../system/platforms/arm-rpi3/bcm2837.h:
Binary file test/test_semaphore_core.o matches
test/test_semaphore_core.d: ../include/core.h ../system/platforms/arm-rpi3/mmu.h ../include/stddef.h
test/test_semaphore_core.d:../system/platforms/arm-rpi3/mmu.h:
Binary file test/test_boundedbuffer.o matches
Binary file test/test_arp.o matches
test/test_boundedbuffer.d: ../system/platforms/arm-rpi3/mutex.h ../system/platforms/arm-rpi3/mmu.h \
test/test_boundedbuffer.d:../system/platforms/arm-rpi3/mutex.h:
test/test_boundedbuffer.d:../system/platforms/arm-rpi3/mmu.h:
